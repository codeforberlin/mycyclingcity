<!-- Copyright (c) 2026 SAI-Lab / MyCyclingCity
     SPDX-License-Identifier: AGPL-3.0-or-later
     
     @file    kiosk_playlist.html
     @author  Roland Rutz
     @note    This code was developed with the assistance of AI (LLMs).
-->

{% load i18n %}
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% trans "Kiosk-Anzeige" %} - {{ device.name }}</title>
    {% url 'favicon' as favicon_url %}
    <link rel="icon" type="image/png" href="{{ favicon_url }}">
    <!-- Base stylesheets and scripts -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-geometryutil@0.10.3/src/leaflet.geometryutil.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #kiosk-content-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        .view-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        .flex {
            display: flex;
        }
        .items-center {
            align-items: center;
        }
        .justify-center {
            justify-content: center;
        }
        .h-full {
            height: 100%;
        }
        .text-center {
            text-align: center;
        }
        .text-2xl {
            font-size: 1.5rem;
            line-height: 2rem;
        }
        .text-lg {
            font-size: 1.125rem;
            line-height: 1.75rem;
        }
        .text-sm {
            font-size: 0.875rem;
            line-height: 1.25rem;
        }
        .font-bold {
            font-weight: 700;
        }
        .mb-4 {
            margin-bottom: 1rem;
        }
        .mt-4 {
            margin-top: 1rem;
        }
        .bg-slate-900 {
            background-color: rgb(15 23 42);
        }
        .text-white {
            color: rgb(255 255 255);
        }
        .text-red-500 {
            color: rgb(239 68 68);
        }
        .text-gray-400 {
            color: rgb(156 163 175);
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        .rounded-full {
            border-radius: 9999px;
        }
        .h-12 {
            height: 3rem;
        }
        .w-12 {
            width: 3rem;
        }
        .border-b-2 {
            border-bottom-width: 2px;
        }
        .border-white {
            border-color: rgb(255 255 255);
        }
        .mx-auto {
            margin-left: auto;
            margin-right: auto;
        }
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body class="h-screen overflow-hidden bg-slate-900 text-white">
    <!-- Main content container -->
    <div id="kiosk-content-container">
        <!-- Views will be loaded here by the playlist controller -->
        <div class="view-container" id="current-view">
            <div class="flex items-center justify-center h-full">
                <div class="text-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4"></div>
                    <p>{% trans "Playlist wird geladen..." %}</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Kiosk Playlist Controller
        (function() {
            'use strict';
            
            const DEVICE_UID = '{{ device_uid }}';
            const API_BASE = '/api/kiosk/' + DEVICE_UID;
            const PLAYLIST_UPDATE_INTERVAL = 30000; // 30 seconds
            const COMMAND_CHECK_INTERVAL = 30000; // 30 seconds
            
            let currentPlaylist = [];
            let currentPlaylistHash = null;
            let currentEntryIndex = 0;
            let rotationTimer = null;
            let playlistUpdateTimer = null;
            let commandCheckTimer = null;
            
            /**
             * Show configuration required page
             */
            function showConfigurationPage() {
                const container = document.getElementById('kiosk-content-container');
                if (container) {
                    const emailSubject = encodeURIComponent('Kiosk Konfiguration');
                    const emailBody = encodeURIComponent(`Hallo,\n\nIch benÃ¶tige Hilfe bei der Konfiguration des Kiosk-GerÃ¤ts.\n\nGerÃ¤te-ID: ${DEVICE_UID}\n\nVielen Dank!`);
                    const emailLink = `mailto:mcc-kontakt@wirzaehlen.de?subject=${emailSubject}&body=${emailBody}`;
                    
                    container.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #ffffff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;">
                            <div style="text-align: center; padding: 3rem; max-width: 600px; animation: fadeIn 1s ease-in;">
                                <div style="font-size: 6rem; margin-bottom: 2rem; animation: pulse 2s ease-in-out infinite;">ðŸ“‹</div>
                                <h1 style="font-size: 2.5rem; font-weight: 700; margin-bottom: 1rem; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);">Konfiguration erforderlich</h1>
                                <p style="font-size: 1.25rem; line-height: 1.6; margin-bottom: 1rem; opacity: 0.95;">Dieses GerÃ¤t ist aktiv, aber noch nicht konfiguriert.</p>
                                <p style="font-size: 1.25rem; line-height: 1.6; margin-bottom: 1rem; opacity: 0.95;">Bitte kontaktieren Sie den Administrator, um die Anzeige zu aktivieren.</p>
                                <a href="${emailLink}" 
                                   style="display: inline-block; margin-top: 2rem; padding: 1rem 2rem; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 8px; color: #ffffff; text-decoration: none; font-size: 1.1rem; font-weight: 600; transition: all 0.3s ease; backdrop-filter: blur(10px);">
                                    ðŸ“§ E-Mail senden
                                </a>
                            </div>
                        </div>
                        <style>
                            @keyframes fadeIn {
                                from { opacity: 0; transform: translateY(-20px); }
                                to { opacity: 1; transform: translateY(0); }
                            }
                            @keyframes pulse {
                                0%, 100% { transform: scale(1); opacity: 1; }
                                50% { transform: scale(1.1); opacity: 0.8; }
                            }
                            a:hover {
                                background: rgba(255, 255, 255, 0.3) !important;
                                border-color: rgba(255, 255, 255, 0.8) !important;
                                transform: translateY(-2px);
                                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                            }
                        </style>
                    `;
                }
            }
            
            /**
             * Show maintenance page
             */
            function showMaintenancePage() {
                const container = document.getElementById('kiosk-content-container');
                if (container) {
                    container.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #ffffff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;">
                            <div style="text-align: center; padding: 3rem; max-width: 600px; animation: fadeIn 1s ease-in;">
                                <div style="font-size: 6rem; margin-bottom: 2rem; animation: pulse 2s ease-in-out infinite;">ðŸ”§</div>
                                <h1 style="font-size: 2.5rem; font-weight: 700; margin-bottom: 1rem; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);">Wartung</h1>
                                <p style="font-size: 1.25rem; line-height: 1.6; margin-bottom: 0.5rem; opacity: 0.95;">Dieses GerÃ¤t wird derzeit gewartet.</p>
                                <p style="font-size: 1.25rem; line-height: 1.6; margin-bottom: 0.5rem; opacity: 0.95;">Bitte versuchen Sie es spÃ¤ter erneut.</p>
                                <div style="margin-top: 2rem; padding: 1rem; background: rgba(255, 255, 255, 0.1); border-radius: 8px; font-size: 0.9rem; opacity: 0.8;">
                                    GerÃ¤te-ID: ${DEVICE_UID}
                                </div>
                            </div>
                        </div>
                        <style>
                            @keyframes fadeIn {
                                from { opacity: 0; transform: translateY(-20px); }
                                to { opacity: 1; transform: translateY(0); }
                            }
                            @keyframes pulse {
                                0%, 100% { transform: scale(1); opacity: 1; }
                                50% { transform: scale(1.1); opacity: 0.8; }
                            }
                        </style>
                    `;
                }
            }
            
            /**
             * Fetch playlist from server
             */
            async function fetchPlaylist() {
                try {
                    const response = await fetch(API_BASE + '/playlist');
                    const data = await response.json();
                    
                    // Check if response contains error
                    if (!response.ok) {
                        // Check for maintenance mode (503 status)
                        if (response.status === 503 || data.maintenance_mode || data.error_code === 'DEVICE_INACTIVE') {
                            data.maintenance_mode = true;
                        }
                        return data; // Return error data
                    }
                    
                    return data;
                } catch (error) {
                    console.error('Failed to fetch playlist:', error);
                    return {
                        error: 'Network error',
                        error_code: 'NETWORK_ERROR',
                        details: error.message
                    };
                }
            }
            
            /**
             * Fetch and execute pending commands
             */
            async function checkCommands() {
                try {
                    const response = await fetch(API_BASE + '/commands');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const data = await response.json();
                    
                    // Execute commands
                    for (const command of data.commands || []) {
                        console.log('Executing command:', command);
                        if (command === 'RELOAD') {
                            location.reload();
                        } else if (command === 'REBOOT') {
                            // Could trigger system reboot via API call
                            console.warn('REBOOT command received (not executed in browser)');
                        } else if (command.startsWith('SET_BRIGHTNESS:')) {
                            // Brightness is handled by the management command on the client
                            console.log('Brightness change requested:', command);
                        }
                    }
                    
                    // Update brightness if changed
                    if (data.brightness !== undefined) {
                        // Brightness is handled by hardware control command
                        console.log('Brightness setting:', data.brightness);
                    }
                } catch (error) {
                    console.error('Failed to check commands:', error);
                }
            }
            
            /**
             * Load a view based on playlist entry
             */
            function loadView(entry) {
                const container = document.getElementById('kiosk-content-container');
                const currentView = document.getElementById('current-view');
                if (!container || !currentView) {
                    console.error('Container elements not found');
                    return;
                }
                
                // Hide any visible overlays before loading new view
                const existingMilestoneOverlay = currentView.querySelector('#milestone-overlay');
                if (existingMilestoneOverlay) {
                    existingMilestoneOverlay.classList.add('hidden');
                    existingMilestoneOverlay.style.display = 'none';
                }
                
                // Build URL based on view type
                let url = '';
                const params = [];
                
                if (entry.view_type === 'leaderboard') {
                    // Use Django URL reverse to get correct URL with language prefix
                    url = '{% url "leaderboard:leaderboard_page" %}';
                    if (entry.event_filter_id) {
                        params.push('event_id=' + entry.event_filter_id);
                    }
                    if (entry.group_filter_name) {
                        params.push('group=' + encodeURIComponent(entry.group_filter_name));
                    }
                } else if (entry.view_type === 'eventboard') {
                    // Use Django URL reverse to get correct URL with language prefix
                    url = '{% url "map:map_page" %}';
                    if (entry.event_filter_id) {
                        params.push('event_id=' + entry.event_filter_id);
                    }
                    // Use group_id if available, otherwise fall back to group_name
                    if (entry.group_filter_id) {
                        params.push('group_id=' + encodeURIComponent(entry.group_filter_id));
                    } else if (entry.group_filter_name) {
                        params.push('group_name=' + encodeURIComponent(entry.group_filter_name));
                    }
                    // Add track filter if available
                    if (entry.track_filter_ids && entry.track_filter_ids.length > 0) {
                        params.push('track_ids=' + encodeURIComponent(entry.track_filter_ids.join(',')));
                    }
                } else if (entry.view_type === 'map') {
                    // Use Django URL reverse to get correct URL with language prefix
                    url = '{% url "map:map_page" %}';
                    // Use group_id if available, otherwise fall back to group_name
                    if (entry.group_filter_id) {
                        params.push('group_id=' + encodeURIComponent(entry.group_filter_id));
                    } else if (entry.group_filter_name) {
                        params.push('group_name=' + encodeURIComponent(entry.group_filter_name));
                    }
                    // Add track filter if available
                    if (entry.track_filter_ids && entry.track_filter_ids.length > 0) {
                        params.push('track_ids=' + encodeURIComponent(entry.track_filter_ids.join(',')));
                    }
                } else {
                    console.error('Unknown view type:', entry.view_type);
                    return;
                }
                
                // Append query parameters if any
                if (params.length > 0) {
                    url += '?' + params.join('&');
                }
                
                console.log('Fetching URL:', url);
                
                // Use fetch to load the view and manually insert it
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.text();
                    })
                    .then(html => {
                        // Parse the HTML and extract both head and body content
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        
                        // Extract inline styles from head and add them to document
                        const headStyles = doc.head.querySelectorAll('style');
                        headStyles.forEach((style, index) => {
                            const styleContent = style.textContent || style.innerHTML;
                            if (styleContent) {
                                // Check if style already exists
                                const styleId = `dynamic-style-${entry.view_type}`;
                                let existingStyle = document.getElementById(styleId);
                                if (!existingStyle) {
                                    existingStyle = document.createElement('style');
                                    existingStyle.id = styleId;
                                    document.head.appendChild(existingStyle);
                                }
                                existingStyle.textContent = styleContent;
                            }
                        });
                        
                        // Extract external stylesheets from head and add them to document
                        const headLinks = doc.head.querySelectorAll('link[rel="stylesheet"]');
                        headLinks.forEach((link) => {
                            const href = link.getAttribute('href');
                            if (href) {
                                // Check if stylesheet already exists
                                const existingLink = document.querySelector(`link[href="${href}"]`);
                                if (!existingLink) {
                                    const newLink = document.createElement('link');
                                    newLink.rel = 'stylesheet';
                                    newLink.href = href;
                                    // Copy other attributes if present
                                    if (link.hasAttribute('media')) {
                                        newLink.media = link.getAttribute('media');
                                    }
                                    document.head.appendChild(newLink);
                                }
                            }
                        });
                        
                        // Get the body content (or the main container)
                        let content = null;
                        
                        // Priority 1: Look for view-container
                        const viewContainer = doc.querySelector('#view-container');
                        if (viewContainer) {
                            content = viewContainer.cloneNode(true);
                        } else {
                            // Priority 2: Look for leaderboard-view
                            const leaderboardView = doc.querySelector('#leaderboard-view');
                            if (leaderboardView) {
                                // Create a wrapper container for leaderboard view with Activity Toasts
                                content = document.createElement('div');
                                content.style.width = '100%';
                                content.style.height = '100%';
                                content.style.position = 'relative';
                                
                                // Clone the leaderboard view
                                content.appendChild(leaderboardView.cloneNode(true));
                                
                                // Also clone the Activity Toast Container (like in map views)
                                const activityToastContainer = doc.querySelector('#activity-toast-container');
                                if (activityToastContainer) {
                                    const clonedActivityToastContainer = activityToastContainer.cloneNode(true);
                                    // Ensure it's positioned correctly for kiosk mode
                                    clonedActivityToastContainer.style.position = 'fixed';
                                    clonedActivityToastContainer.style.top = '20px';
                                    clonedActivityToastContainer.style.right = '20px';
                                    clonedActivityToastContainer.style.zIndex = '2000';
                                    content.appendChild(clonedActivityToastContainer);
                                }
                                
                                // Also clone the hidden ticker data source (needed for Activity Toasts)
                                const tickerDataSource = doc.querySelector('#ticker-data-source');
                                if (tickerDataSource) {
                                    content.appendChild(tickerDataSource.cloneNode(true));
                                }
                            } else {
                                // Priority 3: For map view, look for #section-map or #map container
                                if (entry.view_type === 'map' || entry.view_type === 'eventboard') {
                                    // Create a wrapper container for map view with overlays and chips
                                    content = document.createElement('div');
                                    content.style.width = '100%';
                                    content.style.height = '100%';
                                    content.style.position = 'relative';
                                    
                                    // Look for section-map first (dashboard.html structure)
                                    const sectionMap = doc.querySelector('#section-map');
                                    if (sectionMap) {
                                        content.appendChild(sectionMap.cloneNode(true));
                                    } else {
                                        // Fallback: look for #map element
                                        const mapElement = doc.querySelector('#map');
                                        if (mapElement) {
                                            // Clone the map element and its parent's siblings
                                            if (mapElement.parentElement) {
                                                Array.from(mapElement.parentElement.children).forEach(child => {
                                                    if (child.id === 'map' || child.classList.contains('info-panel') || child.id === 'ticker-target') {
                                                        content.appendChild(child.cloneNode(true));
                                                    }
                                                });
                                            } else {
                                                content.appendChild(mapElement.cloneNode(true));
                                            }
                                        }
                                    }
                                    
                                    // Also clone the Champions Overlay and Milestone Overlay
                                    const championsOverlay = doc.querySelector('#champions-overlay');
                                    if (championsOverlay) {
                                        const clonedChampionsOverlay = championsOverlay.cloneNode(true);
                                        // Ensure it's positioned correctly for kiosk mode
                                        clonedChampionsOverlay.style.position = 'fixed';
                                        clonedChampionsOverlay.style.bottom = '20px';
                                        clonedChampionsOverlay.style.left = '20px';
                                        clonedChampionsOverlay.style.zIndex = '4000';
                                        // Keep it hidden initially - it will be shown by JavaScript when champions are available
                                        clonedChampionsOverlay.classList.add('hidden');
                                        clonedChampionsOverlay.style.display = 'none'; // Start hidden
                                        content.appendChild(clonedChampionsOverlay);
                                    }
                                    
                                    const milestoneOverlay = doc.querySelector('#milestone-overlay');
                                    if (milestoneOverlay) {
                                        const clonedMilestoneOverlay = milestoneOverlay.cloneNode(true);
                                        // Ensure it's positioned correctly for kiosk mode
                                        clonedMilestoneOverlay.style.position = 'fixed';
                                        clonedMilestoneOverlay.style.bottom = '20px';
                                        clonedMilestoneOverlay.style.right = '20px';
                                        clonedMilestoneOverlay.style.zIndex = '4001';
                                        // Keep it hidden initially - it will be shown by JavaScript when a milestone is reached
                                        clonedMilestoneOverlay.classList.add('hidden');
                                        clonedMilestoneOverlay.style.display = 'none'; // Start hidden
                                        content.appendChild(clonedMilestoneOverlay);
                                    }
                                    
                                    // Filter Chips (Activity Chips) are NOT displayed in Kiosk Map view
                                    // They will only be shown when a dedicated Ranking playlist view is implemented
                                    // Removed: cloning of filter-chips-container and ranking-filter-bar for map views
                                    
                                    // Also clone the Activity Toast Container
                                    const activityToastContainer = doc.querySelector('#activity-toast-container');
                                    if (activityToastContainer) {
                                        content.appendChild(activityToastContainer.cloneNode(true));
                                    }
                                } else {
                                    // Priority 4: Use body content for other views
                                    content = document.createElement('div');
                                    if (doc.body) {
                                        while (doc.body.firstChild) {
                                            content.appendChild(doc.body.firstChild.cloneNode(true));
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Clean up previous view resources before replacing content
                        // Remove milestone markers from previous view
                        if (window.milestoneMarkers) {
                            try {
                                window.milestoneMarkers.clearLayers();
                                console.log('Kiosk: Cleared milestone markers from previous view');
                            } catch (e) {
                                console.warn('Kiosk: Error clearing milestone markers:', e);
                            }
                        }
                        // Reset milestone marker map
                        if (window.milestoneMarkerMap) {
                            window.milestoneMarkerMap = {};
                        }
                        // Clear milestone update interval
                        if (window.kioskMilestoneUpdateInterval) {
                            clearInterval(window.kioskMilestoneUpdateInterval);
                            window.kioskMilestoneUpdateInterval = null;
                        }
                        
                        // Clear milestone check interval
                        if (window.kioskNewMilestoneCheckInterval) {
                            clearInterval(window.kioskNewMilestoneCheckInterval);
                            window.kioskNewMilestoneCheckInterval = null;
                        }
                        
                        // Do NOT reset shown milestone IDs when switching views
                        // kioskShownMilestoneIds persists across view switches within the same session
                        // This ensures that milestones already shown in this session are not shown again after view refresh
                        // Only initialize if not already set (first load)
                        if (!window.kioskShownMilestoneIds || window.kioskShownMilestoneIds.size === 0) {
                            // Try to load from sessionStorage (session-scoped, not localStorage)
                            var storedShownIds = sessionStorage.getItem('kioskShownMilestoneIds');
                            if (storedShownIds) {
                                try {
                                    var parsedIds = JSON.parse(storedShownIds);
                                    window.kioskShownMilestoneIds = new Set(parsedIds);
                                    console.log('Kiosk: Loaded shownMilestoneIds from sessionStorage:', Array.from(window.kioskShownMilestoneIds));
                                } catch (e) {
                                    console.warn('Kiosk: Error parsing stored shownMilestoneIds from sessionStorage:', e);
                                    window.kioskShownMilestoneIds = new Set();
                                }
                            } else {
                                window.kioskShownMilestoneIds = new Set();
                                console.log('Kiosk: Initialized shownMilestoneIds as empty set (no sessionStorage data)');
                            }
                        } else {
                            console.log('Kiosk: Keeping existing shownMilestoneIds across view switch:', Array.from(window.kioskShownMilestoneIds));
                        }
                        
                        // Replace the current view content
                        currentView.innerHTML = '';
                        if (content) {
                            currentView.appendChild(content);
                        }
                        
                        // Re-initialize HTMX on the new content
                        if (typeof htmx !== 'undefined') {
                            htmx.process(currentView);
                        }
                        
                        // Execute any scripts from the loaded page
                        const bodyScripts = doc.querySelectorAll('script');
                        let scriptExecutionPromises = [];
                        bodyScripts.forEach((script) => {
                            if (script.src) {
                                // External script - check if already loaded
                                if (!document.querySelector(`script[src="${script.src}"]`)) {
                                    const newScript = document.createElement('script');
                                    newScript.src = script.src;
                                    // For Leaflet, wait for it to load before initializing map
                                    if (script.src.includes('leaflet')) {
                                        const leafletPromise = new Promise((resolve) => {
                                            newScript.onload = resolve;
                                            newScript.onerror = resolve; // Resolve even on error to not block
                                        });
                                        scriptExecutionPromises.push(leafletPromise);
                                        newScript.onload = function() {
                                            // Re-initialize map if it's a map view
                                            if (entry.view_type === 'map' || entry.view_type === 'eventboard') {
                                                setTimeout(() => {
                                                    // Check if map needs to be re-initialized
                                                    const mapElement = currentView.querySelector('#map');
                                                    if (mapElement && typeof L !== 'undefined' && !mapElement._leaflet_id) {
                                                        try {
                                                            const map = L.map('map').setView([51.1657, 10.4515], 6);
                                                            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                                                maxZoom: 19,
                                                                attribution: 'Â© OpenStreetMap-Mitwirkende'
                                                            }).addTo(map);
                                                            console.log('Map re-initialized for kiosk view');
                                                        } catch (e) {
                                                            console.error('Error re-initializing map:', e);
                                                        }
                                                    }
                                                }, 100);
                                            }
                                        };
                                    }
                                    document.head.appendChild(newScript);
                                }
                            } else if (script.textContent) {
                                // Inline script - execute it
                                try {
                                    let scriptContent = script.textContent;
                                    
                                    // For map views, modify script to use the correct container and preserve map reference
                                    if ((entry.view_type === 'map' || entry.view_type === 'eventboard') && scriptContent.includes("L.map('map')")) {
                                        // Replace L.map('map') with a reference to the actual element in currentView
                                        const mapElement = currentView.querySelector('#map');
                                        if (mapElement) {
                                            // Store map reference globally for kiosk context
                                            scriptContent = scriptContent.replace(/var map = L\.map\(['"]map['"]\)/g, 
                                                `var map = (function() {
                                                    const mapEl = document.querySelector('#kiosk-content-container #current-view #map');
                                                    if (mapEl && !mapEl._leaflet_id) {
                                                        return L.map(mapEl);
                                                    } else if (mapEl && mapEl._leaflet_id) {
                                                        return L.map(mapEl);
                                                    } else {
                                                        return L.map('map');
                                                    }
                                                })()`);
                                            
                                            // Also replace standalone L.map('map') calls
                                            scriptContent = scriptContent.replace(/L\.map\(['"]map['"]\)/g, 
                                                `(function() {
                                                    const mapEl = document.querySelector('#kiosk-content-container #current-view #map');
                                                    if (mapEl && !mapEl._leaflet_id) {
                                                        return L.map(mapEl);
                                                    } else if (mapEl && mapEl._leaflet_id) {
                                                        return L.map(mapEl);
                                                    } else {
                                                        return L.map('map');
                                                    }
                                                })()`);
                                        }
                                    }
                                    
                                    const newScript = document.createElement('script');
                                    newScript.textContent = scriptContent;
                                    
                                    // For map views, wrap script execution to ensure functions are available globally
                                    if (entry.view_type === 'map' || entry.view_type === 'eventboard') {
                                        // Don't wrap in IIFE - execute directly so functions are in global scope
                                        // But ensure variables are still available globally
                                        const wrappedScript = `
                                            ${scriptContent}
                                            // Ensure functions and variables are available globally after execution
                                            if (typeof map !== 'undefined') {
                                                window.map = map;
                                            }
                                            if (typeof refreshAvatars !== 'undefined') {
                                                window.refreshAvatars = refreshAvatars;
                                            }
                                            if (typeof updateMapIcons !== 'undefined') {
                                                window.updateMapIcons = updateMapIcons;
                                            }
                                            if (typeof calculatePosition !== 'undefined') {
                                                window.calculatePosition = calculatePosition;
                                            }
                                            if (typeof polylineLookup !== 'undefined') {
                                                window.polylineLookup = polylineLookup;
                                            }
                                            if (typeof avatarMarkers !== 'undefined') {
                                                window.avatarMarkers = avatarMarkers;
                                            }
                                            if (typeof showMilestoneOverlay !== 'undefined') {
                                                window.showMilestoneOverlay = showMilestoneOverlay;
                                            }
                                            if (typeof closeMilestoneOverlay !== 'undefined') {
                                                // Store original function
                                                const originalCloseMilestoneOverlay = closeMilestoneOverlay;
                                                // Wrap closeMilestoneOverlay to work in kiosk context
                                                window.closeMilestoneOverlay = function() {
                                                    // Try to find overlay in active view container first
                                                    const currentView = document.querySelector('.kiosk-view-container.active');
                                                    if (currentView) {
                                                        const overlay = currentView.querySelector('#milestone-overlay');
                                                        const card = currentView.querySelector('#milestone-card');
                                                        if (overlay && card) {
                                                            card.classList.add('fade-out');
                                                            setTimeout(function() {
                                                                overlay.classList.add('hidden');
                                                                overlay.style.display = 'none';
                                                            }, 300);
                                                            return;
                                                        }
                                                    }
                                                    // Fallback to original function if available
                                                    if (typeof originalCloseMilestoneOverlay === 'function') {
                                                        originalCloseMilestoneOverlay();
                                                    } else {
                                                        // Last resort: try document.getElementById
                                                        const overlay = document.getElementById('milestone-overlay');
                                                        const card = document.getElementById('milestone-card');
                                                        if (overlay && card) {
                                                            card.classList.add('fade-out');
                                                            setTimeout(function() {
                                                                overlay.classList.add('hidden');
                                                                overlay.style.display = 'none';
                                                            }, 300);
                                                        }
                                                    }
                                                };
                                            } else {
                                                // Create a basic closeMilestoneOverlay function if it doesn't exist
                                                window.closeMilestoneOverlay = function() {
                                                    const currentView = document.querySelector('.kiosk-view-container.active');
                                                    if (currentView) {
                                                        const overlay = currentView.querySelector('#milestone-overlay');
                                                        const card = currentView.querySelector('#milestone-card');
                                                        if (overlay && card) {
                                                            card.classList.add('fade-out');
                                                            setTimeout(function() {
                                                                overlay.classList.add('hidden');
                                                                overlay.style.display = 'none';
                                                            }, 300);
                                                        }
                                                    }
                                                };
                                            }
                                            // Make updateRankingFilterChips available globally
                                            if (typeof updateRankingFilterChips !== 'undefined') {
                                                window.updateRankingFilterChips = updateRankingFilterChips;
                                            }
                                            
                                            console.log('Kiosk: Functions and variables made available globally', {
                                                map: typeof window.map,
                                                refreshAvatars: typeof window.refreshAvatars,
                                                updateMapIcons: typeof window.updateMapIcons,
                                                calculatePosition: typeof window.calculatePosition,
                                                polylineLookup: typeof window.polylineLookup,
                                                avatarMarkers: typeof window.avatarMarkers,
                                                showMilestoneOverlay: typeof window.showMilestoneOverlay,
                                                closeMilestoneOverlay: typeof window.closeMilestoneOverlay,
                                                updateRankingFilterChips: typeof window.updateRankingFilterChips
                                            });
                                        `;
                                        newScript.textContent = wrappedScript;
                                    }
                                    
                                    document.body.appendChild(newScript);
                                    
                                    // Remove after execution to avoid duplicates
                                    setTimeout(() => {
                                        if (newScript.parentNode) {
                                            newScript.remove();
                                        }
                                    }, 500);
                                } catch (e) {
                                    console.error('Error executing inline script:', e);
                                }
                            }
                        });
                        
                        // For map views, ensure map is initialized after content is loaded
                        if (entry.view_type === 'map' || entry.view_type === 'eventboard') {
                            setTimeout(() => {
                                // Filter Chips are not displayed in Kiosk Map view
                                // No need to call updateRankingFilterChips for map views
                                
                                const mapElement = currentView.querySelector('#map');
                                if (mapElement && typeof L !== 'undefined') {
                                    try {
                                        // Check if map is already initialized (from the loaded script)
                                        if (mapElement._leaflet_id) {
                                            // Map already initialized by the loaded script, get the existing map instance
                                            // Don't try to re-initialize, just get the existing instance
                                            let existingMap = null;
                                            try {
                                                // Try to get the map instance from the element
                                                existingMap = mapElement._leaflet;
                                                if (!existingMap) {
                                                    // If not available, try to get it from window.map
                                                    existingMap = window.map;
                                                }
                                                if (existingMap) {
                                                    existingMap.invalidateSize();
                                                    console.log('Map size invalidated for kiosk view');
                                                }
                                            } catch (e) {
                                                console.warn('Could not invalidate map size:', e);
                                            }
                                            
                                            // Trigger avatar refresh after size invalidation
                                            // Wait a bit to ensure scripts have executed and functions are available
                                            setTimeout(() => {
                                                // First, try to ensure functions are in global scope
                                                if (typeof map !== 'undefined' && !window.map) {
                                                    window.map = map;
                                                }
                                                if (typeof refreshAvatars !== 'undefined') {
                                                    // Wrap refreshAvatars to ensure it uses window.updateChampionsOverlay
                                                    const originalRefreshAvatars = refreshAvatars;
                                                    window.refreshAvatars = function(avatars) {
                                                        // Call original function
                                                        const result = originalRefreshAvatars(avatars);
                                                        
                                                        // After refreshAvatars completes, ensure updateChampionsOverlay is called with window version
                                                        // refreshAvatars internally calls updateChampionsOverlay, but we need to ensure it uses the kiosk version
                                                        setTimeout(() => {
                                                            if (window.allFinishAvatars && typeof window.updateChampionsOverlay === 'function') {
                                                                console.log('Kiosk: Calling window.updateChampionsOverlay after refreshAvatars');
                                                                window.updateChampionsOverlay(window.allFinishAvatars);
                                                            }
                                                        }, 50);
                                                        
                                                        return result;
                                                    };
                                                }
                                                if (typeof updateMapIcons !== 'undefined' && !window.updateMapIcons) {
                                                    window.updateMapIcons = updateMapIcons;
                                                }
                                                if (typeof polylineLookup !== 'undefined' && !window.polylineLookup) {
                                                    window.polylineLookup = polylineLookup;
                                                }
                                                if (typeof avatarMarkers !== 'undefined' && !window.avatarMarkers) {
                                                    window.avatarMarkers = avatarMarkers;
                                                }
                                                if (typeof calculatePosition !== 'undefined' && !window.calculatePosition) {
                                                    window.calculatePosition = calculatePosition;
                                                }
                                                // Always wrap updateChampionsOverlay for kiosk mode, even if it's already set
                                                // This ensures the kiosk-specific version is used
                                                // Store track_filter_ids from entry for filtering
                                                const storedTrackFilterIds = entry.track_filter_ids || [];
                                                if (typeof updateChampionsOverlay !== 'undefined') {
                                                    // Wrap updateChampionsOverlay to work in kiosk mode
                                                    const originalUpdateChampionsOverlay = updateChampionsOverlay;
                                                    // Override both local and global versions
                                                    window.updateChampionsOverlay = function(allFinishAvatars) {
                                                        console.log('Kiosk: updateChampionsOverlay called (wrapped version)', {
                                                            allFinishAvatars: allFinishAvatars,
                                                            allFinishAvatarsLength: allFinishAvatars ? allFinishAvatars.length : 0,
                                                            trackFilterIds: storedTrackFilterIds,
                                                            trackFilterCount: storedTrackFilterIds.length
                                                        });
                                                        
                                                        // In kiosk mode, only show Champions Overlay if exactly one track is defined
                                                        // Multiple tracks would make the overlay confusing
                                                        if (storedTrackFilterIds.length !== 1) {
                                                            console.log('Kiosk: Champions overlay hidden - not exactly one track defined', {
                                                                trackCount: storedTrackFilterIds.length,
                                                                trackIds: storedTrackFilterIds
                                                            });
                                                            const currentView = document.getElementById('current-view');
                                                            if (currentView) {
                                                                const overlay = currentView.querySelector('#champions-overlay');
                                                                if (overlay) {
                                                                    overlay.classList.add('hidden');
                                                                    overlay.style.display = 'none';
                                                                }
                                                            }
                                                            return;
                                                        }
                                                        
                                                        // Get the single active track ID
                                                        const activeTrackId = parseInt(storedTrackFilterIds[0]);
                                                        
                                                        // In kiosk mode, find overlay in current-view container
                                                        const currentView = document.getElementById('current-view');
                                                        console.log('Kiosk: currentView found:', !!currentView);
                                                        
                                                        if (!currentView) {
                                                            console.warn('Kiosk: currentView not found, falling back to original function');
                                                            // Fallback to original function
                                                            if (typeof originalUpdateChampionsOverlay === 'function') {
                                                                return originalUpdateChampionsOverlay(allFinishAvatars);
                                                            }
                                                            return;
                                                        }
                                                        
                                                        const overlay = currentView.querySelector('#champions-overlay');
                                                        const miniPodium = currentView.querySelector('#mini-podium');
                                                        const heroCards = currentView.querySelector('#hero-cards');
                                                        
                                                        console.log('Kiosk: Overlay elements found', {
                                                            overlay: !!overlay,
                                                            miniPodium: !!miniPodium,
                                                            heroCards: !!heroCards,
                                                            currentViewHTML: currentView.innerHTML.substring(0, 500)
                                                        });
                                                        
                                                        if (!overlay || !miniPodium || !heroCards) {
                                                            console.warn('Kiosk: Overlay elements not found in current-view, falling back to original function', {
                                                                overlay: !!overlay,
                                                                miniPodium: !!miniPodium,
                                                                heroCards: !!heroCards
                                                            });
                                                            // Fallback to original function
                                                            if (typeof originalUpdateChampionsOverlay === 'function') {
                                                                return originalUpdateChampionsOverlay(allFinishAvatars);
                                                            }
                                                            return;
                                                        }
                                                        
                                                        // Ensure allFinishAvatars is an array
                                                        if (!allFinishAvatars || !Array.isArray(allFinishAvatars)) {
                                                            allFinishAvatars = [];
                                                        }
                                                        
                                                        // Filter allFinishAvatars to only include finishers from the active track
                                                        // This ensures we only show champions from the track defined in the playlist entry
                                                        const filteredFinishAvatars = allFinishAvatars.filter(function(avatar) {
                                                            const avatarTrackId = avatar.track_id ? parseInt(avatar.track_id) : null;
                                                            return avatarTrackId === activeTrackId;
                                                        });
                                                        
                                                        console.log('Kiosk: Filtered finish avatars by track', {
                                                            originalCount: allFinishAvatars.length,
                                                            filteredCount: filteredFinishAvatars.length,
                                                            activeTrackId: activeTrackId,
                                                            filteredAvatars: filteredFinishAvatars.map(a => ({name: a.name, track_id: a.track_id, goal_reached_at: a.goal_reached_at}))
                                                        });
                                                        
                                                        // Sort filtered finish avatars by goal_reached_at (earlier time = better rank)
                                                        // This ensures correct ranking based on when groups reached the finish
                                                        if (filteredFinishAvatars.length > 0) {
                                                            filteredFinishAvatars.sort(function(a, b) {
                                                                var timeA = null;
                                                                var timeB = null;
                                                                
                                                                if (a.goal_reached_at) {
                                                                    timeA = new Date(a.goal_reached_at).getTime();
                                                                } else {
                                                                    timeA = Infinity;
                                                                }
                                                                
                                                                if (b.goal_reached_at) {
                                                                    timeB = new Date(b.goal_reached_at).getTime();
                                                                } else {
                                                                    timeB = Infinity;
                                                                }
                                                                
                                                                // Groups with goal_reached_at come before those without
                                                                if (a.goal_reached_at && b.goal_reached_at) {
                                                                    return timeA - timeB;
                                                                } else if (a.goal_reached_at && !b.goal_reached_at) {
                                                                    return -1;
                                                                } else if (!a.goal_reached_at && b.goal_reached_at) {
                                                                    return 1;
                                                                } else {
                                                                    return timeA - timeB;
                                                                }
                                                            });
                                                            
                                                            // Assign ranks
                                                            filteredFinishAvatars.forEach(function(avatar, index) {
                                                                avatar.finishRank = index + 1;
                                                            });
                                                        }
                                                        
                                                        // Get top 3 finishers (already sorted and filtered)
                                                        const top3 = filteredFinishAvatars.slice(0, 3);
                                                        
                                                        console.log('Kiosk: updateChampionsOverlay called', {
                                                            allFinishAvatarsCount: allFinishAvatars.length,
                                                            filteredCount: filteredFinishAvatars.length,
                                                            top3Count: top3.length,
                                                            activeTrackId: activeTrackId,
                                                            overlayFound: !!overlay,
                                                            miniPodiumFound: !!miniPodium,
                                                            heroCardsFound: !!heroCards,
                                                            top3: top3.map(a => ({name: a.name, track_id: a.track_id, goal_reached_at: a.goal_reached_at, rank: a.finishRank}))
                                                        });
                                                        
                                                        // In kiosk mode, show overlay only if there are finishers from the active track
                                                        const shouldShow = top3.length > 0;
                                                        
                                                        if (shouldShow) {
                                                            overlay.classList.remove('hidden');
                                                            overlay.style.display = 'block';
                                                            
                                                            // Hide mini podium, show hero cards (detailed view) in kiosk mode
                                                            miniPodium.style.display = 'none';
                                                            heroCards.classList.add('expanded');
                                                            
                                                            // Clear existing content
                                                            miniPodium.innerHTML = '';
                                                            heroCards.innerHTML = '';
                                                            
                                                            // Helper function to format numbers in German format
                                                            function formatNumberDE(value, decimals) {
                                                                if (value === null || value === undefined || isNaN(value)) {
                                                                    return '0';
                                                                }
                                                                var num = parseFloat(value);
                                                                var fixed = num.toFixed(decimals || 2);
                                                                var parts = fixed.split('.');
                                                                parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, '.');
                                                                return parts.join(',');
                                                            }
                                                            
                                                            // Create hero cards (detailed view) for top 3 finishers
                                                            top3.forEach(function(avatar, index) {
                                                                const rank = avatar.finishRank || (index + 1);
                                                                const medal = rank === 1 ? 'ðŸ¥‡' : rank === 2 ? 'ðŸ¥ˆ' : 'ðŸ¥‰';
                                                                
                                                                // Hero Card
                                                                const heroCard = document.createElement('div');
                                                                heroCard.className = 'hero-card';
                                                                heroCard.setAttribute('data-rank', rank);
                                                                
                                                                const heroAvatar = document.createElement('img');
                                                                heroAvatar.className = 'hero-card-avatar';
                                                                heroAvatar.src = avatar.logo || '/static/map/images/default_group.png';
                                                                heroAvatar.onerror = function() { this.src = '/static/map/images/default_group.png'; };
                                                                heroAvatar.alt = avatar.name || avatar.display_name || 'Unknown';
                                                                
                                                                const heroContent = document.createElement('div');
                                                                heroContent.className = 'hero-card-content';
                                                                
                                                                const heroRank = document.createElement('div');
                                                                heroRank.className = 'hero-card-rank';
                                                                heroRank.textContent = medal + ' Platz ' + rank;
                                                                
                                                                const heroName = document.createElement('div');
                                                                heroName.className = 'hero-card-name';
                                                                heroName.textContent = avatar.display_name || avatar.name || 'Unknown';
                                                                
                                                                const heroDetails = document.createElement('div');
                                                                heroDetails.className = 'hero-card-details';
                                                                
                                                                // Travel time if available
                                                                if (avatar.travel_duration_seconds !== undefined && avatar.travel_duration_seconds !== null) {
                                                                    const travelTimeDiv = document.createElement('div');
                                                                    travelTimeDiv.className = 'hero-card-travel-time';
                                                                    const totalSeconds = avatar.travel_duration_seconds;
                                                                    const days = Math.floor(totalSeconds / 86400);
                                                                    const hours = Math.floor((totalSeconds % 86400) / 3600);
                                                                    const minutes = Math.floor((totalSeconds % 3600) / 60);
                                                                    const seconds = Math.floor(totalSeconds % 60);
                                                                    let timeText = '';
                                                                    if (days > 0) {
                                                                        timeText = days + 'd ' + hours + 'h ' + minutes + 'm ' + seconds + 's';
                                                                    } else if (hours > 0) {
                                                                        timeText = hours + 'h ' + minutes + 'm ' + seconds + 's';
                                                                    } else if (minutes > 0) {
                                                                        timeText = minutes + 'm ' + seconds + 's';
                                                                    } else {
                                                                        timeText = seconds + 's';
                                                                    }
                                                                    travelTimeDiv.innerHTML = 'â±ï¸ ' + timeText;
                                                                    heroDetails.appendChild(travelTimeDiv);
                                                                }
                                                                
                                                                // Top contributor leaf group if available
                                                                if (avatar.top_contributor_leaf_group) {
                                                                    const topContributorDiv = document.createElement('div');
                                                                    topContributorDiv.className = 'hero-card-top-contributor';
                                                                    const leafGroup = avatar.top_contributor_leaf_group;
                                                                    const displayName = leafGroup.display_name || leafGroup.name;
                                                                    const contributionKm = formatNumberDE(leafGroup.contribution_km || 0, 2);
                                                                    topContributorDiv.innerHTML = 'ðŸ† ' + displayName + ' (' + contributionKm + ' km)';
                                                                    heroDetails.appendChild(topContributorDiv);
                                                                }
                                                                
                                                                // MVP class if available
                                                                if (avatar.mvp_class) {
                                                                    const mvpDiv = document.createElement('div');
                                                                    mvpDiv.className = 'hero-card-mvp';
                                                                    mvpDiv.textContent = 'â­ ' + avatar.mvp_class;
                                                                    heroDetails.appendChild(mvpDiv);
                                                                }
                                                                
                                                                heroContent.appendChild(heroRank);
                                                                heroContent.appendChild(heroName);
                                                                heroContent.appendChild(heroDetails);
                                                                
                                                                heroCard.appendChild(heroAvatar);
                                                                heroCard.appendChild(heroContent);
                                                                heroCards.appendChild(heroCard);
                                                            });
                                                            
                                                            console.log('Kiosk: Champions overlay displayed with', top3.length, 'finishers (detailed view)');
                                                        } else {
                                                            overlay.classList.add('hidden');
                                                            overlay.style.display = 'none';
                                                            console.log('Kiosk: Champions overlay hidden - no finishers');
                                                        }
                                                    };
                                                }
                                                
                                                console.log('Kiosk: Checking available functions', {
                                                    map: typeof window.map,
                                                    refreshAvatars: typeof window.refreshAvatars,
                                                    updateMapIcons: typeof window.updateMapIcons,
                                                    polylineLookup: typeof window.polylineLookup,
                                                    avatarMarkers: typeof window.avatarMarkers,
                                                    calculatePosition: typeof window.calculatePosition,
                                                    updateChampionsOverlay: typeof window.updateChampionsOverlay
                                                });
                                                
                                                // Load avatars - inline function to have access to entry
                                                (function(entry) {
                                                    // Always try to load avatars from API to ensure they are displayed
                                                    const groupId = entry.group_filter_id || null;
                                                    let langPrefix = '';
                                                    const pathParts = window.location.pathname.split('/');
                                                    if (pathParts.length > 1 && pathParts[1].length === 2) {
                                                        langPrefix = '/' + pathParts[1];
                                                    }
                                                    let avatarUrl = langPrefix + '/map/api/group-avatars/';
                                                    if (groupId) {
                                                        avatarUrl += '?group_id=' + encodeURIComponent(groupId);
                                                    }
                                                    
                                                    console.log('Loading avatars from API:', avatarUrl);
                                                    fetch(avatarUrl)
                                                        .then(response => {
                                                            if (!response.ok) {
                                                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                                            }
                                                            return response.json();
                                                        })
                                                        .then(data => {
                                                            console.log('Avatar data received:', data);
                                                            
                                                            // Try to use refreshAvatars function
                                                            if (typeof window.refreshAvatars === 'function') {
                                                                console.log('Calling window.refreshAvatars() with', data.avatars ? data.avatars.length : 0, 'avatars');
                                                                window.refreshAvatars(data);
                                                                // Explicitly call updateChampionsOverlay after refreshAvatars
                                                                // refreshAvatars should call it, but ensure it's called in kiosk mode
                                                                setTimeout(() => {
                                                                    console.log('Kiosk: Checking for champions after refreshAvatars', {
                                                                        updateChampionsOverlay: typeof window.updateChampionsOverlay,
                                                                        allFinishAvatars: window.allFinishAvatars ? window.allFinishAvatars.length : 0,
                                                                        showBoxes: window.showBoxes
                                                                    });
                                                                    if (typeof window.updateChampionsOverlay === 'function' && window.allFinishAvatars) {
                                                                        console.log('Kiosk: Calling updateChampionsOverlay with', window.allFinishAvatars.length, 'finishers');
                                                                        window.updateChampionsOverlay(window.allFinishAvatars);
                                                                    } else {
                                                                        console.warn('Kiosk: updateChampionsOverlay not available or allFinishAvatars not set', {
                                                                            updateChampionsOverlay: typeof window.updateChampionsOverlay,
                                                                            allFinishAvatars: window.allFinishAvatars
                                                                        });
                                                                    }
                                                                }, 200);
                                                            } else if (typeof refreshAvatars === 'function') {
                                                                console.log('Calling refreshAvatars()');
                                                                refreshAvatars(data);
                                                                // Explicitly call updateChampionsOverlay after refreshAvatars
                                                                setTimeout(() => {
                                                                    if (typeof window.updateChampionsOverlay === 'function' && window.allFinishAvatars) {
                                                                        window.updateChampionsOverlay(window.allFinishAvatars);
                                                                    }
                                                                }, 100);
                                                            } else {
                                                                // If refreshAvatars is not available, manually create markers
                                                                console.warn('refreshAvatars function not available, creating markers manually');
                                                                
                                                                // Inline function to create avatars manually
                                                                if (!data || !data.avatars || !Array.isArray(data.avatars)) {
                                                                    console.error('Invalid avatar data:', data);
                                                                    return;
                                                                }
                                                                
                                                                const mapInstance = window.map;
                                                                if (!mapInstance) {
                                                                    console.error('Map instance not available');
                                                                    return;
                                                                }
                                                                
                                                                const polylineLookup = window.polylineLookup || {};
                                                                const avatarMarkers = window.avatarMarkers || {};
                                                                
                                                                // Ensure avatarMarkers is in window scope
                                                                if (!window.avatarMarkers) {
                                                                    window.avatarMarkers = avatarMarkers;
                                                                }
                                                                
                                                                console.log('Creating', data.avatars.length, 'avatars manually');
                                                                
                                                                // Group avatars by track_id
                                                                const avatarsByTrack = {};
                                                                
                                                                data.avatars.forEach(function(g) {
                                                                    if (!avatarsByTrack[g.track_id]) {
                                                                        avatarsByTrack[g.track_id] = [];
                                                                    }
                                                                    avatarsByTrack[g.track_id].push(g);
                                                                });
                                                                
                                                                data.avatars.forEach(function(g) {
                                                                    // Calculate position manually
                                                                    let pos = null;
                                                                    if (polylineLookup[g.track_id]) {
                                                                        const poly = polylineLookup[g.track_id];
                                                                        const latlngs = poly.getLatLngs();
                                                                        let total = 0;
                                                                        for (let i = 0; i < latlngs.length - 1; i++) {
                                                                            total += latlngs[i].distanceTo(latlngs[i+1]);
                                                                        }
                                                                        const ratio = Math.max(0, Math.min(1, (g.km * 1000) / total));
                                                                        pos = L.GeometryUtil.interpolateOnLine(mapInstance, poly, ratio).latLng;
                                                                    }
                                                                    
                                                                    if (!pos) {
                                                                        console.warn('No position calculated for group:', g.name, 'track_id:', g.track_id);
                                                                        return;
                                                                    }
                                                                    
                                                                    // Calculate offset based on km
                                                                    // At start (0 km): arrange avatars on a virtual line perpendicular to the track start
                                                                    // After start: arrange vertically (stacked) to avoid overlap
                                                                    let xOffset = 0;
                                                                    let yOffset = 0;
                                                                    if (g.km === 0 || (g.km !== undefined && Math.abs(g.km) < 0.01)) {
                                                                        // At start: arrange avatars on a virtual line perpendicular to the track start
                                                                        if (polylineLookup[g.track_id]) {
                                                                            const poly = polylineLookup[g.track_id];
                                                                            const latlngs = poly.getLatLngs();
                                                                            if (latlngs.length >= 2) {
                                                                                const startPoint = latlngs[0];
                                                                                const secondPoint = latlngs[1];
                                                                                
                                                                                // Get all avatars at start for this track
                                                                                const startAvatars = avatarsByTrack[g.track_id].filter(function(avatar) {
                                                                                    return avatar.km === 0 || (avatar.km !== undefined && Math.abs(avatar.km) < 0.01);
                                                                                });
                                                                                
                                                                                // Sort by offset_index to ensure consistent ordering
                                                                                startAvatars.sort(function(a, b) {
                                                                                    return (a.offset_index || 0) - (b.offset_index || 0);
                                                                                });
                                                                                
                                                                                // Find index of current avatar
                                                                                const avatarIndex = startAvatars.findIndex(function(avatar) {
                                                                                    return avatar.name === g.name;
                                                                                });
                                                                                
                                                                                if (avatarIndex >= 0) {
                                                                                    // Calculate direction vector from start to second point
                                                                                    const dx = secondPoint.lng - startPoint.lng;
                                                                                    const dy = secondPoint.lat - startPoint.lat;
                                                                                    const length = Math.sqrt(dx * dx + dy * dy);
                                                                                    
                                                                                    if (length > 0) {
                                                                                        // Normalize direction vector
                                                                                        const normDx = dx / length;
                                                                                        const normDy = dy / length;
                                                                                        
                                                                                        // Perpendicular vector (rotate 90 degrees counterclockwise)
                                                                                        const perpX = -normDy;
                                                                                        const perpY = normDx;
                                                                                        
                                                                                        // Offset distance from track (in degrees, approximately 0.001 = ~100m)
                                                                                        const offsetDistance = 0.001;
                                                                                        
                                                                                        // Spacing between avatars along the perpendicular line (in degrees)
                                                                                        const avatarSpacing = 0.0003; // Approximately 30m between avatars
                                                                                        
                                                                                        // Calculate position offset
                                                                                        const offsetIndex = avatarIndex - (startAvatars.length - 1) / 2;
                                                                                        const offsetLng = perpX * (offsetDistance + offsetIndex * avatarSpacing);
                                                                                        const offsetLat = perpY * (offsetDistance + offsetIndex * avatarSpacing);
                                                                                        
                                                                                        // Apply offset to start position
                                                                                        pos = L.latLng(
                                                                                            startPoint.lat + offsetLat,
                                                                                            startPoint.lng + offsetLng
                                                                                        );
                                                                                    }
                                                                                }
                                                                                
                                                                                xOffset = 0;
                                                                                yOffset = 0;
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // After start: vertical offset (stacked)
                                                                        xOffset = 0;
                                                                        yOffset = (g.offset_index || 0) * 20; // 20px vertical spacing
                                                                    }
                                                                    
                                                                    // Create icon
                                                                    const displayKm = g.km || 0;
                                                                    const groupName = ((g.display_name || g.name) || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                                                                    
                                                                    // Format number (simple version)
                                                                    const formatNumber = (value, decimals) => {
                                                                        const num = parseFloat(value);
                                                                        const fixed = num.toFixed(decimals || 2);
                                                                        const parts = fixed.split('.');
                                                                        const integerStr = parts[0];
                                                                        const decimalPart = parts[1] || '';
                                                                        let integerWithSeparators = '';
                                                                        for (let i = 0; i < integerStr.length; i++) {
                                                                            if (i > 0 && (integerStr.length - i) % 3 === 0) {
                                                                                integerWithSeparators += '.';
                                                                            }
                                                                            integerWithSeparators += integerStr[i];
                                                                        }
                                                                        return integerWithSeparators + (decimalPart ? ',' + decimalPart : '');
                                                                    };
                                                                    
                                                                    // Apply both horizontal and vertical offsets
                                                                    let transform = '';
                                                                    if (xOffset !== 0 || yOffset !== 0) {
                                                                        transform = `transform: translate(${xOffset}px, -${yOffset}px);`;
                                                                    }
                                                                    
                                                                    const icon = L.divIcon({
                                                                        html: `
                                                                            <div class="group-icon-container" style="${transform}">
                                                                                <img src="${g.logo}" class="group-icon-img" onerror="this.src='/static/map/images/default_group.png'">
                                                                                <div class="group-icon-label" style="color: #333; background: rgba(255,255,255,0.95); padding: 2px 6px; border-radius: 4px; font-size: 11px; font-weight: bold; border: 1px solid #ccc; white-space: normal; word-wrap: break-word; overflow-wrap: break-word; box-shadow: 0 1px 3px rgba(0,0,0,0.2); margin-top: 2px; display: inline-block; line-height: 1.2; text-align: center; max-width: 100px;">${groupName}<br>${formatNumber(displayKm, 2)} km</div>
                                                                            </div>`,
                                                                        className: '',
                                                                        iconSize: [50, 65],
                                                                        iconAnchor: [25, 50]
                                                                    });
                                                                    
                                                                    if (avatarMarkers[g.name]) {
                                                                        avatarMarkers[g.name].setLatLng(pos);
                                                                        avatarMarkers[g.name].setIcon(icon);
                                                                    } else {
                                                                        console.log('Creating new marker for group:', g.name, 'at position:', pos);
                                                                        avatarMarkers[g.name] = L.marker(pos, { icon: icon }).addTo(mapInstance);
                                                                    }
                                                                });
                                                                
                                                                // Update window references
                                                                window.avatarMarkers = avatarMarkers;
                                                                console.log('Avatars created manually, total markers:', Object.keys(avatarMarkers).length);
                                                            }
                                                            
                                                            // Also set up periodic updates if updateMapIcons is available
                                                            if (typeof window.updateMapIcons === 'function') {
                                                                console.log('Setting up periodic avatar updates');
                                                                // Clear any existing interval
                                                                if (window.kioskAvatarUpdateInterval) {
                                                                    clearInterval(window.kioskAvatarUpdateInterval);
                                                                }
                                                                // Set up periodic updates (every 5 seconds)
                                                                window.kioskAvatarUpdateInterval = setInterval(() => {
                                                                    if (typeof window.updateMapIcons === 'function') {
                                                                        window.updateMapIcons();
                                                                    }
                                                                }, 5000);
                                                            }
                                                            
                                                            // Load and display milestones
                                                            (function() {
                                                                const groupId = entry.group_filter_id || null;
                                                                let langPrefix = '';
                                                                const pathParts = window.location.pathname.split('/');
                                                                if (pathParts.length > 1 && pathParts[1].length === 2) {
                                                                    langPrefix = '/' + pathParts[1];
                                                                }
                                                                let milestonesUrl = langPrefix + '/map/api/all-milestones-status/';
                                                                if (groupId) {
                                                                    milestonesUrl += '?group_id=' + encodeURIComponent(groupId);
                                                                }
                                                                
                                                                console.log('Kiosk: Loading milestones from API:', milestonesUrl);
                                                                fetch(milestonesUrl)
                                                                    .then(response => {
                                                                        if (!response.ok) {
                                                                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                                                        }
                                                                        return response.json();
                                                                    })
                                                                    .then(data => {
                                                                        console.log('Kiosk: Milestone data received:', data);
                                                                        
                                                                        const mapInstance = window.map;
                                                                        if (!mapInstance) {
                                                                            console.error('Kiosk: Map instance not available for milestones');
                                                                            return;
                                                                        }
                                                                        
                                                                        // Initialize milestone markers layer group if it doesn't exist
                                                                        if (!window.milestoneMarkers) {
                                                                            window.milestoneMarkers = L.layerGroup().addTo(mapInstance);
                                                                        }
                                                                        if (!window.milestoneMarkerMap) {
                                                                            window.milestoneMarkerMap = {};
                                                                        }
                                                                        
                                                                        // Format number function (German format)
                                                                        const formatNumberDE = (value, decimals) => {
                                                                            const num = parseFloat(value);
                                                                            const fixed = num.toFixed(decimals || 2);
                                                                            const parts = fixed.split('.');
                                                                            const integerStr = parts[0];
                                                                            const decimalPart = parts[1] || '';
                                                                            let integerWithSeparators = '';
                                                                            for (let i = 0; i < integerStr.length; i++) {
                                                                                if (i > 0 && (integerStr.length - i) % 3 === 0) {
                                                                                    integerWithSeparators += '.';
                                                                                }
                                                                                integerWithSeparators += integerStr[i];
                                                                            }
                                                                            return integerWithSeparators + (decimalPart ? ',' + decimalPart : '');
                                                                        };
                                                                        
                                                                        // Create or update milestone markers
                                                                        if (data.milestones && Array.isArray(data.milestones)) {
                                                                            data.milestones.forEach(function(m) {
                                                                                if (m.lat && m.lon) {
                                                                                    const isReached = m.is_reached || false;
                                                                                    const bgColor = isReached ? '#28a745' : '#ffd700';
                                                                                    const borderColor = isReached ? '#1e7e34' : '#ff8c00';
                                                                                    const iconEmoji = isReached ? 'âœ…' : 'ðŸ†';
                                                                                    
                                                                                    const milestoneIcon = L.divIcon({
                                                                                        className: 'milestone-marker',
                                                                                        html: '<div style="background: ' + bgColor + '; border: 3px solid ' + borderColor + '; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 18px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">' + iconEmoji + '</div>',
                                                                                        iconSize: [30, 30],
                                                                                        iconAnchor: [15, 15]
                                                                                    });
                                                                                    
                                                                                    // Create popup content
                                                                                    let popupContent = '<div style="text-align: center; font-weight: bold; font-size: 18px; margin-bottom: 10px;">ðŸ† Meilenstein erreicht!</div>';
                                                                                    popupContent += '<div style="text-align: center; font-size: 16px; font-weight: bold; margin-bottom: 8px;">' + (m.name || 'Meilenstein') + '</div>';
                                                                                    popupContent += '<div style="text-align: center; font-size: 14px; margin-bottom: 8px;">' + formatNumberDE(m.km || 0, 2) + ' km</div>';
                                                                                    if (m.reward_text && m.reward_text.trim()) {
                                                                                        popupContent += '<div style="text-align: center; font-size: 14px; margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;"><strong>Belohnung:</strong><br>' + m.reward_text + '</div>';
                                                                                    }
                                                                                    if (isReached && m.winner_group_name) {
                                                                                        popupContent += '<div style="text-align: center; font-size: 12px; margin-top: 8px; color: #666;">Erreicht von: ' + m.winner_group_name + '</div>';
                                                                                    }
                                                                                    
                                                                                    // Check if marker already exists
                                                                                    if (m.id && window.milestoneMarkerMap[m.id]) {
                                                                                        // Update existing marker
                                                                                        window.milestoneMarkerMap[m.id].setLatLng([m.lat, m.lon]);
                                                                                        window.milestoneMarkerMap[m.id].setIcon(milestoneIcon);
                                                                                        window.milestoneMarkerMap[m.id].setPopupContent(popupContent);
                                                                                    } else {
                                                                                        // Create new marker
                                                                                        const marker = L.marker([m.lat, m.lon], {icon: milestoneIcon}).addTo(window.milestoneMarkers);
                                                                                        marker.bindPopup(popupContent);
                                                                                        if (m.id) {
                                                                                            window.milestoneMarkerMap[m.id] = marker;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            });
                                                                            console.log('Kiosk: Milestones created/updated, total markers:', Object.keys(window.milestoneMarkerMap).length);
                                                                            
                                                                            // Initialize kioskShownMilestoneIds - load from sessionStorage if available
                                                                            // kioskShownMilestoneIds persists across view switches within the same session
                                                                            // This ensures that milestones already shown in this session are not shown again after view refresh
                                                                            // last_check is used to prevent old milestones from being shown again after page refresh (new session)
                                                                            if (!window.kioskShownMilestoneIds || window.kioskShownMilestoneIds.size === 0) {
                                                                                // Try to load from sessionStorage (session-scoped, not localStorage)
                                                                                var storedShownIds = sessionStorage.getItem('kioskShownMilestoneIds');
                                                                                if (storedShownIds) {
                                                                                    try {
                                                                                        var parsedIds = JSON.parse(storedShownIds);
                                                                                        window.kioskShownMilestoneIds = new Set(parsedIds);
                                                                                        console.log('Kiosk: Loaded shownMilestoneIds from sessionStorage:', Array.from(window.kioskShownMilestoneIds));
                                                                                    } catch (e) {
                                                                                        console.warn('Kiosk: Error parsing stored shownMilestoneIds from sessionStorage:', e);
                                                                                        window.kioskShownMilestoneIds = new Set();
                                                                                    }
                                                                                } else {
                                                                                    window.kioskShownMilestoneIds = new Set();
                                                                                    console.log('Kiosk: Initialized shownMilestoneIds as empty set (no sessionStorage data)');
                                                                                }
                                                                            }
                                                                        }
                                                                    })
                                                                    .catch(error => {
                                                                        console.error('Kiosk: Error loading milestones:', error);
                                                                    });
                                                                    
                                                                // Set up periodic milestone updates (every 10 seconds)
                                                                if (window.kioskMilestoneUpdateInterval) {
                                                                    clearInterval(window.kioskMilestoneUpdateInterval);
                                                                }
                                                                window.kioskMilestoneUpdateInterval = setInterval(() => {
                                                                    const groupId = entry.group_filter_id || null;
                                                                    let langPrefix = '';
                                                                    const pathParts = window.location.pathname.split('/');
                                                                    if (pathParts.length > 1 && pathParts[1].length === 2) {
                                                                        langPrefix = '/' + pathParts[1];
                                                                    }
                                                                    let milestonesUrl = langPrefix + '/map/api/all-milestones-status/';
                                                                    if (groupId) {
                                                                        milestonesUrl += '?group_id=' + encodeURIComponent(groupId);
                                                                    }
                                                                    
                                                                    fetch(milestonesUrl)
                                                                        .then(response => response.json())
                                                                        .then(data => {
                                                                            if (data.milestones && Array.isArray(data.milestones) && window.map && window.milestoneMarkers) {
                                                                                // Update milestone markers - only if color needs to change
                                                                                data.milestones.forEach(function(m) {
                                                                                    if (m.lat && m.lon && m.id && window.milestoneMarkerMap[m.id]) {
                                                                                        const currentIcon = window.milestoneMarkerMap[m.id].options.icon;
                                                                                        const isReached = m.is_reached || false;
                                                                                        const expectedBgColor = isReached ? '#28a745' : '#ffd700';
                                                                                        
                                                                                        // Only update if the color needs to change
                                                                                        const needsUpdate = !currentIcon || 
                                                                                            (currentIcon.options && currentIcon.options.html && 
                                                                                             !currentIcon.options.html.includes(expectedBgColor));
                                                                                        
                                                                                        if (needsUpdate) {
                                                                                            const bgColor = isReached ? '#28a745' : '#ffd700';
                                                                                            const borderColor = isReached ? '#1e7e34' : '#ff8c00';
                                                                                            const iconEmoji = isReached ? 'âœ…' : 'ðŸ†';
                                                                                            
                                                                                            const milestoneIcon = L.divIcon({
                                                                                                className: 'milestone-marker',
                                                                                                html: '<div style="background: ' + bgColor + '; border: 3px solid ' + borderColor + '; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 18px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">' + iconEmoji + '</div>',
                                                                                                iconSize: [30, 30],
                                                                                                iconAnchor: [15, 15]
                                                                                            });
                                                                                            
                                                                                            window.milestoneMarkerMap[m.id].setIcon(milestoneIcon);
                                                                                        }
                                                                                    }
                                                                                });
                                                                            }
                                                                        })
                                                                        .catch(error => {
                                                                            console.error('Kiosk: Error updating milestones:', error);
                                                                        });
                                                                }, 10000);
                                                                
                                                                // Set up periodic check for new milestones (every 5 seconds)
                                                                // This will show the milestone overlay when a new milestone is reached
                                                                if (window.kioskNewMilestoneCheckInterval) {
                                                                    clearInterval(window.kioskNewMilestoneCheckInterval);
                                                                }
                                                                
                                                                // Initialize kioskShownMilestoneIds - load from sessionStorage if available
                                                                // kioskShownMilestoneIds persists across view switches within the same session
                                                                // This ensures that milestones already shown in this session are not shown again after view refresh
                                                                if (!window.kioskShownMilestoneIds || window.kioskShownMilestoneIds.size === 0) {
                                                                    // Try to load from sessionStorage (session-scoped, not localStorage)
                                                                    var storedShownIds = sessionStorage.getItem('kioskShownMilestoneIds');
                                                                    if (storedShownIds) {
                                                                        try {
                                                                            var parsedIds = JSON.parse(storedShownIds);
                                                                            window.kioskShownMilestoneIds = new Set(parsedIds);
                                                                            console.log('Kiosk: Loaded shownMilestoneIds from sessionStorage for new view:', Array.from(window.kioskShownMilestoneIds));
                                                                        } catch (e) {
                                                                            console.warn('Kiosk: Error parsing stored shownMilestoneIds from sessionStorage:', e);
                                                                            window.kioskShownMilestoneIds = new Set();
                                                                        }
                                                                    } else {
                                                                        window.kioskShownMilestoneIds = new Set();
                                                                        console.log('Kiosk: Initialized shownMilestoneIds as empty set for new view (no sessionStorage data)');
                                                                    }
                                                                } else {
                                                                    console.log('Kiosk: Keeping existing shownMilestoneIds for new view:', Array.from(window.kioskShownMilestoneIds));
                                                                }
                                                                
                                                                // Initialize last_check timestamp
                                                                // Strategy: Use reached_at of displayed milestones, not current time
                                                                // This ensures we only show milestones that were reached AFTER the last displayed milestone
                                                                if (!window.kioskLastMilestoneCheck) {
                                                                    var storedLastCheck = localStorage.getItem('kioskLastMilestoneCheck');
                                                                    if (storedLastCheck) {
                                                                        // Load from localStorage if available
                                                                        window.kioskLastMilestoneCheck = storedLastCheck;
                                                                        console.log('Kiosk: Loaded last_check from localStorage:', window.kioskLastMilestoneCheck);
                                                                    } else {
                                                                        // On first load, set last_check to current time (not 30 seconds ago)
                                                                        // This ensures we only show milestones reached AFTER page load
                                                                        // Milestones reached before page load will not be shown (by design)
                                                                        window.kioskLastMilestoneCheck = new Date().toISOString();
                                                                        localStorage.setItem('kioskLastMilestoneCheck', window.kioskLastMilestoneCheck);
                                                                        console.log('Kiosk: Initialized last_check to current time:', window.kioskLastMilestoneCheck);
                                                                    }
                                                                }
                                                                
                                                                // Store group_filter_id for later use
                                                                const storedGroupId = entry.group_filter_id || null;
                                                                
                                                                function checkNewMilestonesForKiosk() {
                                                                    const groupId = storedGroupId;
                                                                    let langPrefix = '';
                                                                    const pathParts = window.location.pathname.split('/');
                                                                    if (pathParts.length > 1 && pathParts[1].length === 2) {
                                                                        langPrefix = '/' + pathParts[1];
                                                                    }
                                                                    let url = langPrefix + '/map/api/new-milestones/';
                                                                    const params = [];
                                                                    
                                                                    if (groupId) {
                                                                        params.push('group_id=' + encodeURIComponent(groupId));
                                                                    }
                                                                    
                                                                    // Always send last_check to only get new milestones
                                                                    // last_check should be the reached_at of the last displayed milestone
                                                                    if (window.kioskLastMilestoneCheck) {
                                                                        params.push('last_check=' + encodeURIComponent(window.kioskLastMilestoneCheck));
                                                                    } else {
                                                                        // Fallback: if last_check is not set, use current time
                                                                        // This should not happen if initialization is correct
                                                                        var now = new Date();
                                                                        var lastCheckTime = now.toISOString();
                                                                        params.push('last_check=' + encodeURIComponent(lastCheckTime));
                                                                        window.kioskLastMilestoneCheck = lastCheckTime;
                                                                        localStorage.setItem('kioskLastMilestoneCheck', lastCheckTime);
                                                                        console.warn('Kiosk: last_check was not initialized, using current time as fallback');
                                                                    }
                                                                    
                                                                    if (params.length > 0) {
                                                                        url += '?' + params.join('&');
                                                                    }
                                                                    
                                                                    console.log('Kiosk: Checking for new milestones, URL:', url);
                                                                    fetch(url)
                                                                        .then(response => {
                                                                            if (!response.ok) {
                                                                                throw new Error('HTTP error! status: ' + response.status);
                                                                            }
                                                                            return response.json();
                                                                        })
                                                                        .then(data => {
                                                                            console.log('Kiosk: New milestones check response:', {
                                                                                milestoneCount: data.milestones ? data.milestones.length : 0,
                                                                                milestones: data.milestones,
                                                                                shownMilestoneIds: Array.from(window.kioskShownMilestoneIds || [])
                                                                            });
                                                                            if (data.milestones && data.milestones.length > 0) {
                                                                                // Find the milestone overlay in the current view container
                                                                                const currentView = document.getElementById('current-view');
                                                                                if (!currentView) {
                                                                                    console.warn('Kiosk: Current view container not found for milestone overlay');
                                                                                    return;
                                                                                }
                                                                                
                                                                                // First pass: Identify new milestones and mark them as shown IMMEDIATELY (outside setTimeout)
                                                                                // This prevents duplicate displays if the function is called multiple times quickly
                                                                                // IMPORTANT: After a trip restart, milestones may have new reached_at values
                                                                                // even if their IDs are already in kioskShownMilestoneIds
                                                                                // We need to check if reached_at is after last_check to detect trip restarts
                                                                                console.log('Kiosk: Processing milestones, shownIds:', Array.from(window.kioskShownMilestoneIds || []), 'last_check:', window.kioskLastMilestoneCheck);
                                                                                var newMilestoneIds = [];
                                                                                data.milestones.forEach(function(ms) {
                                                                                    var isAlreadyShown = window.kioskShownMilestoneIds.has(ms.id);
                                                                                    var isAfterLastCheck = false;
                                                                                    
                                                                                    // Check if this milestone was reached after last_check (indicates trip restart)
                                                                                    if (ms.reached_at && window.kioskLastMilestoneCheck) {
                                                                                        try {
                                                                                            var reachedAtTime = new Date(ms.reached_at).getTime();
                                                                                            var lastCheckTime = new Date(window.kioskLastMilestoneCheck).getTime();
                                                                                            isAfterLastCheck = reachedAtTime > lastCheckTime;
                                                                                        } catch (e) {
                                                                                            console.warn('Kiosk: Error comparing reached_at with last_check:', e);
                                                                                        }
                                                                                    }
                                                                                    
                                                                                    console.log('Kiosk: Checking milestone:', ms.id, ms.name, 'already shown:', isAlreadyShown, 'reached_at:', ms.reached_at, 'isAfterLastCheck:', isAfterLastCheck);
                                                                                    
                                                                                    // Show milestone if:
                                                                                    // 1. It's not already shown, OR
                                                                                    // 2. It was reached after last_check (trip restart scenario)
                                                                                    if (!isAlreadyShown || isAfterLastCheck) {
                                                                                        // Mark as shown IMMEDIATELY to prevent duplicate displays
                                                                                        window.kioskShownMilestoneIds.add(ms.id);
                                                                                        // Persist to sessionStorage so it survives view refreshes within the same session
                                                                                        sessionStorage.setItem('kioskShownMilestoneIds', JSON.stringify(Array.from(window.kioskShownMilestoneIds)));
                                                                                        newMilestoneIds.push(ms);
                                                                                        if (isAfterLastCheck) {
                                                                                            console.log('Kiosk: Milestone', ms.id, 'detected as new after trip restart (reached_at after last_check)');
                                                                                        }
                                                                                    }
                                                                                });
                                                                                
                                                                                // Update last_check to the reached_at of the newest milestone
                                                                                // This ensures we only show milestones reached AFTER this one
                                                                                // Strategy: Use reached_at instead of current time to prevent showing old milestones
                                                                                if (newMilestoneIds.length > 0) {
                                                                                    // Find the newest milestone (first one is already sorted by newest first)
                                                                                    var newestMilestone = newMilestoneIds[0];
                                                                                    if (newestMilestone.reached_at) {
                                                                                        // Use reached_at of the newest milestone as last_check
                                                                                        window.kioskLastMilestoneCheck = newestMilestone.reached_at;
                                                                                        localStorage.setItem('kioskLastMilestoneCheck', window.kioskLastMilestoneCheck);
                                                                                        console.log('Kiosk: Updated last_check to reached_at of newest milestone:', window.kioskLastMilestoneCheck, 'for milestone:', newestMilestone.name);
                                                                                    } else {
                                                                                        // Fallback: if reached_at is not available, use current time
                                                                                        window.kioskLastMilestoneCheck = new Date().toISOString();
                                                                                        localStorage.setItem('kioskLastMilestoneCheck', window.kioskLastMilestoneCheck);
                                                                                        console.warn('Kiosk: Milestone reached_at not available, using current time as fallback');
                                                                                    }
                                                                                }
                                                                                
                                                                                // Second pass: Display the new milestones (wait for DOM to be ready)
                                                                                if (newMilestoneIds.length > 0) {
                                                                                    setTimeout(() => {
                                                                                        const overlay = currentView.querySelector('#milestone-overlay');
                                                                                        const card = currentView.querySelector('#milestone-card');
                                                                                        const nameEl = currentView.querySelector('#milestone-overlay-name');
                                                                                        const trackNameEl = currentView.querySelector('#milestone-overlay-track-name');
                                                                                        const topGroupEl = currentView.querySelector('#milestone-overlay-top-group');
                                                                                        const leafGroupEl = currentView.querySelector('#milestone-overlay-leaf-group');
                                                                                        const rewardEl = currentView.querySelector('#milestone-overlay-reward');
                                                                                        
                                                                                        if (!overlay || !card) {
                                                                                            console.warn('Kiosk: Milestone overlay elements not found in current view', {
                                                                                                overlay: !!overlay,
                                                                                                card: !!card,
                                                                                                currentView: currentView.id,
                                                                                                currentViewHTML: currentView.innerHTML.substring(0, 200)
                                                                                            });
                                                                                            return;
                                                                                        }
                                                                                        
                                                                                        console.log('Kiosk: Milestone overlay elements found', {
                                                                                            overlay: !!overlay,
                                                                                            card: !!card,
                                                                                            nameEl: !!nameEl,
                                                                                            trackNameEl: !!trackNameEl,
                                                                                            topGroupEl: !!topGroupEl,
                                                                                            leafGroupEl: !!leafGroupEl,
                                                                                            rewardEl: !!rewardEl
                                                                                        });
                                                                                        
                                                                                        // Use the first/newest milestone for display
                                                                                        var ms = newMilestoneIds[0];
                                                                                        
                                                                                        console.log('Kiosk: Showing milestone overlay for:', ms.name, ms.id);
                                                                                        
                                                                                        // Set milestone data
                                                                                        // API returns: track_name, parent_group_name (TOP-Gruppe), group_name (Gruppe), reward_text
                                                                                        if (nameEl) nameEl.textContent = ms.name || '';
                                                                                        if (trackNameEl) trackNameEl.textContent = ms.track_name || '-';
                                                                                        if (topGroupEl) topGroupEl.textContent = ms.parent_group_name || '-';
                                                                                        if (leafGroupEl) leafGroupEl.textContent = ms.group_name || '-';
                                                                                        if (rewardEl) rewardEl.textContent = ms.reward_text || 'Herzlichen GlÃ¼ckwunsch!';
                                                                                        
                                                                                        console.log('Kiosk: Milestone data set', {
                                                                                            name: ms.name,
                                                                                            parent_group_name: ms.parent_group_name,
                                                                                            group_name: ms.group_name,
                                                                                            reward_text: ms.reward_text
                                                                                        });
                                                                                        
                                                                                        // Show overlay
                                                                                        overlay.classList.remove('hidden');
                                                                                        card.classList.remove('fade-out');
                                                                                        overlay.style.display = 'block';
                                                                                        
                                                                                        console.log('Kiosk: Milestone overlay displayed', {
                                                                                            name: ms.name,
                                                                                            overlayVisible: overlay.style.display,
                                                                                            hasHiddenClass: overlay.classList.contains('hidden'),
                                                                                            overlayComputedStyle: window.getComputedStyle(overlay).display
                                                                                        });
                                                                                        
                                                                                        // Auto-hide after 10 seconds
                                                                                        setTimeout(function() {
                                                                                            if (overlay) {
                                                                                                overlay.classList.add('hidden');
                                                                                                overlay.style.display = 'none';
                                                                                                console.log('Kiosk: Milestone overlay auto-hidden after 10 seconds');
                                                                                            }
                                                                                        }, 10000);
                                                                                        
                                                                                        // Update milestone marker color for all new milestones
                                                                                        // Only update if the marker exists and the color needs to change
                                                                                        newMilestoneIds.forEach(function(ms) {
                                                                                            if (window.milestoneMarkerMap && window.milestoneMarkerMap[ms.id]) {
                                                                                                // Check current icon to avoid unnecessary updates
                                                                                                const currentIcon = window.milestoneMarkerMap[ms.id].options.icon;
                                                                                                const isReached = ms.is_reached || false;
                                                                                                const expectedBgColor = isReached ? '#28a745' : '#ffd700';
                                                                                                
                                                                                                // Only update if the color needs to change
                                                                                                // Check if current icon HTML contains the expected color
                                                                                                const needsUpdate = !currentIcon || 
                                                                                                    (currentIcon.options && currentIcon.options.html && 
                                                                                                     !currentIcon.options.html.includes(expectedBgColor));
                                                                                                
                                                                                                if (needsUpdate) {
                                                                                                    const bgColor = isReached ? '#28a745' : '#ffd700';
                                                                                                    const borderColor = isReached ? '#1e7e34' : '#ff8c00';
                                                                                                    const iconEmoji = isReached ? 'âœ…' : 'ðŸ†';
                                                                                                    
                                                                                                    const milestoneIcon = L.divIcon({
                                                                                                        className: 'milestone-marker',
                                                                                                        html: '<div style="background: ' + bgColor + '; border: 3px solid ' + borderColor + '; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 18px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">' + iconEmoji + '</div>',
                                                                                                        iconSize: [30, 30],
                                                                                                        iconAnchor: [15, 15]
                                                                                                    });
                                                                                                    
                                                                                                    window.milestoneMarkerMap[ms.id].setIcon(milestoneIcon);
                                                                                                    console.log('Kiosk: Updated milestone marker icon for', ms.id, 'is_reached:', isReached);
                                                                                                } else {
                                                                                                    console.log('Kiosk: Milestone marker', ms.id, 'already has correct color, skipping update');
                                                                                                }
                                                                                            }
                                                                                        });
                                                                                    }, 100); // Small delay to ensure DOM is ready
                                                                                }
                                                                            } else {
                                                                                // No new milestones found - check if API returned milestones that were already shown
                                                                                // If so, update last_check to the newest reached_at to prevent them from being returned again
                                                                                if (data.milestones && data.milestones.length > 0) {
                                                                                    // Find the newest milestone that was already shown
                                                                                    var newestShownMilestone = null;
                                                                                    data.milestones.forEach(function(ms) {
                                                                                        if (window.kioskShownMilestoneIds.has(ms.id) && ms.reached_at) {
                                                                                            if (!newestShownMilestone || ms.reached_at > newestShownMilestone.reached_at) {
                                                                                                newestShownMilestone = ms;
                                                                                            }
                                                                                        }
                                                                                    });
                                                                                    
                                                                                    // Update last_check to the newest already-shown milestone's reached_at
                                                                                    // This prevents the API from returning these milestones again (even with the 10-second buffer)
                                                                                    if (newestShownMilestone && newestShownMilestone.reached_at) {
                                                                                        window.kioskLastMilestoneCheck = newestShownMilestone.reached_at;
                                                                                        localStorage.setItem('kioskLastMilestoneCheck', window.kioskLastMilestoneCheck);
                                                                                        console.log('Kiosk: Updated last_check to newest already-shown milestone reached_at:', window.kioskLastMilestoneCheck, 'to prevent re-returning');
                                                                                    } else {
                                                                                        console.log('Kiosk: No new milestones found, keeping last_check unchanged:', window.kioskLastMilestoneCheck);
                                                                                    }
                                                                                } else {
                                                                                    console.log('Kiosk: No milestones returned from API, keeping last_check unchanged:', window.kioskLastMilestoneCheck);
                                                                                }
                                                                            }
                                                                        })
                                                                        .catch(error => {
                                                                            console.error('Kiosk: Error checking for new milestones:', error);
                                                                        });
                                                                }
                                                                
                                                                // Make function globally available for interval calls
                                                                window.checkNewMilestonesForKiosk = checkNewMilestonesForKiosk;
                                                                
                                                                // Start checking for new milestones every 5 seconds
                                                                window.kioskNewMilestoneCheckInterval = setInterval(function() {
                                                                    if (typeof window.checkNewMilestonesForKiosk === 'function') {
                                                                        window.checkNewMilestonesForKiosk();
                                                                    } else {
                                                                        console.warn('Kiosk: checkNewMilestonesForKiosk function not available');
                                                                    }
                                                                }, 5000);
                                                                
                                                                // Also check immediately after a short delay
                                                                setTimeout(function() {
                                                                    if (typeof window.checkNewMilestonesForKiosk === 'function') {
                                                                        window.checkNewMilestonesForKiosk();
                                                                    }
                                                                }, 2000);
                                                            })();
                                                        })
                                                        .catch(error => {
                                                            console.error('Error loading avatars:', error);
                                                            // Try to use updateMapIcons as fallback
                                                            if (typeof window.updateMapIcons === 'function') {
                                                                console.log('Trying updateMapIcons as fallback');
                                                                window.updateMapIcons();
                                                            }
                                                        });
                                                })(entry);
                                            }, 1500);
                                        } else {
                                            // Map not initialized yet - wait for script to initialize it
                                            // Check again after scripts have executed
                                            setTimeout(() => {
                                                if (mapElement._leaflet_id) {
                                                    // Map was initialized by script, get existing instance
                                                    let existingMap = mapElement._leaflet || window.map;
                                                    if (existingMap) {
                                                        existingMap.invalidateSize();
                                                        console.log('Map initialized by script, size invalidated');
                                                    }
                                                    
                                                    // Trigger avatar refresh
                                                    setTimeout(() => {
                                                        // First, try to ensure functions are in global scope
                                                        if (typeof map !== 'undefined' && !window.map) {
                                                            window.map = map;
                                                        }
                                                        if (typeof refreshAvatars !== 'undefined' && !window.refreshAvatars) {
                                                            window.refreshAvatars = refreshAvatars;
                                                        }
                                                        if (typeof updateMapIcons !== 'undefined' && !window.updateMapIcons) {
                                                            window.updateMapIcons = updateMapIcons;
                                                        }
                                                        if (typeof polylineLookup !== 'undefined' && !window.polylineLookup) {
                                                            window.polylineLookup = polylineLookup;
                                                        }
                                                        if (typeof avatarMarkers !== 'undefined' && !window.avatarMarkers) {
                                                            window.avatarMarkers = avatarMarkers;
                                                        }
                                                        if (typeof calculatePosition !== 'undefined' && !window.calculatePosition) {
                                                            window.calculatePosition = calculatePosition;
                                                        }
                                                        
                                                        // Always try to load avatars from API
                                                        const groupId = entry.group_filter_id || null;
                                                        let langPrefix = '';
                                                        const pathParts = window.location.pathname.split('/');
                                                        if (pathParts.length > 1 && pathParts[1].length === 2) {
                                                            langPrefix = '/' + pathParts[1];
                                                        }
                                                        let avatarUrl = langPrefix + '/map/api/group-avatars/';
                                                        if (groupId) {
                                                            avatarUrl += '?group_id=' + encodeURIComponent(groupId);
                                                        }
                                                        
                                                        console.log('Loading avatars from API (delayed):', avatarUrl);
                                                        fetch(avatarUrl)
                                                            .then(response => {
                                                                if (!response.ok) {
                                                                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                                                }
                                                                return response.json();
                                                            })
                                                            .then(data => {
                                                                console.log('Avatar data received (delayed):', data);
                                                                if (typeof window.refreshAvatars === 'function') {
                                                                    window.refreshAvatars(data);
                                                                    // Explicitly call updateChampionsOverlay after refreshAvatars
                                                                    setTimeout(() => {
                                                                        if (typeof window.updateChampionsOverlay === 'function' && window.allFinishAvatars) {
                                                                            window.updateChampionsOverlay(window.allFinishAvatars);
                                                                        }
                                                                    }, 100);
                                                                } else if (typeof refreshAvatars === 'function') {
                                                                    refreshAvatars(data);
                                                                    // Explicitly call updateChampionsOverlay after refreshAvatars
                                                                    setTimeout(() => {
                                                                        if (typeof window.updateChampionsOverlay === 'function' && window.allFinishAvatars) {
                                                                            window.updateChampionsOverlay(window.allFinishAvatars);
                                                                        }
                                                                    }, 100);
                                                                }
                                                            })
                                                            .catch(error => {
                                                                console.error('Error loading avatars (delayed):', error);
                                                                // Try updateMapIcons as fallback
                                                                if (typeof window.updateMapIcons === 'function') {
                                                                    window.updateMapIcons();
                                                                }
                                                            });
                                                        
                                                        // Also load milestones (delayed initialization)
                                                        (function() {
                                                            const groupId = entry.group_filter_id || null;
                                                            let langPrefix = '';
                                                            const pathParts = window.location.pathname.split('/');
                                                            if (pathParts.length > 1 && pathParts[1].length === 2) {
                                                                langPrefix = '/' + pathParts[1];
                                                            }
                                                            let milestonesUrl = langPrefix + '/map/api/all-milestones-status/';
                                                            if (groupId) {
                                                                milestonesUrl += '?group_id=' + encodeURIComponent(groupId);
                                                            }
                                                            
                                                            console.log('Kiosk: Loading milestones from API (delayed):', milestonesUrl);
                                                            fetch(milestonesUrl)
                                                                .then(response => {
                                                                    if (!response.ok) {
                                                                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                                                    }
                                                                    return response.json();
                                                                })
                                                                .then(data => {
                                                                    console.log('Kiosk: Milestone data received (delayed):', data);
                                                                    
                                                                    const mapInstance = window.map;
                                                                    if (!mapInstance) {
                                                                        console.error('Kiosk: Map instance not available for milestones (delayed)');
                                                                        return;
                                                                    }
                                                                    
                                                                    // Always create a new milestone layer group for the current map instance
                                                                    // Remove old layer group if it exists and is not on the current map
                                                                    if (window.milestoneMarkers) {
                                                                        try {
                                                                            // Check if the layer group is still on the map
                                                                            if (window.milestoneMarkers._map && window.milestoneMarkers._map !== mapInstance) {
                                                                                // Old layer group is on a different map, remove it
                                                                                window.milestoneMarkers.remove();
                                                                            } else if (!window.milestoneMarkers._map) {
                                                                                // Layer group is not on any map, clear it
                                                                                window.milestoneMarkers.clearLayers();
                                                                            }
                                                                        } catch (e) {
                                                                            console.warn('Kiosk: Error checking milestone markers layer (delayed):', e);
                                                                        }
                                                                    }
                                                                    
                                                                    // Create new milestone layer group for current map
                                                                    window.milestoneMarkers = L.layerGroup().addTo(mapInstance);
                                                                    if (!window.milestoneMarkerMap) {
                                                                        window.milestoneMarkerMap = {};
                                                                    } else {
                                                                        // Clear the map to start fresh
                                                                        window.milestoneMarkerMap = {};
                                                                    }
                                                                    
                                                                    // Format number function (German format)
                                                                    const formatNumberDE = (value, decimals) => {
                                                                        const num = parseFloat(value);
                                                                        const fixed = num.toFixed(decimals || 2);
                                                                        const parts = fixed.split('.');
                                                                        const integerStr = parts[0];
                                                                        const decimalPart = parts[1] || '';
                                                                        let integerWithSeparators = '';
                                                                        for (let i = 0; i < integerStr.length; i++) {
                                                                            if (i > 0 && (integerStr.length - i) % 3 === 0) {
                                                                                integerWithSeparators += '.';
                                                                            }
                                                                            integerWithSeparators += integerStr[i];
                                                                        }
                                                                        return integerWithSeparators + (decimalPart ? ',' + decimalPart : '');
                                                                    };
                                                                    
                                                                    // Create or update milestone markers
                                                                    if (data.milestones && Array.isArray(data.milestones)) {
                                                                        data.milestones.forEach(function(m) {
                                                                            if (m.lat && m.lon) {
                                                                                const isReached = m.is_reached || false;
                                                                                const bgColor = isReached ? '#28a745' : '#ffd700';
                                                                                const borderColor = isReached ? '#1e7e34' : '#ff8c00';
                                                                                const iconEmoji = isReached ? 'âœ…' : 'ðŸ†';
                                                                                
                                                                                const milestoneIcon = L.divIcon({
                                                                                    className: 'milestone-marker',
                                                                                    html: '<div style="background: ' + bgColor + '; border: 3px solid ' + borderColor + '; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 18px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">' + iconEmoji + '</div>',
                                                                                    iconSize: [30, 30],
                                                                                    iconAnchor: [15, 15]
                                                                                });
                                                                                
                                                                                // Create popup content
                                                                                let popupContent = '<div style="text-align: center; font-weight: bold; font-size: 18px; margin-bottom: 10px;">ðŸ† Meilenstein erreicht!</div>';
                                                                                popupContent += '<div style="text-align: center; font-size: 16px; font-weight: bold; margin-bottom: 8px;">' + (m.name || 'Meilenstein') + '</div>';
                                                                                popupContent += '<div style="text-align: center; font-size: 14px; margin-bottom: 8px;">' + formatNumberDE(m.km || 0, 1) + ' km</div>';
                                                                                if (m.reward_text && m.reward_text.trim()) {
                                                                                    popupContent += '<div style="text-align: center; font-size: 14px; margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;"><strong>Belohnung:</strong><br>' + m.reward_text + '</div>';
                                                                                }
                                                                                if (isReached && m.winner_group_name) {
                                                                                    popupContent += '<div style="text-align: center; font-size: 12px; margin-top: 8px; color: #666;">Erreicht von: ' + m.winner_group_name + '</div>';
                                                                                }
                                                                                
                                                                                // Check if marker already exists
                                                                                if (m.id && window.milestoneMarkerMap[m.id]) {
                                                                                    // Update existing marker
                                                                                    window.milestoneMarkerMap[m.id].setLatLng([m.lat, m.lon]);
                                                                                    window.milestoneMarkerMap[m.id].setIcon(milestoneIcon);
                                                                                    window.milestoneMarkerMap[m.id].setPopupContent(popupContent);
                                                                                } else {
                                                                                    // Create new marker
                                                                                    const marker = L.marker([m.lat, m.lon], {icon: milestoneIcon}).addTo(window.milestoneMarkers);
                                                                                    marker.bindPopup(popupContent);
                                                                                    if (m.id) {
                                                                                        window.milestoneMarkerMap[m.id] = marker;
                                                                                    }
                                                                                }
                                                                            }
                                                                        });
                                                                        console.log('Kiosk: Milestones created/updated (delayed), total markers:', Object.keys(window.milestoneMarkerMap).length);
                                                                    }
                                                                })
                                                                .catch(error => {
                                                                    console.error('Kiosk: Error loading milestones (delayed):', error);
                                                                });
                                                                
                                                            // Set up periodic milestone updates (every 10 seconds)
                                                            if (window.kioskMilestoneUpdateInterval) {
                                                                clearInterval(window.kioskMilestoneUpdateInterval);
                                                            }
                                                            window.kioskMilestoneUpdateInterval = setInterval(() => {
                                                                const groupId = entry.group_filter_id || null;
                                                                let langPrefix = '';
                                                                const pathParts = window.location.pathname.split('/');
                                                                if (pathParts.length > 1 && pathParts[1].length === 2) {
                                                                    langPrefix = '/' + pathParts[1];
                                                                }
                                                                let milestonesUrl = langPrefix + '/map/api/all-milestones-status/';
                                                                if (groupId) {
                                                                    milestonesUrl += '?group_id=' + encodeURIComponent(groupId);
                                                                }
                                                                
                                                                fetch(milestonesUrl)
                                                                    .then(response => response.json())
                                                                    .then(data => {
                                                                        if (data.milestones && Array.isArray(data.milestones) && window.map && window.milestoneMarkers) {
                                                                            // Update milestone markers
                                                                            data.milestones.forEach(function(m) {
                                                                                if (m.lat && m.lon && m.id && window.milestoneMarkerMap[m.id]) {
                                                                                    const isReached = m.is_reached || false;
                                                                                    const bgColor = isReached ? '#28a745' : '#ffd700';
                                                                                    const borderColor = isReached ? '#1e7e34' : '#ff8c00';
                                                                                    const iconEmoji = isReached ? 'âœ…' : 'ðŸ†';
                                                                                    
                                                                                    const milestoneIcon = L.divIcon({
                                                                                        className: 'milestone-marker',
                                                                                        html: '<div style="background: ' + bgColor + '; border: 3px solid ' + borderColor + '; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 18px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">' + iconEmoji + '</div>',
                                                                                        iconSize: [30, 30],
                                                                                        iconAnchor: [15, 15]
                                                                                    });
                                                                                    
                                                                                    window.milestoneMarkerMap[m.id].setIcon(milestoneIcon);
                                                                                }
                                                                            });
                                                                        }
                                                                    })
                                                                    .catch(error => {
                                                                        console.error('Kiosk: Error updating milestones:', error);
                                                                    });
                                                            }, 10000);
                                                        })();
                                                    }, 1500);
                                                } else {
                                                    console.warn('Map was not initialized by loaded script');
                                                }
                                            }, 1000);
                                        }
                                    } catch (e) {
                                        console.error('Error handling map:', e);
                                    }
                                } else if (!mapElement) {
                                    console.warn('Map element not found in loaded content');
                                } else if (typeof L === 'undefined') {
                                    console.warn('Leaflet library not loaded yet');
                                }
                            }, 500);
                        }
                        
                        console.log('View loaded successfully:', entry.view_type);
                    })
                    .catch(error => {
                        console.error('Failed to load view:', error);
                        currentView.innerHTML = `
                            <div class="flex items-center justify-center h-full bg-slate-900 text-white">
                                <div class="text-center">
                                    <h1 class="text-2xl font-bold mb-4 text-red-500">Error loading view</h1>
                                    <p class="text-lg">Failed to load ${entry.view_type} view.</p>
                                    <p class="text-sm mt-4 text-gray-400">Error: ${error.message}</p>
                                    <p class="text-sm text-gray-400">URL: ${url}</p>
                                </div>
                            </div>
                        `;
                    });
            }
            
            /**
             * Start playlist rotation
             */
            function startRotation() {
                if (currentPlaylist.length === 0) {
                    console.warn('No playlist entries available');
                    return;
                }
                
                // Clear existing timer
                if (rotationTimer) {
                    clearTimeout(rotationTimer);
                }
                
                // Get current entry
                const entry = currentPlaylist[currentEntryIndex];
                if (!entry) {
                    console.error('Invalid playlist entry index:', currentEntryIndex);
                    return;
                }
                
                // Load the view
                loadView(entry);
                
                // Schedule next rotation
                const duration = entry.display_duration * 1000; // Convert to milliseconds
                rotationTimer = setTimeout(() => {
                    // Move to next entry
                    currentEntryIndex = (currentEntryIndex + 1) % currentPlaylist.length;
                    startRotation();
                }, duration);
                
                console.log(`Displaying ${entry.view_type} for ${entry.display_duration}s (entry ${currentEntryIndex + 1}/${currentPlaylist.length})`);
            }
            
            /**
             * Update playlist if changed
             */
            async function updatePlaylistIfChanged() {
                const data = await fetchPlaylist();
                if (!data || !data.playlist) {
                    return;
                }
                
                // Create hash of playlist to detect changes
                const playlistHash = JSON.stringify(data.playlist);
                
                if (playlistHash !== currentPlaylistHash) {
                    console.log('Playlist changed, updating...');
                    currentPlaylist = data.playlist;
                    currentPlaylistHash = playlistHash;
                    
                    // Reset to first entry if playlist changed
                    currentEntryIndex = 0;
                    
                    // Restart rotation with new playlist
                    if (rotationTimer) {
                        clearTimeout(rotationTimer);
                    }
                    startRotation();
                }
            }
            
            /**
             * Initialize the playlist controller
             */
            async function init() {
                console.log('Initializing Kiosk Playlist Controller for device:', DEVICE_UID);
                console.log('API Base URL:', API_BASE);
                
                // Initial playlist fetch
                const data = await fetchPlaylist();
                console.log('Playlist data received:', data);
                
                if (!data) {
                    console.error('Failed to load initial playlist - no data returned');
                    return;
                }
                
                // Check for API errors
                if (data.error) {
                    console.error('API error:', data.error, data);
                    
                    // Special handling for maintenance mode
                    if (data.error_code === 'DEVICE_INACTIVE' || data.maintenance_mode) {
                        // Show maintenance page instead of error message
                        showMaintenancePage();
                        return;
                    }
                    
                    return;
                }
                
                if (data && data.playlist) {
                    currentPlaylist = data.playlist;
                    currentPlaylistHash = JSON.stringify(data.playlist);
                    
                    console.log('Playlist entries:', currentPlaylist.length);
                    console.log('Device info:', {
                        name: data.device_name,
                        total_entries: data.total_entries,
                        active_entries: data.active_entries,
                        inactive_entries: data.inactive_entries
                    });
                    
                    if (currentPlaylist.length > 0) {
                        // Start rotation
                        startRotation();
                    } else {
                        console.warn('Playlist is empty - no active entries found');
                        // Show configuration page instead of error message
                        showConfigurationPage();
                    }
                } else {
                    console.error('Invalid playlist data structure:', data);
                }
                
                // Set up periodic updates
                playlistUpdateTimer = setInterval(updatePlaylistIfChanged, PLAYLIST_UPDATE_INTERVAL);
                commandCheckTimer = setInterval(checkCommands, COMMAND_CHECK_INTERVAL);
                
                // Initial command check
                checkCommands();
            }
            
            // Start when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
            
            // Cleanup on page unload
            window.addEventListener('beforeunload', () => {
                if (rotationTimer) clearTimeout(rotationTimer);
                if (playlistUpdateTimer) clearInterval(playlistUpdateTimer);
                if (commandCheckTimer) clearInterval(commandCheckTimer);
            });
        })();
    </script>
</body>
</html>

