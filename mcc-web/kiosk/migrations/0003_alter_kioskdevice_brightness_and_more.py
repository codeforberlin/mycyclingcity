# Generated by Django 5.2.9 on 2026-02-04 16:58

import django.core.validators
import django.db.models.deletion
from django.db import migrations, models


def add_event_filter_if_not_exists(apps, schema_editor):
    """
    Add event_filter field if it doesn't exist (fresh install).
    For existing systems: Field already exists, FK constraint already correct.
    """
    db_alias = schema_editor.connection.alias
    connection = schema_editor.connection
    
    # Check if column exists
    with connection.cursor() as cursor:
        cursor.execute("PRAGMA table_info(kiosk_kioskplaylistentry)")
        columns = [row[1] for row in cursor.fetchall()]
        field_exists = 'event_filter_id' in columns
    
    if not field_exists:
        # Fresh install: Add the field using direct SQL (more reliable)
        with connection.cursor() as cursor:
            try:
                # Execute the ALTER TABLE statement
                cursor.execute(
                    "ALTER TABLE kiosk_kioskplaylistentry ADD COLUMN event_filter_id INTEGER NULL REFERENCES eventboard_event(id) ON DELETE SET NULL"
                )
            except Exception as e:
                # If field already exists (shouldn't happen, but be safe), ignore
                error_msg = str(e).lower()
                if 'duplicate column' not in error_msg and 'already exists' not in error_msg:
                    raise
    # Existing system: Field already exists, no action needed


def add_field_if_not_exists(apps, schema_editor):
    """
    Add event_filter field to state if it doesn't exist in database.
    This is a wrapper to handle the case where the field was already added by RunPython.
    """
    # This function is called after RunPython, so the field should already exist in DB
    # We just need to update the state
    pass


def reverse_add_event_filter_if_not_exists(apps, schema_editor):
    """Reverse: Remove event_filter field if it exists."""
    with schema_editor.connection.cursor() as cursor:
        cursor.execute("PRAGMA table_info(kiosk_kioskplaylistentry)")
        columns = [row[1] for row in cursor.fetchall()]
        
        if 'event_filter_id' in columns:
            # SQLite doesn't support DROP COLUMN directly, but for reverse we can skip
            # In practice, this migration should not be reversed
            pass


class Migration(migrations.Migration):

    dependencies = [
        ('api', '0012_delete_event_delete_eventhistory_and_more'),
        ('eventboard', '0001_initial'),
        ('kiosk', '0002_kioskdevice_assigned_to_group_and_more'),
    ]

    operations = [
        migrations.AlterField(
            model_name='kioskdevice',
            name='brightness',
            field=models.IntegerField(default=100, help_text='Helligkeitsstufe der Anzeige (0-100)', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100)], verbose_name='Helligkeit'),
        ),
        migrations.AlterField(
            model_name='kioskdevice',
            name='command_queue',
            field=models.JSONField(blank=True, default=list, help_text="JSON-Array mit ausstehenden Hardware-Befehlen (z.B. ['RELOAD', 'SET_BRIGHTNESS:50'])", verbose_name='Befehls-Warteschlange'),
        ),
        migrations.AlterField(
            model_name='kioskdevice',
            name='is_active',
            field=models.BooleanField(default=True, help_text='Ob dieses Gerät derzeit aktiv ist und Inhalte anzeigen soll', verbose_name='Aktiv'),
        ),
        migrations.AlterField(
            model_name='kioskdevice',
            name='name',
            field=models.CharField(help_text='Lesbarer Name für dieses Kiosk-Gerät', max_length=200, verbose_name='Gerätename'),
        ),
        migrations.AlterField(
            model_name='kioskdevice',
            name='uid',
            field=models.CharField(help_text='Eindeutige Kennung für dieses Gerät (z.B. MAC-Adresse oder Seriennummer)', max_length=100, unique=True, verbose_name='Eindeutige ID'),
        ),
        migrations.AlterField(
            model_name='kioskplaylistentry',
            name='display_duration',
            field=models.IntegerField(default=30, help_text='Wie lange diese Ansicht angezeigt werden soll, bevor zur nächsten gewechselt wird', validators=[django.core.validators.MinValueValidator(1)], verbose_name='Anzeigedauer (Sekunden)'),
        ),
        # Add event_filter field conditionally to handle both cases:
        # 1. Fresh install: field doesn't exist, needs to be added
        # 2. Existing system: field exists (from kiosk.0001), FK constraint already correct (api.0012 renamed table)
        # First, use RunPython to conditionally add the field in the database if it doesn't exist
        migrations.RunPython(
            add_event_filter_if_not_exists,
            reverse_add_event_filter_if_not_exists,
        ),
        # Then update the state to reflect event_filter pointing to eventboard.event
        # Use SeparateDatabaseAndState to prevent AddField from trying to add it again in the database
        migrations.SeparateDatabaseAndState(
            database_operations=[
                # No database operation - field already created by RunPython above
                migrations.RunSQL(migrations.RunSQL.noop, migrations.RunSQL.noop),
            ],
            state_operations=[
                # Only update the state
                migrations.AddField(
                    model_name='kioskplaylistentry',
                    name='event_filter',
                    field=models.ForeignKey(blank=True, help_text='Optional: Inhalte nach spezifischem Event filtern', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='kiosk_playlist_entries', to='eventboard.event', verbose_name='Event-Filter'),
                ),
            ],
        ),
        migrations.AlterField(
            model_name='kioskplaylistentry',
            name='group_filter',
            field=models.ForeignKey(blank=True, help_text='Optional: Inhalte filtern, um nur Gruppen und Radler anzuzeigen, die zu dieser Hauptgruppe gehören', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='kiosk_playlist_entries', to='api.group', verbose_name='Gruppen-Filter'),
        ),
        migrations.AlterField(
            model_name='kioskplaylistentry',
            name='is_active',
            field=models.BooleanField(default=True, help_text='Ob dieser Eintrag in der Playlist aktiv ist', verbose_name='Aktiv'),
        ),
        migrations.AlterField(
            model_name='kioskplaylistentry',
            name='order',
            field=models.PositiveIntegerField(default=1, help_text='Anzeigereihenfolge in der Playlist (niedrigere Zahlen zuerst, beginnt bei 1)', verbose_name='Reihenfolge'),
        ),
        migrations.AlterField(
            model_name='kioskplaylistentry',
            name='track_filter',
            field=models.ManyToManyField(blank=True, help_text='Optional: Kartenansicht filtern, um nur ausgewählte Routen anzuzeigen (leer lassen, um alle Routen anzuzeigen)', related_name='kiosk_playlist_entries', to='api.traveltrack', verbose_name='Routen-Filter'),
        ),
        migrations.AlterField(
            model_name='kioskplaylistentry',
            name='view_type',
            field=models.CharField(choices=[('leaderboard', 'Leaderboard'), ('eventboard', 'Eventboard'), ('map', 'Map')], default='leaderboard', help_text='Art der anzuzeigenden Ansicht', max_length=20, verbose_name='Ansichtstyp'),
        ),
    ]
