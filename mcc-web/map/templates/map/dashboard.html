<!-- Copyright (c) 2026 SAI-Lab / MyCyclingCity
     SPDX-License-Identifier: AGPL-3.0-or-later
     
     @file    dashboard.html
     @author  Roland Rutz
     @note    This code was developed with the assistance of AI (LLMs).
-->

{% load i18n l10n map_filters %}
{% get_current_language as LANGUAGE_CODE %}
<!DOCTYPE html>
<html lang="{{ LANGUAGE_CODE }}">
<head>
    <meta charset="UTF-8">
    <title>{% trans "Live-Map & Wettbewerb" %}</title>
    {% url 'favicon' as favicon_url %}
    <link rel="icon" type="image/png" href="{{ favicon_url }}">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
        /* Full-screen layout */
        body, html { 
            margin: 0; 
            padding: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; 
            background: #000; 
            overflow: hidden; 
            height: 100vh;
            width: 100vw;
        }
        #map { 
            height: 100vh; 
            width: 100vw; 
        }


        /* Activity Toast System (replaces ticker) */
        .activity-toast-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 4500;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 380px;
            pointer-events: none;
        }
        .activity-toast {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 14px 18px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            pointer-events: auto;
            animation: toastSlideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transition: opacity 0.3s, transform 0.3s;
        }
        .activity-toast.fade-out {
            animation: toastSlideOut 0.3s ease-in forwards;
        }
        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateX(400px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        @keyframes toastSlideOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(400px);
            }
        }
        .activity-toast-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        .activity-toast-icon {
            font-size: 20px;
        }
        .activity-toast-title {
            font-weight: 600;
            font-size: 14px;
            color: #1a1a1a;
        }
        .activity-toast-body {
            font-size: 13px;
            color: #4a4a4a;
            line-height: 1.5;
        }
        .activity-toast-cyclist {
            font-weight: 600;
            color: #007bff;
        }
        .activity-toast-distance {
            font-weight: 600;
            color: #28a745;
        }
        /* Legacy ticker styles (hidden) */
        .live-ticker-container {
            display: none;
        }
        .ticker-scroll {
            display: none;
        }
        .ticker-item { display: none; }


        /* Champions Overlay - Mini Podium (default) and Hero Cards (expanded) */
        .champions-overlay {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 4000; /* Below active cyclist avatars (z-index 5000+) but above map */
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }
        
        .champions-overlay.ghost-mode {
            opacity: 0.2;
        }
        
        .champions-overlay.hidden {
            display: none;
        }
        
        /* Mini Podium (default compact view) */
        .mini-podium {
            display: flex;
            align-items: flex-end;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 215, 0, 0.5);
        }
        
        .mini-podium-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .mini-podium-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid;
            object-fit: cover;
            background: white;
        }
        
        .mini-podium-item[data-rank="1"] .mini-podium-avatar {
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }
        
        .mini-podium-item[data-rank="2"] .mini-podium-avatar {
            border-color: #c0c0c0;
            box-shadow: 0 0 8px rgba(192, 192, 192, 0.5);
        }
        
        .mini-podium-item[data-rank="3"] .mini-podium-avatar {
            border-color: #cd7f32;
            box-shadow: 0 0 8px rgba(205, 127, 50, 0.5);
        }
        
        .mini-podium-rank {
            font-size: 12px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
        }
        
        .mini-podium-expand-btn {
            margin-left: 8px;
            padding: 6px 12px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
            color: #ffd700;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .mini-podium-expand-btn:hover {
            background: rgba(255, 215, 0, 0.3);
            border-color: rgba(255, 215, 0, 0.8);
        }
        
        /* Hero Cards (expanded view) */
        .hero-cards {
            display: none;
            flex-direction: column;
            gap: 12px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 215, 0, 0.6);
            min-width: 320px;
            max-width: 400px;
        }
        
        .hero-cards.expanded {
            display: flex;
        }
        
        .hero-card {
            display: flex;
            align-items: center;
            gap: 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .hero-card[data-rank="1"] {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.15);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .hero-card[data-rank="2"] {
            border-color: #c0c0c0;
            background: rgba(192, 192, 192, 0.1);
        }
        
        .hero-card[data-rank="3"] {
            border-color: #cd7f32;
            background: rgba(205, 127, 50, 0.1);
        }
        
        .hero-card-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid;
            object-fit: cover;
            background: white;
            flex-shrink: 0;
        }
        
        .hero-card[data-rank="1"] .hero-card-avatar {
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }
        
        .hero-card[data-rank="2"] .hero-card-avatar {
            border-color: #c0c0c0;
            box-shadow: 0 0 12px rgba(192, 192, 192, 0.5);
        }
        
        .hero-card[data-rank="3"] .hero-card-avatar {
            border-color: #cd7f32;
            box-shadow: 0 0 12px rgba(205, 127, 50, 0.5);
        }
        
        .hero-card-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .hero-card-rank {
            font-size: 14px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
        }
        
        .hero-card-name {
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .hero-card-details {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .hero-card-travel-time {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .hero-card-mvp {
            font-size: 11px;
            color: #ffd700;
            font-weight: bold;
            margin-top: 2px;
        }
        
        .hero-card-top-contributor {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
            margin-top: 2px;
        }
        
        .hero-cards-collapse-btn {
            align-self: flex-end;
            padding: 6px 12px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
            color: #ffd700;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
        }
        
        .hero-cards-collapse-btn:hover {
            background: rgba(255, 215, 0, 0.3);
            border-color: rgba(255, 215, 0, 0.8);
        }

        /* Milestone Overlay - Matching Champions Overlay Design */
        .milestone-overlay {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 4001; /* Above champions overlay (z-index 4000) but below active cyclist avatars (z-index 5000+) */
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }
        
        .milestone-overlay.hidden {
            display: none;
        }
        
        .milestone-card {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 215, 0, 0.6);
            min-width: 320px;
            max-width: 400px;
            animation: milestoneSlideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes milestoneSlideIn {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .milestone-card.fade-out {
            animation: milestoneSlideOut 0.3s ease-in forwards;
        }
        
        @keyframes milestoneSlideOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100px);
            }
        }
        
        .milestone-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .milestone-card-icon {
            font-size: 32px;
            line-height: 1;
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.6));
        }
        
        .milestone-card-title {
            flex: 1;
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
        }
        
        .milestone-card-close-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            color: #ffffff;
            font-size: 16px;
            line-height: 1;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .milestone-card-close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .milestone-card-name {
            font-size: 20px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            margin-bottom: 12px;
        }
        
        .milestone-card-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .milestone-card-info-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .milestone-card-info-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .milestone-card-info-value {
            font-size: 14px;
            color: #ffffff;
            font-weight: 500;
        }
        
        .milestone-card-info-value.highlight {
            color: #ffd700;
            text-shadow: 0 0 4px rgba(255, 215, 0, 0.6);
        }

        /* Beschreibung - scrollbar für lange Texte */
        .milestone-card-description {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 215, 0, 0.2);
        }

        .milestone-card-description-text {
            margin-top: 8px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            line-height: 1.6;
            max-height: 200px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
        }

        /* Externer Link Button - groß und touch-freundlich */
        .milestone-card-external-link {
            margin-top: 16px;
            padding-top: 16px;
            padding-left: 0;
            padding-right: 0;
            border-top: 1px solid rgba(255, 215, 0, 0.2);
            box-sizing: border-box;
        }

        .milestone-external-link-btn {
            display: block;
            width: 100%;
            max-width: 100%;
            padding: 14px 20px;
            background: rgba(59, 130, 246, 0.3);
            border: 2px solid rgba(59, 130, 246, 0.5);
            border-radius: 12px;
            text-decoration: none;
            color: white;
            text-align: center;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.2s;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-sizing: border-box;
            overflow: hidden;
            word-wrap: break-word;
        }

        .milestone-external-link-btn:hover {
            background: rgba(59, 130, 246, 0.5);
        }

        .milestone-external-link-btn:active {
            background: rgba(59, 130, 246, 0.5);
            transform: scale(0.98);
        }

        /* Details-Button im Popup */
        .milestone-details-btn-container {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .milestone-details-btn {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            min-height: 44px;
            transition: all 0.2s;
        }

        .milestone-details-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .milestone-details-btn:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.98);
        }

        .group-icon-container {
        text-align: center;
        transition: transform 0.3s ease-out; /* Smooth transition on position change */
    }
    .group-icon-img {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        border: 3px solid #ffffff; /* White border makes logos stand out better from track */
        background: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }
    .group-icon-label {
        background: rgba(255,255,255,0.95);
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 11px;
        font-weight: bold;
        color: #333;
        border: 1px solid #ccc;
        white-space: nowrap;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        margin-top: 2px;
        display: block;
        line-height: 1.2;
    }

        /* Unified Glassmorphism Design Language */
        /* Floating View Switcher - Top Right */
        .floating-view-switcher {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 5000;
            display: flex;
            gap: 0;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px; /* rounded-xl equivalent */
            padding: 4px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .floating-view-switcher button {
            padding: 10px 24px;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }
        .floating-view-switcher button:hover {
            color: #007bff;
            background: rgba(0, 123, 255, 0.1);
        }
        .floating-view-switcher button.active {
            color: #007bff;
            background: rgba(0, 123, 255, 0.15);
            font-weight: 600;
        }
        
        /* Floating Layer Control - Map View */
        .floating-layer-control {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 4999;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px; /* rounded-xl equivalent */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: 320px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .layer-control-toggle {
            width: 44px; /* Minimum touch target */
            height: 44px; /* Minimum touch target */
            border: none;
            background: transparent;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            transition: all 0.3s;
            padding: 0;
        }
        .layer-control-toggle:hover {
            background: rgba(0, 123, 255, 0.1);
            color: #007bff;
        }
        .layer-control-content {
            display: none;
            padding: 16px;
            max-height: 70vh;
            overflow-y: auto;
        }
        .floating-layer-control.expanded .layer-control-content {
            display: block;
        }
        .layer-control-section {
            margin-bottom: 20px;
        }
        .layer-control-section:last-child {
            margin-bottom: 0;
        }
        /* Hide tracks section in ranking view - handled by JavaScript */
        /* Hide groups section in map view - handled by JavaScript */
        .layer-control-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin: 0 0 12px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .layer-control-toggles {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        /* Modern Toggle Switch - Enhanced with color support */
        .modern-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            padding: 8px 12px;
            min-height: 44px; /* Minimum touch target for kiosk */
            border-radius: 8px;
            transition: background 0.2s;
            user-select: none;
        }
        .modern-toggle:hover {
            background: rgba(0, 123, 255, 0.05);
        }
        .modern-toggle-input {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            margin: 0;
            padding: 0;
            border: 0;
            clip: rect(0, 0, 0, 0);
            /* Keep pointer-events enabled so clicks work on the label */
        }
        
        /* Also ensure layer-toggle-input is completely hidden */
        .layer-toggle-input {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            margin: 0;
            padding: 0;
            border: 0;
            clip: rect(0, 0, 0, 0);
            /* Keep pointer-events enabled so clicks work on the label */
        }
        .modern-toggle-slider {
            position: relative;
            width: 44px; /* Minimum touch target */
            height: 24px;
            background: #ccc;
            border-radius: 24px;
            transition: background 0.3s, border-color 0.3s;
            flex-shrink: 0;
            border: 2px solid transparent;
        }
        .modern-toggle-slider::before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        /* Default blue for tracks */
        .modern-toggle-input:checked + .modern-toggle-slider,
        .layer-toggle-input:checked + .modern-toggle-slider {
            background: #007bff;
        }
        .modern-toggle-input:checked + .modern-toggle-slider::before,
        .layer-toggle-input:checked + .modern-toggle-slider::before {
            transform: translateX(20px);
        }
        /* Dynamic color support for tracks and groups */
        .layer-toggle-input[data-color]:checked + .modern-toggle-slider {
            background: var(--toggle-color, #007bff);
            border-color: var(--toggle-color, #007bff);
        }
        .modern-toggle-label {
            font-size: 14px;
            color: #333;
            font-weight: 500;
            flex: 1;
        }
        /* High contrast for kiosk mode */
        .kiosk-mode .floating-layer-control {
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.5);
        }
        .kiosk-mode .layer-control-title {
            color: #fff;
        }
        .kiosk-mode .modern-toggle-label {
            color: #fff;
        }
        .kiosk-mode .modern-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* Ranking Filter Bar - Glassmorphism Design */
        .ranking-filter-bar {
            position: sticky;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10001; /* Higher than ranking content to stay on top */
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 16px 24px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 0 0 12px 12px; /* rounded-xl bottom corners */
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            display: none; /* Hidden by default, shown when ranking view is active */
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            width: 100%;
            box-sizing: border-box;
            margin: 0;
            overflow-x: auto;
            overflow-y: visible;
        }
        /* Show ranking filter bar when ranking view is active */
        #section-ranking.active .ranking-filter-bar {
            display: flex !important;
        }
        .ranking-filter-bar::-webkit-scrollbar {
            height: 4px;
        }
        .ranking-filter-bar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }
        .ranking-filter-bar::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }
        .ranking-filter-bar-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-right: 8px;
        }
        /* Filter Chips - Top-Level Groups (Schools) */
        .filter-chip {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            min-height: 44px; /* Minimum touch target for kiosk */
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px; /* rounded-xl */
            font-size: 14px;
            font-weight: 600;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            white-space: nowrap;
        }
        .filter-chip:hover {
            background: rgba(255, 255, 255, 1);
            border-color: rgba(0, 123, 255, 0.3);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        .filter-chip.active {
            background: var(--chip-color, #007bff);
            color: white;
            border-color: var(--chip-color, #007bff);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
            opacity: 1;
        }
        .filter-chip:not(.active) {
            background: rgba(255, 255, 255, 0.6);
            color: #666;
            border-color: rgba(0, 0, 0, 0.2);
            opacity: 0.6;
        }
        .filter-chip:not(.active):hover {
            background: rgba(255, 255, 255, 0.8);
            opacity: 0.8;
        }
        /* Sub-Group Chips (Classes) - Smaller, compact */
        .filter-chip.sub-group {
            padding: 6px 12px;
            min-height: 36px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 8px;
        }
        /* Chip Container - Scrollable when more than 15 chips */
        .filter-chips-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            max-width: 100%;
        }
        .filter-chips-container.scrollable {
            overflow-x: auto;
            overflow-y: visible;
            flex-wrap: nowrap;
            padding-bottom: 4px;
        }
        .filter-chips-container.scrollable::-webkit-scrollbar {
            height: 4px;
        }
        .filter-chips-container.scrollable::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }
        .filter-chips-container.scrollable::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }
        /* Sub-Groups Row */
        .filter-sub-groups-row {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
            padding-left: 12px;
            border-left: 3px solid;
            animation: slideDown 0.2s ease-out;
        }
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .filter-chip .chip-close {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
            transition: background 0.2s;
        }
        .filter-chip.active .chip-close {
            background: rgba(255, 255, 255, 0.3);
        }
        .filter-chip .chip-close:hover {
            background: rgba(0, 0, 0, 0.2);
        }
        .filter-chip.active .chip-close:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        .filter-dropdown-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
        }
        .filter-dropdown-toggle:hover {
            background: rgba(0, 0, 0, 0.1);
        }
        .filter-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            min-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 10002; /* Higher than ranking content and other UI elements */
            display: none;
            padding: 8px;
        }
        .filter-dropdown.show {
            display: block !important;
        }
        .filter-dropdown-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .filter-dropdown-item:hover {
            background: rgba(0, 123, 255, 0.05);
        }
        .filter-dropdown-item .modern-toggle {
            flex: 1;
            padding: 0;
        }
        .filter-dropdown-item .modern-toggle-label {
            flex: 1;
        }
        /* High contrast for kiosk mode */
        .kiosk-mode .ranking-filter-bar {
            background: rgba(0, 0, 0, 0.95);
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
        }
        .kiosk-mode .ranking-filter-bar-title {
            color: #fff;
        }
        .kiosk-mode .filter-chip {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            color: #fff;
        }
        .kiosk-mode .filter-chip.active {
            background: #007bff;
            border-color: #007bff;
        }
        .kiosk-mode .filter-dropdown-toggle {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            color: #fff;
        }
        .kiosk-mode .filter-dropdown {
            background: rgba(0, 0, 0, 0.95);
            border-color: rgba(255, 255, 255, 0.3);
        }
        .kiosk-mode .filter-dropdown-item {
            color: #fff;
        }
        .kiosk-mode .filter-dropdown-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* Information Hub Button - Global UI Layer */
        .info-hub-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #333;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .info-hub-button:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 1);
        }
        
        /* Information Hub Modal - Global UI Layer */
        .info-hub-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 10001;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease-out;
            padding: 20px;
        }
        .info-hub-modal-overlay.show {
            display: flex;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .info-hub-modal {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 24px;
            max-width: 600px;
            max-height: 85vh;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
            animation: modalSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        .info-hub-header {
            padding: 28px 32px 24px 32px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        .info-hub-title {
            font-size: 28px;
            font-weight: 700;
            color: #1a1a1a;
            margin: 0 0 12px 0;
        }
        .info-hub-version {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            color: #666;
        }
        .info-hub-version-label {
            font-weight: 500;
        }
        .info-hub-version-value {
            font-weight: 600;
            color: #007bff;
            font-family: 'Courier New', monospace;
        }
        .info-hub-body {
            padding: 24px 32px;
            overflow-y: auto;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }
        .info-hub-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .info-hub-section-title {
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            margin: 0;
        }
        .info-hub-faq {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .info-hub-accordion-item {
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.2s;
        }
        .info-hub-accordion-item:hover {
            border-color: rgba(0, 123, 255, 0.3);
        }
        .info-hub-accordion-header {
            padding: 16px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            background: rgba(255, 255, 255, 0.5);
            transition: background 0.2s;
        }
        .info-hub-accordion-header:hover {
            background: rgba(0, 123, 255, 0.05);
        }
        .info-hub-accordion-question {
            font-size: 15px;
            font-weight: 600;
            color: #1a1a1a;
            flex: 1;
        }
        .info-hub-accordion-icon {
            font-size: 18px;
            color: #666;
            transition: transform 0.3s;
        }
        .info-hub-accordion-item.open .info-hub-accordion-icon {
            transform: rotate(180deg);
        }
        .info-hub-accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 20px;
        }
        .info-hub-accordion-item.open .info-hub-accordion-content {
            max-height: 500px;
            padding: 0 20px 16px 20px;
        }
        .info-hub-accordion-answer {
            font-size: 14px;
            line-height: 1.6;
            color: #4a4a4a;
        }
        .info-hub-wiki-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border-radius: 12px;
            text-decoration: none;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        }
        .info-hub-wiki-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
        }
        .info-hub-language-form {
            display: flex;
            width: 100%;
        }
        .info-hub-language-select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            font-size: 15px;
            background: rgba(255, 255, 255, 0.8);
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }
        .info-hub-language-select:hover {
            border-color: rgba(0, 123, 255, 0.3);
            background: rgba(255, 255, 255, 1);
        }
        .info-hub-footer {
            padding: 20px 32px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(0, 0, 0, 0.02);
        }
        .info-hub-footer-content {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 12px;
            color: #666;
        }
        .info-hub-footer-link {
            color: #007bff;
            text-decoration: none;
            transition: color 0.2s;
        }
        .info-hub-footer-link:hover {
            color: #0056b3;
            text-decoration: underline;
        }
        .info-hub-footer-separator {
            color: #ccc;
        }
        .info-hub-footer-copyright {
            color: #999;
        }
        .info-hub-footer-copyright a {
            color: #007bff;
            text-decoration: none;
        }
        .info-hub-footer-copyright a:hover {
            text-decoration: underline;
        }
        .info-hub-close {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: rgba(0, 0, 0, 0.05);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #666;
            transition: all 0.2s;
            z-index: 1;
        }
        .info-hub-close:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #333;
            transform: rotate(90deg);
        }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .info-hub-modal {
                max-width: 95%;
                max-height: 90vh;
                border-radius: 20px;
            }
            .info-hub-header {
                padding: 24px 20px 20px 20px;
            }
            .info-hub-title {
                font-size: 24px;
            }
            .info-hub-body {
                padding: 20px;
            }
            .info-hub-footer {
                padding: 16px 20px;
            }
        }
        
        /* View sections with smooth transitions */
        #section-map, #section-ranking {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
        }
        #section-map {
            opacity: 1;
            transform: translateX(0);
            z-index: 1;
        }
        #section-map.hidden {
            opacity: 0;
            transform: translateX(-100%);
            pointer-events: none;
            z-index: 0;
        }
        #section-ranking {
            opacity: 0;
            transform: translateX(100%);
            pointer-events: none;
            z-index: 0;
            overflow-y: auto;
            overflow-x: hidden;
            background: #ffffff;
        }
        #section-ranking.active {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
            z-index: 1;
            background: #ffffff;
        }
        #ranking-content {
            width: 100%;
            min-height: 100%;
            padding: 0;
            background: #ffffff;
        }
        /* Add padding-top to ranking content to prevent overlap with view switcher */
        #section-ranking.active #ranking-content {
            padding-top: 80px;
        }
        /* Hide sidebar and sidebar toggle in ranking view */
        #section-ranking.active ~ .sidebar-toggle,
        #section-ranking.active ~ .glassmorphism-sidebar {
            display: none !important;
        }
        /* Ensure ranking filter bar doesn't overflow */
        #section-ranking.active .ranking-filter-bar {
            position: sticky;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            margin: 0;
            padding-left: 20px;
            padding-right: 20px;
        }
        /* stylelint-enable */

        /* ============================================
           Mobile-Only Overrides (max-width: 1023px)
           Protects Kiosk Mode - Desktop remains untouched
           ============================================ */
        @media screen and (max-width: 1023px) {
            /* Root Scaling: Scale up all rem-based elements for mobile */
            html {
                font-size: 110%; /* Scales all rem-based elements up */
            }

            /* Full-screen map layout: Fill entire screen on mobile - Remove white gap */
            html, body {
                margin: 0;
                padding: 0;
                height: 100%;
                overflow: hidden; /* Prevent unwanted scrolling on the map page */
            }

            /* Typography: Ensure minimum readable size for mobile */
            body {
                font-size: 16px; /* Minimum readable size for mobile */
                line-height: 1.5;
            }

            /* Map optimization: Full height with absolute positioning to remove white gap */
            #map {
                height: 100vh !important; /* Full height */
                width: 100vw !important;
                position: absolute;
                top: 0;
                left: 0;
                margin: 0;
                padding: 0;
            }

            /* Activity Toast Container: Adjust position and size for mobile */
            .activity-toast-container {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: calc(100% - 20px);
            }

            /* Champions Overlay: Adjust position for mobile */
            .champions-overlay {
                bottom: 10px;
                left: 10px;
                right: 10px;
            }

            .mini-podium {
                flex-wrap: wrap;
                justify-content: center;
            }

            /* Touch targets: Increase padding for buttons and interactive elements */
            button, .sidebar-toggle, .info-hub-button {
                min-height: 44px; /* Touch-friendly minimum height */
                min-width: 44px;
                padding: 15px 25px; /* Larger padding for better touch targets */
                font-size: 16px; /* Ensure readable button text */
            }

            /* View Switch Button: Mobile-Only Overlay - Position at top right */
            .floating-view-switcher {
                position: fixed !important;
                top: 15px; /* Stay at the top */
                right: 15px;
                bottom: auto; /* Ensure it doesn't move to the bottom */
                z-index: 2000; /* Above everything else */
                background: white; /* Solid background for mobile */
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
                border-radius: 30px; /* More rounded for mobile */
                padding: 4px;
            }

            .floating-view-switcher button {
                padding: 15px 25px; /* Larger padding for touch targets */
                font-size: 16px;
                min-height: 44px;
                font-weight: bold; /* Make text more prominent */
                border-radius: 30px; /* Match container rounding */
            }

            /* Small text blocks and labels: Ensure minimum readable size */
            label, .layer-control-title, .activity-toast-title, .activity-toast-body,
            .milestone-card-label, .milestone-card-value, .ranking-filter-bar-title {
                font-size: 14px; /* Minimum readable size for labels */
            }

            /* Ensure text in toasts and overlays is readable */
            .activity-toast-title {
                font-size: 15px;
            }

            .activity-toast-body {
                font-size: 14px;
            }

            /* Glassmorphism Sidebar: Full width on mobile */
            .glassmorphism-sidebar {
                width: 100%;
                max-width: 100%;
            }

            /* Ranking Filter Bar: Ensure it doesn't overflow on mobile */
            .ranking-filter-bar {
                padding: 15px; /* Increased padding for better touch targets */
                flex-wrap: wrap;
            }

            .ranking-filter-bar-title {
                font-size: 16px; /* Larger title for readability */
            }

            .filter-chips-container {
                flex-wrap: wrap;
                gap: 8px;
            }

            /* Info Hub Modal: Full width on mobile with proper padding */
            .info-hub-modal {
                max-width: 95%;
                margin: 20px;
            }

            /* Milestone Overlay: Adjust for mobile screens */
            .milestone-overlay {
                padding: 10px;
            }

            .milestone-card {
                max-width: 95%;
            }
        }
    </style>
</head>
<body>

    <!-- Hidden ticker target for HTMX updates (data source for Activity Toasts) -->
    <div id="ticker-target" class="live-ticker-container"
         hx-get="{% url 'map:map_ticker' %}{% if group_id %}?group_id={{ group_id|urlencode }}{% elif group_name %}?group_name={{ group_name|urlencode }}{% endif %}"
         hx-trigger="load, every {{ refresh_interval }}s"
         hx-swap="innerHTML"
         style="display: none;">
    </div>

    <!-- Floating View Switcher -->
    <div class="floating-view-switcher">
        <button id="btn-show-map" class="active" onclick="showMapView()">{% trans "Karte" %}</button>
        <button id="btn-show-ranking" onclick="showRankingView()">{% trans "Ranking" %}</button>
    </div>

    <!-- Floating Layer Control (Map View) -->
    <div class="floating-layer-control" id="floating-layer-control">
        <button class="layer-control-toggle" onclick="toggleLayerControl()" title="{% trans 'Ebenen anzeigen/verstecken' %}">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                <path d="M2 17l10 5 10-5"></path>
                <path d="M2 12l10 5 10-5"></path>
            </svg>
        </button>
        <div class="layer-control-content" id="layer-control-content">
            <div class="layer-control-section" id="layer-control-tracks-section">
                <h3 class="layer-control-title">{% trans "Routen" %}</h3>
                <div class="layer-control-toggles">
                    <label class="modern-toggle">
                        <input type="checkbox" id="layer-track-all" class="layer-toggle-input" 
                               {% if not selected_track_ids or selected_track_ids|length == 0 %}checked{% endif %}
                               onchange="handleLayerTrackAllChange(this)">
                        <span class="modern-toggle-slider"></span>
                        <span class="modern-toggle-label">{% trans "Alle Routen" %}</span>
                    </label>
                    {% for track in all_tracks %}
                    <label class="modern-toggle">
                        <input type="checkbox" class="layer-toggle-input layer-track-toggle" 
                               value="{{ track.id }}" 
                               data-color="#007bff"
                               style="--toggle-color: #007bff;"
                               {% if selected_track_ids and track.id|stringformat:"s" in selected_track_ids %}checked{% else %}{% if not selected_track_ids or selected_track_ids|length == 0 %}checked{% endif %}{% endif %}
                               onchange="handleLayerTrackChange(this)" 
                               id="layer-track-{{ track.id }}">
                        <span class="modern-toggle-slider"></span>
                        <span class="modern-toggle-label">{% trans track.name %}</span>
                    </label>
                    {% endfor %}
                </div>
            </div>
            <div class="layer-control-section" id="layer-control-groups-section">
                <h3 class="layer-control-title">{% trans "Gruppen" %}</h3>
                <div class="layer-control-toggles">
                    <label class="modern-toggle">
                        <input type="checkbox" id="layer-group-all" class="layer-toggle-input"
                               {% if not selected_group_ids or selected_group_ids|length == 0 %}checked{% endif %}
                               onchange="handleLayerGroupAllChange(this)">
                        <span class="modern-toggle-slider"></span>
                        <span class="modern-toggle-label">{% trans "Alle Gruppen" %}</span>
                    </label>
                    {% for group in all_groups %}
                    <label class="modern-toggle">
                        <input type="checkbox" class="layer-toggle-input layer-group-toggle" 
                               value="{{ group.id }}"
                               data-color="{% if group.color %}{{ group.color }}{% else %}#6b7280{% endif %}"
                               style="--toggle-color: {% if group.color %}{{ group.color }}{% else %}#6b7280{% endif %};"
                               {% if selected_group_ids and group.id|stringformat:"s" in selected_group_ids %}checked{% else %}{% if not selected_group_ids or selected_group_ids|length == 0 %}checked{% endif %}{% endif %}
                               onchange="handleLayerGroupChange(this)"
                               id="layer-group-{{ group.id }}">
                        <span class="modern-toggle-slider"></span>
                        <span class="modern-toggle-label">{% trans group.name %}</span>
                    </label>
                    {% endfor %}
                </div>
            </div>
            <div class="layer-control-section" id="layer-control-winners-section">
                <h3 class="layer-control-title">{% trans "Anzeige" %}</h3>
                <div class="layer-control-toggles">
                    <label class="modern-toggle">
                        <input type="checkbox" id="layer-winners-toggle" class="layer-toggle-input"
                               checked
                               onchange="handleWinnersToggleChange(this)">
                        <span class="modern-toggle-slider"></span>
                        <span class="modern-toggle-label">{% trans "Gewinner anzeigen" %}</span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- Glassmorphism Sidebar Toggle -->
    <button class="sidebar-toggle" id="sidebar-toggle" onclick="toggleSidebar()" title="{% trans 'Steuerung anzeigen/verstecken' %}">
        ☰
    </button>

    <!-- Glassmorphism Sidebar -->
    <div class="glassmorphism-sidebar" id="glassmorphism-sidebar">
        <!-- Track Selector (visible in map view) -->
        <div class="sidebar-section" id="track-selector-section">
            <div class="sidebar-section-title">{% trans "Routen" %}</div>
            <button class="sidebar-selector-button" id="track-selector-button" onclick="toggleTrackDropdown(event)">
                <span id="track-selector-text">{% trans "Alle Routen" %}</span>
                <span>▼</span>
            </button>
            <div class="sidebar-dropdown" id="track-selector-dropdown">
                <div class="sidebar-checkbox-item">
                    <input type="checkbox" id="track-all" value="all" {% if not selected_track_ids or selected_track_ids|length == 0 %}checked{% endif %} onchange="handleTrackAllChange(this)">
                    <label for="track-all"><strong>{% trans "Alle Routen" %}</strong></label>
                </div>
                {% for track in all_tracks %}
                <div class="sidebar-checkbox-item">
                    <input type="checkbox" class="track-checkbox" value="{{ track.id }}" 
                           {% if selected_track_ids and track.id|stringformat:"s" in selected_track_ids %}checked{% else %}{% if not selected_track_ids or selected_track_ids|length == 0 %}checked{% endif %}{% endif %}
                           onchange="handleTrackChange(this)" id="track-{{ track.id }}">
                    <label for="track-{{ track.id }}">{{ track.name }}</label>
                </div>
                {% endfor %}
            </div>
        </div>

        <!-- Group Selector removed - now using Filter Bar in Ranking View -->
    </div>

    <!-- Activity Toast Container -->
    <div class="activity-toast-container" id="activity-toast-container"></div>

    <!-- Global Information Hub (Button + Modal) -->
    {% include "partials/info_hub.html" %}

    <!-- Champions Overlay (Winners Podium) -->
    <div id="champions-overlay" class="champions-overlay hidden">
        <!-- Mini Podium (default compact view) -->
        <div id="mini-podium" class="mini-podium">
            <!-- Top 3 avatars will be dynamically inserted here -->
        </div>
        
        <!-- Hero Cards (expanded view) -->
        <div id="hero-cards" class="hero-cards">
            <!-- Top 3 hero cards will be dynamically inserted here -->
            <button class="hero-cards-collapse-btn" onclick="collapseChampionsOverlay()">{% trans "Weniger anzeigen" %}</button>
        </div>
    </div>

    <!-- Milestone Overlay -->
    <div id="milestone-overlay" class="milestone-overlay hidden">
        <div id="milestone-card" class="milestone-card">
            <div class="milestone-card-header">
                <div class="milestone-card-icon">🏆</div>
                <div class="milestone-card-title" id="milestone-overlay-title">{% trans "Meilenstein" %}</div>
                <button class="milestone-card-close-btn" onclick="closeMilestoneOverlay()">&times;</button>
            </div>
            <div class="milestone-card-name" id="milestone-overlay-name"></div>
            <div class="milestone-card-info">
                <div class="milestone-card-info-item">
                    <div class="milestone-card-info-label">{% trans "Reiseroute" %}</div>
                    <div class="milestone-card-info-value highlight" id="milestone-overlay-track-name"></div>
                </div>
                <div class="milestone-card-info-item">
                    <div class="milestone-card-info-label">{% trans "TOP Gruppe" %}</div>
                    <div class="milestone-card-info-value highlight" id="milestone-overlay-top-group"></div>
                </div>
                <div class="milestone-card-info-item">
                    <div class="milestone-card-info-label">{% trans "Gruppe" %}</div>
                    <div class="milestone-card-info-value highlight" id="milestone-overlay-leaf-group"></div>
                </div>
                <div class="milestone-card-info-item">
                    <div class="milestone-card-info-label">{% trans "Belohnung" %}</div>
                    <div class="milestone-card-info-value" id="milestone-overlay-reward"></div>
                </div>
            </div>
            <!-- Beschreibung (wenn vorhanden) -->
            <div class="milestone-card-description" id="milestone-overlay-description" style="display: none;">
                <div class="milestone-card-info-label">{% trans "Beschreibung" %}</div>
                <div class="milestone-card-description-text" id="milestone-overlay-description-text"></div>
            </div>
            <!-- Externer Link (wenn vorhanden) -->
            <div class="milestone-card-external-link" id="milestone-overlay-link" style="display: none;">
                <a href="#" target="_blank" rel="noopener noreferrer" 
                   class="milestone-external-link-btn" 
                   id="milestone-overlay-link-btn">
                    🔗 {% trans "Weitere Informationen" %}
                </a>
            </div>
        </div>
    </div>

    <!-- View Sections -->
    <div id="section-map">
        <div id="map"></div>
    </div>
    <div id="section-ranking" class="">
        <!-- Ranking Filter Bar with Hierarchical Chips -->
        <div class="ranking-filter-bar" id="ranking-filter-bar">
            <span class="ranking-filter-bar-title">{% trans "Filter:" %}</span>
            <div class="filter-chips-container" id="filter-chips-container">
                <!-- Top-Level Group Chips will be dynamically generated via JavaScript -->
            </div>
        </div>
        <div id="ranking-content">
            <!-- Ranking content will be loaded here via HTMX -->
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-geometryutil@0.10.3/src/leaflet.geometryutil.min.js"></script>
    {% load static %}
    <script src="{% static 'js/timezone-converter.js' %}"></script>
    <script>
        /* eslint-disable */
        // Django Template Variables are inserted here
        var milestonePopupDuration = {{ milestone_popup_duration|default:30000 }};
        var textCurrentlyCycling = '{% trans "Aktuell radelnd" %}';
        
        // Initialize map first
        var map = L.map('map').setView([51.16, 10.45], 6);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
        // Make map available globally for kiosk mode
        window.map = map;

        // Map size adjustment function - fixes quarter-map issue on mobile
        function adjustMap() {
            if (typeof map !== 'undefined') {
                map.invalidateSize();
            }
        }
        window.addEventListener('resize', adjustMap);
        // Call after CSS changes to fill any gaps
        setTimeout(adjustMap, 500);
        setTimeout(adjustMap, 1000); // Additional call to ensure map fills after CSS is fully applied
        var tracks = {{ tracks_json|safe }};
        // Make tracks available globally for avatar refresh logic
        window.tracks = tracks;
        var trackLayers = L.featureGroup().addTo(map);
        var polylineLookup = {};
        var trackPolylineMap = {}; // Map track ID to polyline for show/hide functionality
        var trackStartEndMarkersMap = {}; // Map track ID to start/end markers
        var avatarMarkers = {};
        var finishTimes = {}; // Store finish times: {trackId: {groupName: timestamp}}
        // Make variables available globally for kiosk mode
        window.polylineLookup = polylineLookup;
        window.avatarMarkers = avatarMarkers;
        window.finishTimes = finishTimes;
        var milestones = {{ milestones_json|safe }};
        var milestoneMarkers = L.layerGroup().addTo(map);
        var devices = {{ devices_json|safe }};
        var deviceMarkers = L.layerGroup().addTo(map);
        // Track markers will be managed per track in trackStartEndMarkersMap
        
        // Function to update popup opacity values dynamically (currently disabled - using fixed values)
        function updatePopupOpacity() {
            // Opacity is now fixed at 1.0 in CSS, no dynamic updates needed
        }
        
        /* eslint-enable */
        
        // Format number based on current language
        function formatNumberDE(value, decimals) {
            if (value === null || value === undefined || isNaN(value)) {
                const lang = document.documentElement.lang || 'de';
                const isGerman = lang.startsWith('de');
                const decimalSep = isGerman ? ',' : '.';
                return '0' + (decimals > 0 ? decimalSep + '0'.repeat(decimals) : '');
            }
            const num = parseFloat(value);
            const fixed = num.toFixed(decimals || 2);
            const parts = fixed.split('.');
            const integerStr = parts[0];
            const decimalPart = parts[1] || '';
            
            // Get language from HTML lang attribute
            const lang = document.documentElement.lang || 'de';
            const isGerman = lang.startsWith('de');
            
            // Add thousands separators
            let integerWithSeparators = '';
            for (let i = 0; i < integerStr.length; i++) {
                if (i > 0 && (integerStr.length - i) % 3 === 0) {
                    integerWithSeparators += isGerman ? '.' : ',';
                }
                integerWithSeparators += integerStr[i];
            }
            
            // Add decimal separator
            if (decimalPart) {
                return integerWithSeparators + (isGerman ? ',' : '.') + decimalPart;
            }
            return integerWithSeparators;
        }
        
        // Update track visibility based on selected track IDs
        function updateTrackVisibility(visibleTrackIds) {
            console.log('updateTrackVisibility called with visibleTrackIds:', visibleTrackIds);
            console.log('tracks:', tracks, 'trackLayers:', trackLayers);
            
            if (!tracks || !Array.isArray(tracks)) {
                console.error('Tracks not available for updateTrackVisibility', tracks);
                return;
            }
            
            if (!trackLayers) {
                console.error('TrackLayers not available for updateTrackVisibility', trackLayers);
                return;
            }
            
            // Ensure visibleTrackIds is an array of numbers
            visibleTrackIds = visibleTrackIds || [];
            visibleTrackIds = visibleTrackIds.map(function(id) { return typeof id === 'string' ? parseInt(id) : id; }).filter(function(id) { return !isNaN(id); });
            
            console.log('Processing', tracks.length, 'tracks, visibleTrackIds:', visibleTrackIds);
            
            var tracksCreated = 0;
            var tracksRemoved = 0;
            
            tracks.forEach(function(t) {
                if (!t || !t.id) {
                    console.warn('Invalid track:', t);
                    return;
                }
                
                var trackId = typeof t.id === 'string' ? parseInt(t.id) : t.id;
                if (isNaN(trackId)) {
                    console.warn('Invalid track ID:', t.id);
                    return;
                }
                
                var shouldBeVisible = visibleTrackIds.includes(trackId);
                var isCurrentlyVisible = trackPolylineMap[trackId] !== undefined;
                
                console.log('Track', trackId, 'shouldBeVisible:', shouldBeVisible, 'isCurrentlyVisible:', isCurrentlyVisible);
                
                if (shouldBeVisible && !isCurrentlyVisible) {
                    // Create track polyline
                    if (t.points && Array.isArray(t.points) && t.points.length > 0) {
                        try {
                            console.log('Creating polyline for track', trackId, 'with', t.points.length, 'points');
                            var poly = L.polyline(t.points, {
                                color: '#007bff',
                                weight: 6,
                                opacity: 0.5
                            }).addTo(trackLayers);
                            
                            polylineLookup[trackId] = poly;
                            trackPolylineMap[trackId] = poly;
                            tracksCreated++;
                            console.log('Polyline created for track', trackId);
                            
                            // Create start and end markers
                            var startPoint = t.points[0];
                            var endPoint = t.points[t.points.length - 1];
                            
                            if (startPoint && Array.isArray(startPoint) && startPoint.length >= 2) {
                                var startIcon = L.divIcon({
                                    className: 'start-marker',
                                    html: '<div style="font-size: 30px; line-height: 1;">🚩</div>',
                                    iconSize: [30, 30],
                                    iconAnchor: [15, 30]
                                });
                                var startMarker = L.marker([startPoint[0], startPoint[1]], {
                                    icon: startIcon,
                                    title: '{% trans "Start" %}: ' + (t.name || '')
                                }).addTo(trackLayers);
                                startMarker.bindPopup('<strong>{% trans "Start" %}</strong><br>' + (t.name || ''));
                                
                                if (endPoint && Array.isArray(endPoint) && endPoint.length >= 2) {
                                    var endIcon = L.divIcon({
                                        className: 'end-marker',
                                        html: '<div style="font-size: 30px; line-height: 1;">🏁</div>',
                                        iconSize: [30, 30],
                                        iconAnchor: [15, 30]
                                    });
                                    var endMarker = L.marker([endPoint[0], endPoint[1]], {
                                        icon: endIcon,
                                        title: '{% trans "Ziel" %}: ' + (t.name || '')
                                    }).addTo(trackLayers);
                                    endMarker.bindPopup('<strong>{% trans "Ziel" %}</strong><br>' + (t.name || ''));
                                    
                                    // Store markers
                                    trackStartEndMarkersMap[trackId] = {
                                        start: startMarker,
                                        end: endMarker
                                    };
                                    console.log('Markers created for track', trackId);
                                }
                            }
                        } catch (e) {
                            console.error('Error creating track polyline for track', trackId, e, e.stack);
                        }
                    } else {
                        console.warn('Track', trackId, 'has no valid points:', t.points);
                    }
                } else if (!shouldBeVisible && isCurrentlyVisible) {
                    // Remove track polyline
                    if (trackPolylineMap[trackId]) {
                        try {
                            trackLayers.removeLayer(trackPolylineMap[trackId]);
                            tracksRemoved++;
                            console.log('Removed polyline for track', trackId);
                        } catch (e) {
                            console.error('Error removing track polyline', trackId, e);
                        }
                        delete trackPolylineMap[trackId];
                        delete polylineLookup[trackId];
                    }
                    
                    // Remove markers
                    if (trackStartEndMarkersMap[trackId]) {
                        try {
                            if (trackStartEndMarkersMap[trackId].start) {
                                trackLayers.removeLayer(trackStartEndMarkersMap[trackId].start);
                            }
                            if (trackStartEndMarkersMap[trackId].end) {
                                trackLayers.removeLayer(trackStartEndMarkersMap[trackId].end);
                            }
                            console.log('Removed markers for track', trackId);
                        } catch (e) {
                            console.error('Error removing track markers', trackId, e);
                        }
                        delete trackStartEndMarkersMap[trackId];
                    }
                }
            });
            
            console.log('updateTrackVisibility complete: created', tracksCreated, 'removed', tracksRemoved);
            
            // Update window.polylineLookup
            window.polylineLookup = polylineLookup;
        }
        
        // Initialize track display system - SIMPLE DIRECT APPROACH
        function initializeTracks() {
            console.log('initializeTracks called, tracks:', tracks);
            
            if (!tracks || !Array.isArray(tracks) || tracks.length === 0) {
                console.warn('No tracks available for initialization', tracks);
                return;
            }
            
            if (!map) {
                console.warn('Map not available for track initialization');
                return;
            }
            
            if (!trackLayers) {
                console.warn('TrackLayers not available');
                return;
            }
            
            console.log('Map (dashboard): initializeTracks() called');
            console.log('Map (dashboard): window.kioskTrackFilterIds:', typeof window.kioskTrackFilterIds !== 'undefined' ? window.kioskTrackFilterIds : 'undefined', 'isArray:', Array.isArray(window.kioskTrackFilterIds));
            
            // Determine which tracks should be visible based on URL parameters or kiosk filter
            var urlParams = new URLSearchParams(window.location.search);
            var urlTrackIds = urlParams.get('track_ids');
            var visibleTrackIds = [];
            
            // Check global kiosk track filter variable (set by kiosk playlist before scripts execute)
            // IMPORTANT: Check if it's defined (even if it's an empty array)
            var kioskTrackFilterIds = null;
            var kioskTrackFilterDefined = typeof window.kioskTrackFilterIds !== 'undefined';
            
            if (kioskTrackFilterDefined) {
                // Variable is defined - use it (even if it's an empty array or null)
                kioskTrackFilterIds = window.kioskTrackFilterIds;
                console.log('Map (dashboard): Found kioskTrackFilterIds (defined):', kioskTrackFilterIds, 'type:', Array.isArray(kioskTrackFilterIds) ? 'array' : typeof kioskTrackFilterIds, 'length:', Array.isArray(kioskTrackFilterIds) ? kioskTrackFilterIds.length : 'N/A');
            }
            
            // Also check if track filter is set in a data attribute (for kiosk context)
            if (!kioskTrackFilterDefined) {
                var sectionMap = document.getElementById('section-map');
                if (sectionMap) {
                    var trackFilterFromData = sectionMap.getAttribute('data-track-filter-ids');
                    console.log('Map (dashboard): Checking data-track-filter-ids attribute:', trackFilterFromData);
                    if (trackFilterFromData !== null && trackFilterFromData !== '') {
                        kioskTrackFilterIds = trackFilterFromData.split(',').map(function(id) {
                            return parseInt(id.trim());
                        }).filter(function(id) { return !isNaN(id); });
                        console.log('Map (dashboard): Using track filter from data attribute:', kioskTrackFilterIds);
                        kioskTrackFilterDefined = true; // Mark as defined so we use it
                    }
                }
            }
            
            // Priority: kiosk filter > data attribute > URL parameter > show all
            // In kiosk mode: if track_filter_ids is set (even if empty array), use it
            // Empty array means show no tracks, null/undefined means use URL or show all
            console.log('Map (dashboard): kioskTrackFilterDefined:', kioskTrackFilterDefined, 'kioskTrackFilterIds:', kioskTrackFilterIds);
            if (kioskTrackFilterDefined) {
                // Kiosk filter is explicitly set - use it (even if empty array or null)
                if (Array.isArray(kioskTrackFilterIds) && kioskTrackFilterIds.length > 0) {
                    visibleTrackIds = kioskTrackFilterIds;
                    console.log('Map (dashboard): Using kiosk track filter (non-empty):', visibleTrackIds);
                } else {
                    // track_filter_ids is explicitly set to empty array or null - show no tracks
                    visibleTrackIds = [];
                    console.log('Map (dashboard): Kiosk track filter is empty/null - showing NO tracks');
                }
            } else if (urlTrackIds === 'none') {
                visibleTrackIds = [];
                console.log('Map (dashboard): URL says no tracks (track_ids=none)');
            } else if (urlTrackIds && urlTrackIds !== 'none') {
                visibleTrackIds = urlTrackIds.split(',').map(function(id) { 
                    return parseInt(id.trim()); 
                }).filter(function(id) { return !isNaN(id); });
                console.log('Map (dashboard): Using URL track filter:', visibleTrackIds);
            } else {
                // No filter - show all tracks by default (only in non-kiosk mode)
                visibleTrackIds = tracks.map(function(t) { 
                    return typeof t.id === 'string' ? parseInt(t.id) : t.id; 
                }).filter(function(id) { return !isNaN(id); });
                console.log('Map (dashboard): No filter - showing all tracks:', visibleTrackIds);
            }
            
            console.log('Map (dashboard): Final visibleTrackIds:', visibleTrackIds);
            
            // Create and display tracks
            console.log('Calling updateTrackVisibility with:', visibleTrackIds);
            updateTrackVisibility(visibleTrackIds);
            
            // Make initializeTracks globally available for kiosk mode
            if (typeof window !== 'undefined') {
                window.initializeTracks = initializeTracks;
            }
            
            // Fit bounds on initial load
            if (visibleTrackIds.length > 0 && !map._initialBoundsSet) {
                var visibleBounds = [];
                visibleTrackIds.forEach(function(trackId) {
                    var track = tracks.find(function(t) { 
                        var tid = typeof t.id === 'string' ? parseInt(t.id) : t.id;
                        return tid === trackId; 
                    });
                    if (track && track.points && Array.isArray(track.points) && track.points.length > 0) {
                        try {
                            var bounds = L.latLngBounds(track.points);
                            visibleBounds.push(bounds);
                        } catch (e) {
                            console.error('Error creating bounds for track', trackId, e);
                        }
                    }
                });
                if (visibleBounds.length > 0) {
                    try {
                        var combinedBounds = visibleBounds[0];
                        for (var i = 1; i < visibleBounds.length; i++) {
                            combinedBounds.extend(visibleBounds[i]);
                        }
                        map.fitBounds(combinedBounds);
                        map._initialBoundsSet = true;
                        console.log('Map bounds fitted to tracks');
                    } catch (e) {
                        console.error('Error fitting bounds', e);
                    }
                }
            }
        }
        
        // Initialize tracks immediately - DIRECT SIMPLE APPROACH
        (function() {
            console.log('=== TRACK INITIALIZATION START ===');
            console.log('Map available:', !!map);
            console.log('Tracks available:', !!tracks);
            console.log('Tracks type:', typeof tracks);
            console.log('Tracks is array:', Array.isArray(tracks));
            if (tracks) {
                console.log('Tracks length:', tracks.length);
                if (tracks.length > 0) {
                    console.log('First track:', tracks[0]);
                }
            }
            console.log('TrackLayers available:', !!trackLayers);
            
            if (!tracks || !Array.isArray(tracks) || tracks.length === 0) {
                console.warn('No tracks available for initialization', tracks);
                return;
            }
            
            if (!map) {
                console.warn('Map not available for track initialization');
                return;
            }
            
            if (!trackLayers) {
                console.warn('TrackLayers not available');
                return;
            }
            
            // Determine which tracks should be visible based on URL parameters
            var urlParams = new URLSearchParams(window.location.search);
            var urlTrackIds = urlParams.get('track_ids');
            var visibleTrackIds = [];
            
            if (urlTrackIds === 'none') {
                visibleTrackIds = [];
                console.log('URL says no tracks should be visible');
            } else if (urlTrackIds && urlTrackIds !== 'none') {
                visibleTrackIds = urlTrackIds.split(',').map(function(id) { 
                    return parseInt(id.trim()); 
                }).filter(function(id) { return !isNaN(id); });
                console.log('URL specifies tracks:', visibleTrackIds);
            } else {
                visibleTrackIds = tracks.map(function(t) { 
                    return typeof t.id === 'string' ? parseInt(t.id) : t.id; 
                }).filter(function(id) { return !isNaN(id); });
                console.log('No URL filter, showing all tracks:', visibleTrackIds);
            }
            
            // Create and display tracks DIRECTLY
            console.log('Calling updateTrackVisibility with:', visibleTrackIds);
            updateTrackVisibility(visibleTrackIds);
            
            // Fit bounds on initial load
            if (visibleTrackIds.length > 0 && !map._initialBoundsSet) {
                var visibleBounds = [];
                visibleTrackIds.forEach(function(trackId) {
                    var track = tracks.find(function(t) { 
                        var tid = typeof t.id === 'string' ? parseInt(t.id) : t.id;
                        return tid === trackId; 
                    });
                    if (track && track.points && Array.isArray(track.points) && track.points.length > 0) {
                        try {
                            var bounds = L.latLngBounds(track.points);
                            visibleBounds.push(bounds);
                        } catch (e) {
                            console.error('Error creating bounds for track', trackId, e);
                        }
                    }
                });
                if (visibleBounds.length > 0) {
                    try {
                        var combinedBounds = visibleBounds[0];
                        for (var i = 1; i < visibleBounds.length; i++) {
                            combinedBounds.extend(visibleBounds[i]);
                        }
                        map.fitBounds(combinedBounds);
                        map._initialBoundsSet = true;
                        console.log('Map bounds fitted to tracks');
                    } catch (e) {
                        console.error('Error fitting bounds', e);
                    }
                }
            }
            
            console.log('=== TRACK INITIALIZATION COMPLETE ===');
        })();
        
        // Initialize selectors - sync checkboxes with "all" checkboxes
        function initializeSelectors() {
            // Initialize track selector
            var trackAllCheckbox = document.getElementById('track-all');
            var trackCheckboxes = document.querySelectorAll('.track-checkbox');
            var selectedTracks = Array.from(trackCheckboxes).filter(cb => cb.checked);
            
            // Check URL parameter to see if track_ids='none' is set
            var urlParams = new URLSearchParams(window.location.search);
            var urlTrackIds = urlParams.get('track_ids');
            
            // If track_ids='none' in URL, uncheck all checkboxes
            if (urlTrackIds === 'none') {
                if (trackAllCheckbox) {
                    trackAllCheckbox.checked = false;
                }
                trackCheckboxes.forEach(function(cb) {
                    cb.checked = false;
                });
            } else if (selectedTracks.length === 0 && (!trackAllCheckbox || !trackAllCheckbox.checked)) {
                // If no tracks are selected (neither "all" nor individual) and track_ids is not 'none',
                // check "all" and all individual track checkboxes
                if (trackAllCheckbox) {
                    trackAllCheckbox.checked = true;
                }
                trackCheckboxes.forEach(function(cb) {
                    cb.checked = true;
                });
            } else if (trackAllCheckbox && trackAllCheckbox.checked) {
                // If "all tracks" is checked, check all individual track checkboxes
                trackCheckboxes.forEach(function(cb) {
                    cb.checked = true;
                });
            }
            if (typeof updateTrackSelectorText === 'function') {
                updateTrackSelectorText();
            }
            
            // Legacy group selector removed - now using Layer Control
            // Groups are now managed via Layer Control toggle switches
            
            // If ranking view is active, load ranking content with current filter
            var rankingSection = document.getElementById('section-ranking');
            if (rankingSection && rankingSection.style.display !== 'none') {
                // Ranking view is active - trigger showRankingView to load content
                if (typeof showRankingView === 'function') {
                    // Don't change view state, just load content
                    var rankingContent = document.getElementById('ranking-content');
                    if (rankingContent && !rankingContent.dataset.loaded) {
                        // Build ranking URL with current group filter from Layer Control
                        var langPrefix = '';
                        var pathParts = window.location.pathname.split('/');
                        if (pathParts.length > 1 && pathParts[1].length === 2) {
                            langPrefix = '/' + pathParts[1] + '/';
                        }
                        var rankingUrl = langPrefix + 'ranking/';
                        
                        // Get current group selection from Layer Control
                        var groupAllCheckbox = document.getElementById('layer-group-all');
                        var groupCheckboxes = document.querySelectorAll('.layer-group-toggle:checked');
                        var selectedGroups = Array.from(groupCheckboxes).filter(cb => cb.value !== 'all').map(cb => cb.value);
                        var urlParams = new URLSearchParams();
                        var totalCheckboxes = document.querySelectorAll('.layer-group-toggle').length;
                        var allGroupsSelected = (groupAllCheckbox && groupAllCheckbox.checked) || 
                                               (totalCheckboxes > 0 && selectedGroups.length >= totalCheckboxes);
                        
                        if (allGroupsSelected) {
                            // All groups selected, no filter needed (backend shows all by default)
                        } else if (selectedGroups.length > 0) {
                            // Add selected group IDs
                            var groupIds = selectedGroups.map(cb => cb.value).join(',');
                            urlParams.set('group_id', groupIds);
                        } else {
                            // No groups selected - set to 'none'
                            urlParams.set('group_id', 'none');
                        }
                        
                        if (urlParams.toString()) {
                            rankingUrl += '?' + urlParams.toString();
                        }
                        
                        // Load ranking content
                        fetch(rankingUrl, {
                            method: 'GET',
                            headers: {
                                'Accept': 'text/html',
                                'X-Requested-With': 'XMLHttpRequest',
                                'HX-Request': 'true'
                            },
                            credentials: 'same-origin',
                            mode: 'same-origin'
                        })
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error('Network response was not ok');
                                }
                                return response.text();
                            })
                            .then(html => {
                                rankingContent.innerHTML = html;
                                if (window.htmx) {
                                    htmx.process(rankingContent);
                                }
                                rankingContent.dataset.loaded = 'true';
                            })
                            .catch(error => {
                                console.error('Error loading ranking page:', error);
                                rankingContent.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545;">Fehler beim Laden der Ranking-Seite. Bitte versuchen Sie es erneut.</div>';
                            });
                    }
                }
            }
        }
        
        // Run initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeSelectors);
        } else {
            initializeSelectors();
        }

        // Display devices as markers on the map
        devices.forEach(function(d) {
            if (d.lat && d.lon) {
                var deviceIcon = L.divIcon({
                    className: 'device-marker',
                    html: '<div style="background: #28a745; border: 3px solid #155724; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 18px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">🚲</div>',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });
                var marker = L.marker([d.lat, d.lon], {icon: deviceIcon}).addTo(deviceMarkers);
                var popupContent = '<strong>{% trans "Gerät" %}: ' + d.name + '</strong><br>{% trans "Gesamt" %}: ' + formatNumberDE(d.distance_total, 2) + ' km';
                if (d.last_active) {
                    popupContent += '<br>{% trans "Zuletzt aktiv" %}: ' + new Date(d.last_active).toLocaleString('de-DE');
                }
                marker.bindPopup(popupContent);
            }
        });

        // Store milestone markers with ID for later update
        var milestoneMarkerMap = {};

        // Display milestones as markers on the map
        // Get visible track IDs from kiosk filter, data attribute, or URL
        var visibleTrackIdsForMilestones = [];
        if (typeof window.kioskTrackFilterIds !== 'undefined') {
            if (Array.isArray(window.kioskTrackFilterIds) && window.kioskTrackFilterIds.length > 0) {
                visibleTrackIdsForMilestones = window.kioskTrackFilterIds;
            } else {
                visibleTrackIdsForMilestones = [];
            }
        } else {
            // Check data attribute
            var sectionMap = document.getElementById('section-map');
            if (sectionMap) {
                var trackFilterFromData = sectionMap.getAttribute('data-track-filter-ids');
                if (trackFilterFromData !== null && trackFilterFromData !== '') {
                    visibleTrackIdsForMilestones = trackFilterFromData.split(',').map(function(id) {
                        return parseInt(id.trim());
                    }).filter(function(id) { return !isNaN(id); });
                }
            }
            // If still empty, check URL
            if (visibleTrackIdsForMilestones.length === 0) {
                var urlParams = new URLSearchParams(window.location.search);
                var urlTrackIds = urlParams.get('track_ids');
                if (urlTrackIds === 'none') {
                    visibleTrackIdsForMilestones = [];
                } else if (urlTrackIds && urlTrackIds !== 'none') {
                    visibleTrackIdsForMilestones = urlTrackIds.split(',').map(function(id) { 
                        return parseInt(id.trim()); 
                    }).filter(function(id) { return !isNaN(id); });
                } else {
                    // No filter - show all tracks
                    if (typeof tracks !== 'undefined' && Array.isArray(tracks)) {
                        visibleTrackIdsForMilestones = tracks.map(function(t) { 
                            return typeof t.id === 'string' ? parseInt(t.id) : t.id; 
                        }).filter(function(id) { return !isNaN(id); });
                    }
                }
            }
        }
        console.log('Map (dashboard): Filtering initial milestones by visible tracks:', visibleTrackIdsForMilestones);
        
        milestones.forEach(function(m) {
            if (m.lat && m.lon) {
                // Check if this milestone belongs to a visible track
                var milestoneTrackId = m.track_id ? (typeof m.track_id === 'string' ? parseInt(m.track_id) : m.track_id) : null;
                
                // If no tracks are visible, hide ALL milestones (even those without track_id)
                if (visibleTrackIdsForMilestones.length === 0) {
                    // No tracks visible - hide all milestones
                    console.log('Map (dashboard): Skipping milestone', m.id || m.name, '- no tracks visible (initial load)');
                    return; // Skip this milestone
                }
                
                // If tracks are visible, check if this milestone belongs to a visible track
                if (milestoneTrackId && !visibleTrackIdsForMilestones.includes(milestoneTrackId)) {
                    // Milestone belongs to a hidden track - skip it
                    console.log('Map (dashboard): Skipping milestone', m.id || m.name, 'for hidden track', milestoneTrackId, '(initial load)');
                    return; // Skip this milestone
                }
                // Check if this is the target/end point
                var isTarget = false;
                if (m.name && (m.name.toLowerCase().includes('ziel') || m.name.toLowerCase().includes('target'))) {
                    isTarget = true;
                } else if (m.track_total_length_km) {
                    // Check if milestone is at or near the end of the track (within 100m)
                    var distanceToEnd = Math.abs(m.track_total_length_km - (m.km || 0));
                    if (distanceToEnd < 0.1) { // Within 100m of track end
                        isTarget = true;
                    }
                }
                
                // Different colors for reached vs unreached milestones
                var isReached = m.is_reached || false;
                var bgColor, borderColor, iconEmoji;
                
                if (isTarget) {
                    // Target point: Green with finish flag
                    bgColor = isReached ? '#28a745' : '#20c997';
                    borderColor = isReached ? '#155724' : '#17a2b8';
                    iconEmoji = '🏁';
                } else {
                    bgColor = isReached ? '#28a745' : '#ffd700';  // Green for reached, gold for unreached
                    borderColor = isReached ? '#1e7e34' : '#ff8c00';  // Dark green for reached, orange for unreached
                    iconEmoji = isReached ? '✅' : '🏆';
                }
                
                var milestoneIcon = L.divIcon({
                    className: 'milestone-marker',
                    html: '<div style="background: ' + bgColor + '; border: 3px solid ' + borderColor + '; border-radius: ' + (isTarget ? '8px' : '50%') + '; width: ' + (isTarget ? '40px' : '30px') + '; height: ' + (isTarget ? '40px' : '30px') + '; display: flex; align-items: center; justify-content: center; font-size: ' + (isTarget ? '24px' : '18px') + '; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transform: ' + (isTarget ? 'rotate(-5deg)' : 'none') + ';">' + iconEmoji + '</div>',
                    iconSize: [isTarget ? 40 : 30, isTarget ? 40 : 30],
                    iconAnchor: [isTarget ? 20 : 15, isTarget ? 20 : 15]
                });
                var marker = L.marker([m.lat, m.lon], {icon: milestoneIcon}).addTo(milestoneMarkers);
                var popupContent = '<div class="milestone-header">🏆 {% trans "Meilenstein" %}</div>';
                popupContent += '<div class="milestone-name">' + (isTarget ? '🏁 ' + m.name : m.name) + '</div>';
                popupContent += '<div class="milestone-distance">' + formatNumberDE(m.km, 2) + ' km</div>';
                if (isTarget) {
                    popupContent += '<div class="milestone-target-reached">{% trans "Ziel erreicht!" %}</div>';
                } else {
                    if (m.text) {
                        popupContent += '<div class="milestone-reward-text">' + m.text + '</div>';
                    }
                }
                if (isReached && m.winner_group_name) {
                    popupContent += '<div class="milestone-group-label">{% trans "Erreicht von" %}</div>';
                    var groupDisplay = m.winner_group_name;
                    if (m.winner_parent_group_name) {
                        groupDisplay += '<br><span style="font-size: 0.85em; opacity: 0.9;">(' + m.winner_parent_group_name + ')</span>';
                    }
                    popupContent += '<div class="milestone-group-name">' + groupDisplay + '</div>';
                    if (m.reached_at) {
                        var reachedDate = new Date(m.reached_at);
                        popupContent += '<div class="milestone-date">{% trans "Erreicht am" %}: ' + reachedDate.toLocaleString('de-DE') + '</div>';
                    }
                }
                // Add details button if description or external_link exists
                if ((m.description && m.description.trim()) || (m.external_link && m.external_link.trim())) {
                    // Find track name from tracks array
                    var trackName = '';
                    if (m.track_id && typeof tracks !== 'undefined') {
                        var track = tracks.find(function(t) {
                            var tid = typeof t.id === 'string' ? parseInt(t.id) : t.id;
                            var mid = typeof m.track_id === 'string' ? parseInt(m.track_id) : m.track_id;
                            return tid === mid;
                        });
                        if (track && track.name) {
                            trackName = track.name;
                        }
                    }
                    popupContent += '<div class="milestone-details-btn-container">';
                    popupContent += '<button class="milestone-details-btn" onclick="openMilestoneDetailsFromPopup(' + m.id + ', \'' + (m.name || '').replace(/'/g, "\\'") + '\', \'' + (m.description || '').replace(/'/g, "\\'").replace(/\n/g, '\\n') + '\', \'' + (m.external_link || '') + '\', \'' + (m.text || '') + '\', \'' + (m.winner_group_name || '') + '\', \'' + (m.winner_parent_group_name || '') + '\', \'' + (m.reached_at || '') + '\', ' + m.km + ', \'' + trackName.replace(/'/g, "\\'") + '\')">';
                    popupContent += 'ℹ️ {% trans "Details anzeigen" %}';
                    popupContent += '</button>';
                    popupContent += '</div>';
                }
                marker.bindPopup(popupContent);
                // Store marker with name as key (if ID not available)
                if (m.id) {
                    milestoneMarkerMap[m.id] = marker;
                } else {
                    milestoneMarkerMap[m.name] = marker;
                }
            }
        });

        function calculatePosition(g) {
            // Use window.map if available (for kiosk mode), otherwise use local map
            var mapInstance = window.map || map;
            var lookup = window.polylineLookup || polylineLookup;
            if (lookup[g.track_id]) {
                var poly = lookup[g.track_id], latlngs = poly.getLatLngs(), total = 0;
                for (var i = 0; i < latlngs.length - 1; i++) total += latlngs[i].distanceTo(latlngs[i+1]);
                var ratio = Math.max(0, Math.min(1, (g.km * 1000) / total));
                return L.GeometryUtil.interpolateOnLine(mapInstance, poly, ratio).latLng;
            }
            return null;
        }
        // Make calculatePosition available globally for kiosk mode
        window.calculatePosition = calculatePosition;

        // Helper function to create offset icon
        function createAvatarIcon(g, xOffset, yOffset, rank) {
            // Use km for display (current_travel_distance only, not historical)
            // This ensures that after restart, avatars show 0 km at the start point
            var displayKm = g.km || 0;
            // Use display_name (short_name if available) or fall back to name
            // Escape HTML to prevent XSS and ensure proper display
            var groupName = ((g.display_name || g.name) || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            // Apply both horizontal and vertical offsets
            var transform = '';
            if (xOffset !== 0 || yOffset !== 0) {
                transform = `transform: translate(${xOffset}px, -${yOffset}px);`;
            }
            // Add rank display if provided
            var rankDisplay = '';
            if (rank !== undefined && rank !== null && rank > 0) {
                var rankEmoji = '';
                if (rank === 1) rankEmoji = '🥇';
                else if (rank === 2) rankEmoji = '🥈';
                else if (rank === 3) rankEmoji = '🥉';
                rankDisplay = `<div style="font-size: 16px; font-weight: bold; margin-bottom: 2px;">${rankEmoji} ${rank}.</div>`;
            }
            
            // Check if group has reached goal and has top contributor leaf group
            var topContributorDisplay = '';
            var travelDurationDisplay = '';
            var trackTotalLength = g.track_total_length_km || 0;
            var isAtFinish = trackTotalLength > 0 && g.km >= trackTotalLength;
            if (isAtFinish && g.top_contributor_leaf_group) {
                var leafGroup = g.top_contributor_leaf_group;
                var leafGroupName = ((leafGroup.display_name || leafGroup.name) || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                var leafContribution = formatNumberDE(leafGroup.contribution_km || 0, 2);
                topContributorDisplay = `<div style="margin-top: 4px; padding-top: 4px; border-top: 1px solid #ddd; font-size: 10px; color: #28a745; font-weight: bold;">⭐ ${leafGroupName}<br>${leafContribution} km</div>`;
            }
            
            // Display travel duration if goal is reached
            if (isAtFinish && g.travel_duration_seconds !== undefined && g.travel_duration_seconds !== null) {
                var totalSeconds = g.travel_duration_seconds;
                var days = Math.floor(totalSeconds / 86400);
                var hours = Math.floor((totalSeconds % 86400) / 3600);
                var minutes = Math.floor((totalSeconds % 3600) / 60);
                var seconds = totalSeconds % 60;
                
                // Format: Tage:Stunden:Minuten:Sekunden
                var durationText = '';
                if (days > 0) {
                    durationText = days + ':' + String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
                } else {
                    durationText = String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
                }
                travelDurationDisplay = `<div style="margin-top: 4px; padding-top: 4px; border-top: 1px solid #ddd; font-size: 10px; color: #007bff; font-weight: bold;">⏱️ ${durationText}</div>`;
            }
            
            return L.divIcon({
                html: `
                    <div class="group-icon-container" style="${transform}">
                        <img src="${g.logo}" class="group-icon-img" onerror="this.src='/static/map/images/default_group.png'">
                        <div class="group-icon-label" style="color: #333; background: rgba(255,255,255,0.95); padding: 2px 6px; border-radius: 4px; font-size: 11px; font-weight: bold; border: 1px solid #ccc; white-space: normal; word-wrap: break-word; overflow-wrap: break-word; box-shadow: 0 1px 3px rgba(0,0,0,0.2); margin-top: 2px; display: inline-block; line-height: 1.2; text-align: center; max-width: 100px;">${rankDisplay}${groupName}<br>${formatNumberDE(displayKm, 2)} km${travelDurationDisplay}${topContributorDisplay}</div>
                    </div>`,
                className: '',
                iconSize: [50, 65],
                iconAnchor: [25, 50]
            });
        }

        // ============================================
        // Champions Overlay (Winners Podium) - Define early
        // ============================================
        
        // Translation for "Platz" (Position/Rank)
        var TRANSLATION_PLATZ = '{% trans "Platz" %}';
        
        var championsOverlayExpanded = false;
        var championsOverlayVisible = true;
        
        // Update Champions Overlay with top 3 finishers
        function updateChampionsOverlay(allFinishAvatars) {
            var overlay = document.getElementById('champions-overlay');
            var miniPodium = document.getElementById('mini-podium');
            var heroCards = document.getElementById('hero-cards');
            
            if (!overlay || !miniPodium || !heroCards) return;
            
            // Ensure allFinishAvatars is an array
            if (!allFinishAvatars || !Array.isArray(allFinishAvatars)) {
                allFinishAvatars = [];
            }
            
            // Check if we're in map view (not ranking view)
            var mapSection = document.getElementById('section-map');
            var rankingSection = document.getElementById('section-ranking');
            var isMapView = mapSection && !mapSection.classList.contains('hidden');
            var isRankingView = rankingSection && rankingSection.classList.contains('active');
            
            // Get top 3 finishers
            var top3 = allFinishAvatars.slice(0, 3);
            
            // Get showBoxes state (only show if exactly one track is active)
            var showBoxes = window.showBoxes !== undefined ? window.showBoxes : false;
            
            // Show/hide overlay based on:
            // 1. Toggle state
            // 2. Availability of finishers
            // 3. Map view (not ranking view)
            // 4. Exactly one track is active
            var winnersToggle = document.getElementById('layer-winners-toggle');
            var shouldShow = championsOverlayVisible && 
                           (winnersToggle ? winnersToggle.checked : true) && 
                           top3.length > 0 &&
                           isMapView &&
                           !isRankingView &&
                           showBoxes;
            
            if (shouldShow) {
                overlay.classList.remove('hidden');
                
                // Clear existing content
                miniPodium.innerHTML = '';
                heroCards.innerHTML = '';
                
                // Create mini podium items
                top3.forEach(function(avatar, index) {
                    var rank = index + 1;
                    var medal = rank === 1 ? '🥇' : rank === 2 ? '🥈' : '🥉';
                    
                    // Mini Podium Item
                    var miniItem = document.createElement('div');
                    miniItem.className = 'mini-podium-item';
                    miniItem.setAttribute('data-rank', rank);
                    
                    var miniAvatar = document.createElement('img');
                    miniAvatar.className = 'mini-podium-avatar';
                    miniAvatar.src = avatar.logo || '/static/map/images/default_group.png';
                    miniAvatar.onerror = function() { this.src = '/static/map/images/default_group.png'; };
                    miniAvatar.alt = avatar.name;
                    
                    var miniRank = document.createElement('div');
                    miniRank.className = 'mini-podium-rank';
                    miniRank.textContent = medal;
                    
                    miniItem.appendChild(miniAvatar);
                    miniItem.appendChild(miniRank);
                    miniPodium.appendChild(miniItem);
                    
                    // Hero Card
                    var heroCard = document.createElement('div');
                    heroCard.className = 'hero-card';
                    heroCard.setAttribute('data-rank', rank);
                    
                    var heroAvatar = document.createElement('img');
                    heroAvatar.className = 'hero-card-avatar';
                    heroAvatar.src = avatar.logo || '/static/map/images/default_group.png';
                    heroAvatar.onerror = function() { this.src = '/static/map/images/default_group.png'; };
                    heroAvatar.alt = avatar.name;
                    
                    var heroContent = document.createElement('div');
                    heroContent.className = 'hero-card-content';
                    
                    var heroRank = document.createElement('div');
                    heroRank.className = 'hero-card-rank';
                    heroRank.textContent = medal + ' ' + TRANSLATION_PLATZ + ' ' + rank;
                    
                    var heroName = document.createElement('div');
                    heroName.className = 'hero-card-name';
                    heroName.textContent = avatar.name;
                    
                    var heroDetails = document.createElement('div');
                    heroDetails.className = 'hero-card-details';
                    
                    // Travel time if available
                    if (avatar.travel_duration_seconds !== undefined && avatar.travel_duration_seconds !== null) {
                        var travelTimeDiv = document.createElement('div');
                        travelTimeDiv.className = 'hero-card-travel-time';
                        var days = Math.floor(avatar.travel_duration_seconds / 86400);
                        var hours = Math.floor((avatar.travel_duration_seconds % 86400) / 3600);
                        var minutes = Math.floor((avatar.travel_duration_seconds % 3600) / 60);
                        var seconds = Math.floor(avatar.travel_duration_seconds % 60);
                        var timeText = '';
                        if (days > 0) {
                            timeText = days + 'd ' + hours + 'h ' + minutes + 'm ' + seconds + 's';
                        } else if (hours > 0) {
                            timeText = hours + 'h ' + minutes + 'm ' + seconds + 's';
                        } else if (minutes > 0) {
                            timeText = minutes + 'm ' + seconds + 's';
                        } else {
                            timeText = seconds + 's';
                        }
                        travelTimeDiv.innerHTML = '⏱️ ' + timeText;
                        heroDetails.appendChild(travelTimeDiv);
                    }
                    
                    // Top contributor leaf group if available
                    if (avatar.top_contributor_leaf_group) {
                        var topContributorDiv = document.createElement('div');
                        topContributorDiv.className = 'hero-card-top-contributor';
                        var leafGroup = avatar.top_contributor_leaf_group;
                        var displayName = leafGroup.display_name || leafGroup.name;
                        var contributionKm = formatNumberDE(leafGroup.contribution_km || 0, 2);
                        topContributorDiv.innerHTML = '🏆 ' + displayName + ' (' + contributionKm + ' km)';
                        heroDetails.appendChild(topContributorDiv);
                    }
                    
                    // MVP class if available
                    if (avatar.mvp_class) {
                        var mvpDiv = document.createElement('div');
                        mvpDiv.className = 'hero-card-mvp';
                        mvpDiv.textContent = '⭐ ' + avatar.mvp_class;
                        heroDetails.appendChild(mvpDiv);
                    }
                    
                    heroContent.appendChild(heroRank);
                    heroContent.appendChild(heroName);
                    heroContent.appendChild(heroDetails);
                    
                    heroCard.appendChild(heroAvatar);
                    heroCard.appendChild(heroContent);
                    heroCards.appendChild(heroCard);
                });
                
                // Add expand button to mini podium if not already present
                if (!miniPodium.querySelector('.mini-podium-expand-btn')) {
                    var expandBtn = document.createElement('button');
                    expandBtn.className = 'mini-podium-expand-btn';
                    expandBtn.textContent = '{% trans "Details" %}';
                    expandBtn.onclick = expandChampionsOverlay;
                    miniPodium.appendChild(expandBtn);
                }
                
                // Add collapse button to hero cards
                var collapseBtn = document.createElement('button');
                collapseBtn.className = 'hero-cards-collapse-btn';
                collapseBtn.textContent = '{% trans "Weniger anzeigen" %}';
                collapseBtn.onclick = collapseChampionsOverlay;
                heroCards.appendChild(collapseBtn);
                
                // Check for active cyclist overlap and apply ghost mode
                checkChampionsOverlayOverlap();
            } else {
                overlay.classList.add('hidden');
            }
        }
        
        // Expand Champions Overlay to show Hero Cards
        function expandChampionsOverlay() {
            var miniPodium = document.getElementById('mini-podium');
            var heroCards = document.getElementById('hero-cards');
            
            if (miniPodium && heroCards) {
                miniPodium.style.display = 'none';
                heroCards.classList.add('expanded');
                championsOverlayExpanded = true;
            }
        }
        
        // Collapse Champions Overlay to show Mini Podium
        function collapseChampionsOverlay() {
            var miniPodium = document.getElementById('mini-podium');
            var heroCards = document.getElementById('hero-cards');
            
            if (miniPodium && heroCards) {
                heroCards.classList.remove('expanded');
                miniPodium.style.display = 'flex';
                championsOverlayExpanded = false;
            }
        }
        
        // Check if active cyclist icons overlap with Champions Overlay area
        function checkChampionsOverlayOverlap() {
            var overlay = document.getElementById('champions-overlay');
            if (!overlay || overlay.classList.contains('hidden')) return;
            
            var overlayRect = overlay.getBoundingClientRect();
            var hasOverlap = false;
            
            // Get map instance
            var mapInstance = window.map || map;
            
            // Check all active cyclist markers
            if (window.avatarMarkers && mapInstance) {
                Object.keys(window.avatarMarkers).forEach(function(groupName) {
                    var marker = window.avatarMarkers[groupName];
                    if (!marker) return;
                    
                    var latlng = marker.getLatLng();
                    var point = mapInstance.latLngToContainerPoint(latlng);
                    
                    // Check if marker point is within overlay area (with some padding)
                    var padding = 100; // Extra padding to account for icon size
                    if (point.x >= overlayRect.left - padding &&
                        point.x <= overlayRect.right + padding &&
                        point.y >= overlayRect.top - padding &&
                        point.y <= overlayRect.bottom + padding) {
                        hasOverlap = true;
                    }
                });
            }
            
            // Apply ghost mode if overlap detected
            if (hasOverlap) {
                overlay.classList.add('ghost-mode');
            } else {
                overlay.classList.remove('ghost-mode');
            }
        }
        
        // Handle Winners Toggle Change
        function handleWinnersToggleChange(toggle) {
            championsOverlayVisible = toggle.checked;
            var overlay = document.getElementById('champions-overlay');
            
            if (overlay) {
                if (championsOverlayVisible) {
                    overlay.classList.remove('hidden');
                    // Refresh overlay with current finishers
                    if (window.allFinishAvatars) {
                        updateChampionsOverlay(window.allFinishAvatars);
                    }
                } else {
                    overlay.classList.add('hidden');
                }
            }
        }
        
        // Monitor map movements and marker updates to check for overlap
        // Register event listeners after map is initialized
        function registerChampionsOverlayListeners() {
            var mapInstance = window.map || map;
            if (mapInstance) {
                mapInstance.on('moveend', checkChampionsOverlayOverlap);
                mapInstance.on('zoomend', checkChampionsOverlayOverlap);
            }
        }
        
        // Register listeners when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', registerChampionsOverlayListeners);
        } else {
            registerChampionsOverlayListeners();
        }
        
        // Check overlap periodically (every 2 seconds) as markers move
        setInterval(checkChampionsOverlayOverlap, 2000);
        
        // ============================================
        // Avatar Refresh Function
        // ============================================
        
        function refreshAvatars(data) {
            if (!data || !data.avatars) {
                data = { avatars: data || [] };
            }
            var avatars = data.avatars || data;
            
            // Use window.map if available (for kiosk mode), otherwise use local map
            var mapInstance = window.map || map;
            // Use window.avatarMarkers if available (for kiosk mode), otherwise use local avatarMarkers
            var markers = window.avatarMarkers || avatarMarkers;
            // Use window.calculatePosition if available (for kiosk mode), otherwise use local calculatePosition
            var calcPos = window.calculatePosition || calculatePosition;
            var finishTimes = window.finishTimes || {};

            console.log('refreshAvatars called with', avatars.length, 'avatars, map:', mapInstance, 'markers:', markers);
            
            // Initialize finishTimes for each track if not exists
            avatars.forEach(function(g) {
                if (!finishTimes[g.track_id]) {
                    finishTimes[g.track_id] = {};
                }
            });

            // Group avatars by track_id
            var avatarsByTrack = {};
            
            avatars.forEach(function(g) {
                if (!avatarsByTrack[g.track_id]) {
                    avatarsByTrack[g.track_id] = [];
                }
                avatarsByTrack[g.track_id].push(g);
            });
            
            // Check if tracks are active (not filtered out)
            var urlParams = new URLSearchParams(window.location.search);
            var urlTrackIds = urlParams.get('track_ids');
            var tracksAreActive = true; // Default: tracks are active
            var activeTrackCount = 0; // Count of active tracks
            
            if (urlTrackIds === 'none') {
                // Explicitly set to show no tracks
                tracksAreActive = false;
                activeTrackCount = 0;
            } else if (urlTrackIds && urlTrackIds !== 'none') {
                // Specific tracks selected - check if any are active
                var activeTrackIds = urlTrackIds.split(',').map(function(id) { return parseInt(id.trim()); });
                // Check if tracks variable has any active tracks
                var tracks = window.tracks || [];
                var activeTracks = tracks.filter(function(t) {
                    return activeTrackIds.includes(t.id);
                });
                tracksAreActive = activeTracks.length > 0;
                activeTrackCount = activeTracks.length;
            } else {
                // No track_ids in URL - check if tracks variable has any tracks
                var tracks = window.tracks || [];
                tracksAreActive = tracks.length > 0;
                activeTrackCount = tracks.length;
            }
            
            // Only show Champions Overlay if exactly one track is active
            var showBoxes = tracksAreActive && activeTrackCount === 1;
            
            // Initialize allFinishAvatars - always collect finish avatars from active tracks
            var allFinishAvatars = [];
            
            // Determine which tracks are active
            var activeTrackIds = [];
            if (urlTrackIds && urlTrackIds !== 'none') {
                activeTrackIds = urlTrackIds.split(',').map(function(id) { return parseInt(id.trim()); });
            } else if (!urlTrackIds || urlTrackIds === 'none') {
                // No active tracks - don't collect any finish avatars
                activeTrackIds = [];
            }
            
            // Always collect finish avatars from ACTIVE tracks only
            // This ensures Champions Overlay can be updated when new groups reach the finish
            // But only for tracks that are currently active
            Object.keys(avatarsByTrack).forEach(function(trackId) {
                var trackIdInt = parseInt(trackId);
                // Only collect from active tracks
                if (activeTrackIds.length === 0 || activeTrackIds.includes(trackIdInt)) {
                    var finishAvatars = avatarsByTrack[trackId].filter(function(g) {
                        var trackTotalLength = g.track_total_length_km || 0;
                        return trackTotalLength > 0 && g.km >= trackTotalLength;
                    });
                    
                    if (finishAvatars.length > 0) {
                        // IMPORTANT: Don't overwrite goal_reached_at from backend with client-side time
                        finishAvatars.forEach(function(avatar) {
                            if (!finishTimes[trackId]) {
                                finishTimes[trackId] = {};
                            }
                            if (!avatar.goal_reached_at && !finishTimes[trackId][avatar.name]) {
                                finishTimes[trackId][avatar.name] = Date.now();
                            }
                        });
                        
                        allFinishAvatars = allFinishAvatars.concat(finishAvatars);
                    }
                }
            });
            
            // Sort all finish avatars by goal_reached_at (earlier time = better rank)
            if (allFinishAvatars.length > 0) {
                allFinishAvatars.sort(function(a, b) {
                    var timeA = null;
                    var timeB = null;
                    
                    if (a.goal_reached_at) {
                        timeA = new Date(a.goal_reached_at).getTime();
                    } else {
                        var trackIdA = a.track_id;
                        timeA = (finishTimes[trackIdA] && finishTimes[trackIdA][a.name]) || Infinity;
                    }
                    
                    if (b.goal_reached_at) {
                        timeB = new Date(b.goal_reached_at).getTime();
                    } else {
                        var trackIdB = b.track_id;
                        timeB = (finishTimes[trackIdB] && finishTimes[trackIdB][b.name]) || Infinity;
                    }
                    
                    if (a.goal_reached_at && b.goal_reached_at) {
                        return timeA - timeB;
                    } else if (a.goal_reached_at && !b.goal_reached_at) {
                        return -1;
                    } else if (!a.goal_reached_at && b.goal_reached_at) {
                        return 1;
                    } else {
                        return timeA - timeB;
                    }
                });
                
                // Assign ranks
                allFinishAvatars.forEach(function(avatar, index) {
                    avatar.finishRank = index + 1;
                });
            }
            
            // Store globally for Champions Overlay
            window.allFinishAvatars = allFinishAvatars;
            window.showBoxes = showBoxes;
            
            // Update Champions Overlay immediately when finish avatars are collected
            updateChampionsOverlay(allFinishAvatars);

            avatars.forEach(function(g) {
                // Skip avatars that have reached the finish - they should not be displayed on the map
                var trackTotalLength = g.track_total_length_km || 0;
                var isAtFinish = trackTotalLength > 0 && g.km >= trackTotalLength;
                
                if (isAtFinish) {
                    // Remove marker if it exists
                    if (markers[g.name]) {
                        mapInstance.removeLayer(markers[g.name]);
                        delete markers[g.name];
                    }
                    return; // Skip this avatar - don't display it
                }
                
                var pos = calcPos(g);
                if (!pos) {
                    console.warn('No position calculated for group:', g.name, 'track_id:', g.track_id);
                    return;
                }

                // Calculate offset based on offset_index and km
                var xOffset = 0;
                var yOffset = 0;
                var rank = null;
                
                // At start (0 km): arrange avatars on a virtual line outside the track
                if (g.km === 0 || (g.km !== undefined && Math.abs(g.km) < 0.01)) {
                    // At start: arrange avatars on a virtual line perpendicular to the track start
                    // Get all start avatars for this track
                    var trackStartAvatars = avatarsByTrack[g.track_id] ? avatarsByTrack[g.track_id].filter(function(avatar) {
                        return avatar.km === 0 || (avatar.km !== undefined && Math.abs(avatar.km) < 0.01);
                    }) : [];
                    
                    // Sort by offset_index to ensure consistent ordering
                    trackStartAvatars.sort(function(a, b) {
                        return (a.offset_index || 0) - (b.offset_index || 0);
                    });
                    
                    // Find index of current avatar
                    var avatarIndex = trackStartAvatars.findIndex(function(avatar) {
                        return avatar.name === g.name;
                    });
                    
                    if (avatarIndex >= 0 && pos) {
                        // Calculate a position perpendicular to the track start
                        // Get the first segment of the track to determine direction
                        var lookup = window.polylineLookup || polylineLookup;
                        var trackPolyline = lookup[g.track_id];
                        
                        if (trackPolyline && trackPolyline.getLatLngs && trackPolyline.getLatLngs().length > 1) {
                            var latlngs = trackPolyline.getLatLngs();
                            var startPoint = latlngs[0];
                            var secondPoint = latlngs[1];
                            
                            // Calculate direction vector from start to second point
                            var dx = secondPoint.lng - startPoint.lng;
                            var dy = secondPoint.lat - startPoint.lat;
                            var length = Math.sqrt(dx * dx + dy * dy);
                            
                            if (length > 0) {
                                // Normalize direction vector
                                dx = dx / length;
                                dy = dy / length;
                                
                                // Perpendicular vector (rotate 90 degrees counterclockwise)
                                var perpX = -dy;
                                var perpY = dx;
                                
                                // Offset distance from track (in degrees, approximately 0.001 = ~100m)
                                var offsetDistance = 0.001;
                                
                                // Spacing between avatars along the perpendicular line (in degrees)
                                var avatarSpacing = 0.0003; // Approximately 30m between avatars
                                
                                // Calculate position offset
                                var offsetIndex = avatarIndex - (trackStartAvatars.length - 1) / 2;
                                var offsetLng = perpX * (offsetDistance + offsetIndex * avatarSpacing);
                                var offsetLat = perpY * (offsetDistance + offsetIndex * avatarSpacing);
                                
                                // Apply offset to start position
                                pos = L.latLng(
                                    startPoint.lat + offsetLat,
                                    startPoint.lng + offsetLng
                                );
                            }
                        }
                    }
                    
                    xOffset = 0;
                    yOffset = 0;
                } else {
                    // After start: vertical offset (stacked)
                    xOffset = 0;
                    yOffset = (g.offset_index || 0) * 20; // 20px vertical spacing
                }

                if (markers[g.name]) {
                    markers[g.name].setLatLng(pos);
                    // Also update the icon if offset or KM have changed
                    markers[g.name].setIcon(createAvatarIcon(g, xOffset, yOffset, rank));
                } else {
                    console.log('Creating new marker for group:', g.name, 'at position:', pos);
                    markers[g.name] = L.marker(pos, {
                        icon: createAvatarIcon(g, xOffset, yOffset, rank),
                        zIndexOffset: 5000 // Ensure active cyclist avatars are above Champions Overlay (z-index 4000)
                    }).addTo(mapInstance);
                }
            });
            
            // Update window references
            window.avatarMarkers = markers;
            window.finishTimes = finishTimes;
            
            // Store globally for Champions Overlay (already set in if/else blocks above)
            // Ensure it's set even if not set in the blocks above
            if (window.allFinishAvatars === undefined) {
                window.allFinishAvatars = allFinishAvatars;
            }
            if (window.showBoxes === undefined) {
                window.showBoxes = showBoxes;
            }
            
            // Update Champions Overlay with top 3 finishers (already called in if/else blocks above)
            // Call again to ensure it's updated with the latest state
            updateChampionsOverlay(window.allFinishAvatars);
        }
        
        // Make refreshAvatars available globally for kiosk mode
        window.refreshAvatars = refreshAvatars;

        // Initial call
        refreshAvatars({{ group_avatars_json|safe }});

            // Automatic icon update
            function updateMapIcons() {
                var url = "{% url 'map:get_group_avatars' %}";
            {% if group_id %}
            url += "?group_id={{ group_id|urlencode }}";
            {% elif group_name %}
            url += "?group_name={{ group_name|urlencode }}";
            {% endif %}
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        refreshAvatars(data);
                    })
                    .catch(error => {
                        console.error('{% trans "Fehler beim Laden der Avatar-Daten" %}:', error);
                    });
        }
        // Make updateMapIcons available globally for kiosk mode
        window.updateMapIcons = updateMapIcons;

        // Update icons regularly (every 5 seconds)
        setInterval(updateMapIcons, 5000);
        
        // Function to update popup opacity values from HTMX response (currently disabled - using fixed values)
        function updatePopupOpacityFromHTMX(event) {
            // Opacity is now fixed at 1.0 in CSS, no dynamic updates needed
        }
        
        // Function to update popup opacity values from server (currently disabled - using fixed values)
        function updatePopupOpacityFromServer() {
            // Opacity is now fixed at 1.0 in CSS, no dynamic updates needed
        }

        // Initialize ticker animation
        function initTickerAnimation() {
            const tickerScroll = document.querySelector('.ticker-scroll');
            if (tickerScroll) {
                const contentWidth = tickerScroll.scrollWidth;
                const viewportWidth = window.innerWidth;
                // Calculate end position: from right (100vw) to completely outside left
                // Content must completely disappear beyond the left edge
                const endPosition = -(contentWidth + viewportWidth);
                const duration = 40; // Sekunden

                // Remove old animation styles
                const oldStyle = document.getElementById('ticker-animation-style');
                if (oldStyle) oldStyle.remove();

                // Set animation dynamically
                tickerScroll.style.animation = `ticker-anim ${duration}s linear infinite`;
                const style = document.createElement('style');
                style.id = 'ticker-animation-style';
                style.textContent = `
                    @keyframes ticker-anim {
                        0% { transform: translateX(100vw); }
                        100% { transform: translateX(${endPosition}px); }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        // Initialize animation after loading
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initTickerAnimation);
        } else {
            initTickerAnimation();
        }

        // Also initialize after HTMX updates
        document.body.addEventListener('htmx:afterSwap', function(event) {
            if (event.target.id === 'ticker-target') {
                setTimeout(initTickerAnimation, 100);
                // Update popup opacity from HTMX response
                if (typeof updatePopupOpacityFromHTMX === 'function') {
                    updatePopupOpacityFromHTMX(event);
                }
            }
            // Restore open groups after table is reloaded via HTMX
            if (event.target.id === 'dynamic-table-content' || (event.target.closest && event.target.closest('#dynamic-table-content'))) {
                // Use MutationObserver to wait for DOM to be ready
                const tableContent = document.getElementById('dynamic-table-content');
                if (tableContent) {
                    const observer = new MutationObserver(function(mutations) {
                        // Restore groups after DOM changes
                        try {
                            const stored = localStorage.getItem('mcc_open_groups');
                            if (stored) {
                                const openGroups = JSON.parse(stored);
                                let restored = false;
                                openGroups.forEach(function(groupId) {
                                    const el = document.getElementById(groupId);
                                    if (el && !el.classList.contains('is-open')) {
                                        el.classList.add('is-open');
                                        restored = true;
                                    }
                                });
                                if (restored) {
                                    observer.disconnect(); // Stop observing once restored
                                }
                            } else {
                                observer.disconnect();
                            }
                        } catch (e) {
                            console.error('Error restoring open groups:', e);
                            observer.disconnect();
                        }
                    });
                    
                    // Start observing
                    observer.observe(tableContent, {
                        childList: true,
                        subtree: true
                    });
                    
                    // Also try immediate restore and with delays as fallback
                    setTimeout(function() {
                        try {
                            const stored = localStorage.getItem('mcc_open_groups');
                            if (stored) {
                                const openGroups = JSON.parse(stored);
                                openGroups.forEach(function(groupId) {
                                    const el = document.getElementById(groupId);
                                    if (el) {
                                        el.classList.add('is-open');
                                    }
                                });
                            }
                        } catch (e) {
                            console.error('Error restoring open groups:', e);
                        }
                        observer.disconnect();
                    }, 200);
                }
            }
        });

        // Check milestone celebrations
        // Load from localStorage to persist across page reloads
        var lastMilestoneCheck = localStorage.getItem('lastMilestoneCheck');
        var shownMilestoneIds = new Set();
        var storedIds = localStorage.getItem('shownMilestoneIds');
        if (storedIds) {
            try {
                var idsArray = JSON.parse(storedIds);
                idsArray.forEach(function(id) {
                    shownMilestoneIds.add(id);
                });
                console.log('Geladene bereits angezeigte Meilenstein-IDs aus localStorage:', shownMilestoneIds.size);
            } catch (e) {
                console.error('Error parsing shownMilestoneIds from localStorage:', e);
            }
        }
        // If we have a stored timestamp, we're not on first check
        // On first check (no stored timestamp), we should not show old milestones
        var isFirstCheck = !lastMilestoneCheck;

        // Store previous milestone states to detect when a milestone is newly reached
        var previousMilestoneStates = {};
        
        // Initialize previousMilestoneStates on first load
        function initializeMilestoneStates() {
            // Initialize from initial milestones data if available
            if (typeof milestones !== 'undefined' && milestones.length > 0) {
                milestones.forEach(function(ms) {
                    if (ms.id) {
                        previousMilestoneStates[ms.id] = ms.is_reached || false;
                        console.log('[initializeMilestoneStates] Initialized milestone', ms.id, 'as', ms.is_reached ? 'reached' : 'not reached');
                    }
                });
            }
            
            // Also initialize from first updateMilestoneMarkers call
            // This ensures we catch milestones that were reached before page load
            setTimeout(function() {
                var url = "{% url 'map:get_all_milestones_status' %}";
                var params = [];
                {% if group_id %}
                params.push("group_id={{ group_id|urlencode }}");
                {% elif group_name %}
                params.push("group_name={{ group_name|urlencode }}");
                {% endif %}
                if (params.length > 0) {
                    url += "?" + params.join("&");
                }
                
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        if (data.milestones && data.milestones.length > 0) {
                            data.milestones.forEach(function(ms) {
                                if (ms.id) {
                                    // Only set if not already initialized
                                    if (previousMilestoneStates[ms.id] === undefined) {
                                        previousMilestoneStates[ms.id] = ms.is_reached || false;
                                        console.log('[initializeMilestoneStates] Initialized milestone', ms.id, 'from server as', ms.is_reached ? 'reached' : 'not reached');
                                    }
                                }
                            });
                        }
                    })
                    .catch(error => {
                        console.error('[initializeMilestoneStates] Error fetching milestone states:', error);
                    });
            }, 2000);
        }
        

        // Function to update milestone markers based on current status from server
        function updateMilestoneMarkers() {
            var url = "{% url 'map:get_all_milestones_status' %}";
            var params = [];

            {% if group_id %}
            params.push("group_id={{ group_id|urlencode }}");
            {% elif group_name %}
            params.push("group_name={{ group_name|urlencode }}");
            {% endif %}

            if (params.length > 0) {
                url += "?" + params.join("&");
            }

            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP error! status: ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.milestones && data.milestones.length > 0) {
                        data.milestones.forEach(function(ms) {
                            if (ms.id && milestoneMarkerMap[ms.id]) {
                                var marker = milestoneMarkerMap[ms.id];
                                
                                // Check if this is the target/end point
                                var isTarget = false;
                                if (ms.name && (ms.name.toLowerCase().includes('ziel') || ms.name.toLowerCase().includes('target'))) {
                                    isTarget = true;
                                } else if (ms.track_total_length_km) {
                                    // Check if milestone is at or near the end of the track (within 100m)
                                    var distanceToEnd = Math.abs(ms.track_total_length_km - (ms.km || 0));
                                    if (distanceToEnd < 0.1) { // Within 100m of track end
                                        isTarget = true;
                                    }
                                }
                                
                                var isReached = ms.is_reached || false;
                                
                                // Initialize state if not already set (first time seeing this milestone)
                                if (previousMilestoneStates[ms.id] === undefined) {
                                    previousMilestoneStates[ms.id] = isReached;
                                    console.log('[updateMilestoneMarkers] First time seeing milestone', ms.id, '(', ms.name, '), initializing as', isReached ? 'reached' : 'not reached');
                                }
                                
                                var wasReached = previousMilestoneStates[ms.id];
                                // Only treat as newly reached if it was explicitly false before (not undefined)
                                var isNewlyReached = isReached && (wasReached === false);
                                
                                // Debug logging for reached milestones
                                if (isReached) {
                                    console.log('[updateMilestoneMarkers] Milestone', ms.id, '(', ms.name, '): isReached=', isReached, ', wasReached=', wasReached, ', isNewlyReached=', isNewlyReached);
                                }
                                
                                // Store current state for next check
                                previousMilestoneStates[ms.id] = isReached;
                                
                                var bgColor, borderColor, iconEmoji;
                                
                                if (isTarget) {
                                    // Target point: Green with finish flag
                                    bgColor = isReached ? '#28a745' : '#20c997';
                                    borderColor = isReached ? '#155724' : '#17a2b8';
                                    iconEmoji = '🏁';
                                } else {
                                    bgColor = isReached ? '#28a745' : '#ffd700';  // Green for reached, gold for unreached
                                    borderColor = isReached ? '#1e7e34' : '#ff8c00';  // Dark green for reached, orange for unreached
                                    iconEmoji = isReached ? '✅' : '🏆';
                                }
                                
                                var milestoneIcon = L.divIcon({
                                    className: 'milestone-marker',
                                    html: '<div style="background: ' + bgColor + '; border: 3px solid ' + borderColor + '; border-radius: ' + (isTarget ? '8px' : '50%') + '; width: ' + (isTarget ? '40px' : '30px') + '; height: ' + (isTarget ? '40px' : '30px') + '; display: flex; align-items: center; justify-content: center; font-size: ' + (isTarget ? '24px' : '18px') + '; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transform: ' + (isTarget ? 'rotate(-5deg)' : 'none') + ';">' + iconEmoji + '</div>',
                                    iconSize: [isTarget ? 40 : 30, isTarget ? 40 : 30],
                                    iconAnchor: [isTarget ? 20 : 15, isTarget ? 20 : 15]
                                });
                                marker.setIcon(milestoneIcon);
                                
                                // Update popup with reward information
                                var kmValue = ms.km || ms.distance_km || 0;
                                var popupContent = '<div class="milestone-header">🏆 {% trans "Meilenstein" %}</div>';
                                popupContent += '<div class="milestone-name">' + (isTarget ? '🏁 ' + ms.name : ms.name) + '</div>';
                                popupContent += '<div class="milestone-distance">' + formatNumberDE(kmValue, 2) + ' km</div>';
                                if (isTarget) {
                                    popupContent += '<div class="milestone-target-reached">{% trans "Ziel erreicht!" %}</div>';
                                }
                                // Always show reward if available (for both target and regular milestones)
                                if (ms.reward_text && ms.reward_text.trim()) {
                                    popupContent += '<div class="milestone-reward-label">{% trans "Belohnung" %}</div>';
                                    popupContent += '<div class="milestone-reward-text">' + ms.reward_text + '</div>';
                                } else if (ms.text && ms.text.trim()) {
                                    popupContent += '<div class="milestone-reward-text">' + ms.text + '</div>';
                                }
                                if (isReached && ms.winner_group_name) {
                                    popupContent += '<div class="milestone-group-label">{% trans "Erreicht von" %}</div>';
                                    popupContent += '<div class="milestone-group-name">' + ms.winner_group_name + '</div>';
                                    if (ms.reached_at) {
                                        var reachedDate = new Date(ms.reached_at);
                                        popupContent += '<div class="milestone-date">{% trans "Erreicht am" %}: ' + reachedDate.toLocaleString('de-DE') + '</div>';
                                    }
                                }
                                // Add details button if description or external_link exists
                                if ((ms.description && ms.description.trim()) || (ms.external_link && ms.external_link.trim())) {
                                    // Find track name from tracks array or use track_name from API
                                    var trackName = ms.track_name || '';
                                    if (!trackName && ms.track_id && typeof tracks !== 'undefined') {
                                        var track = tracks.find(function(t) {
                                            var tid = typeof t.id === 'string' ? parseInt(t.id) : t.id;
                                            var mid = typeof ms.track_id === 'string' ? parseInt(ms.track_id) : ms.track_id;
                                            return tid === mid;
                                        });
                                        if (track && track.name) {
                                            trackName = track.name;
                                        }
                                    }
                                    popupContent += '<div class="milestone-details-btn-container">';
                                    popupContent += '<button class="milestone-details-btn" onclick="openMilestoneDetailsFromPopup(' + ms.id + ', \'' + (ms.name || '').replace(/'/g, "\\'") + '\', \'' + (ms.description || '').replace(/'/g, "\\'").replace(/\n/g, '\\n') + '\', \'' + (ms.external_link || '') + '\', \'' + (ms.reward_text || ms.text || '') + '\', \'' + (ms.winner_group_name || '') + '\', \'' + (ms.winner_parent_group_name || '') + '\', \'' + (ms.reached_at || '') + '\', ' + kmValue + ', \'' + trackName.replace(/'/g, "\\'") + '\')">';
                                    popupContent += 'ℹ️ {% trans "Details anzeigen" %}';
                                    popupContent += '</button>';
                                    popupContent += '</div>';
                                }
                                marker.setPopupContent(popupContent);
                                
                                // If milestone was just reached (status changed from unreached to reached), show overlay
                                if (isNewlyReached) {
                                    console.log('[updateMilestoneMarkers] Milestone newly reached:', ms.name, 'ID:', ms.id);
                                    
                                    // Show milestone overlay
                                    showMilestoneOverlay(ms);
                                }
                            }
                        });
                    }
                })
                .catch(error => {
                    console.error('Error updating milestone markers:', error);
                });
        }

        function checkNewMilestones() {
            var url = "{% url 'map:get_new_milestones' %}";
            var params = [];

            {% if group_id %}
            params.push("group_id={{ group_id|urlencode }}");
            {% elif group_name %}
            params.push("group_name={{ group_name|urlencode }}");
            {% endif %}

            // Always send last_check if available to only get new milestones
            // On first check (no stored timestamp), set last_check to 30 seconds ago to catch recently reached milestones
            // After that only new milestones after last check
            if (lastMilestoneCheck) {
                params.push("last_check=" + encodeURIComponent(lastMilestoneCheck));
            } else {
                // On first check, set last_check to 30 seconds ago to catch milestones reached just before page load
                // This ensures we don't miss milestones that were reached while the page was loading
                var now = new Date();
                now.setSeconds(now.getSeconds() - 30);  // 30 seconds ago
                var lastCheckTime = now.toISOString();
                params.push("last_check=" + encodeURIComponent(lastCheckTime));
                // Store this as the initial lastMilestoneCheck to avoid showing old milestones
                lastMilestoneCheck = lastCheckTime;
                localStorage.setItem('lastMilestoneCheck', lastCheckTime);
            }

            if (params.length > 0) {
                url += "?" + params.join("&");
            }

            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP error! status: ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.milestones && data.milestones.length > 0) {
                        var newCount = 0;
                        // Show only new milestones that haven't been displayed yet
                        data.milestones.forEach(function(ms) {
                            if (!shownMilestoneIds.has(ms.id)) {
                                // Show new milestone overlay
                                showMilestoneOverlay(ms);
                                shownMilestoneIds.add(ms.id);
                                newCount++;

                                // Update milestone marker color
                                var marker = milestoneMarkerMap[ms.id] || milestoneMarkerMap[ms.name];
                                if (marker) {
                                    // Check if this is the target/end point
                                    var kmValue = ms.km || ms.distance_km || 0;
                                    var isTarget = false;
                                    if (ms.name && (ms.name.toLowerCase().includes('ziel') || ms.name.toLowerCase().includes('target'))) {
                                        isTarget = true;
                                    } else if (ms.track_total_length_km) {
                                        // Check if milestone is at or near the end of the track (within 100m)
                                        var distanceToEnd = Math.abs(ms.track_total_length_km - kmValue);
                                        if (distanceToEnd < 0.1) { // Within 100m of track end
                                            isTarget = true;
                                        }
                                    }
                                    
                                    var isReached = ms.is_reached || false;
                                    var bgColor, borderColor, iconEmoji;
                                    
                                    if (isTarget) {
                                        // Target point: Green with finish flag
                                        bgColor = isReached ? '#28a745' : '#20c997';
                                        borderColor = isReached ? '#155724' : '#17a2b8';
                                        iconEmoji = '🏁';
                                    } else {
                                        bgColor = isReached ? '#28a745' : '#ffd700';
                                        borderColor = isReached ? '#1e7e34' : '#ff8c00';
                                        iconEmoji = isReached ? '✅' : '🏆';
                                    }
                                    
                                    var reachedIcon = L.divIcon({
                                        className: 'milestone-marker',
                                        html: '<div style="background: ' + bgColor + '; border: 3px solid ' + borderColor + '; border-radius: ' + (isTarget ? '8px' : '50%') + '; width: ' + (isTarget ? '40px' : '30px') + '; height: ' + (isTarget ? '40px' : '30px') + '; display: flex; align-items: center; justify-content: center; font-size: ' + (isTarget ? '24px' : '18px') + '; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transform: ' + (isTarget ? 'rotate(-5deg)' : 'none') + ';">' + iconEmoji + '</div>',
                                        iconSize: [isTarget ? 40 : 30, isTarget ? 40 : 30],
                                        iconAnchor: [isTarget ? 20 : 15, isTarget ? 20 : 15]
                                    });
                                    marker.setIcon(reachedIcon);
                                }
                            }
                        });
                        // Update last check timestamp and save to localStorage
                        lastMilestoneCheck = new Date().toISOString();
                        localStorage.setItem('lastMilestoneCheck', lastMilestoneCheck);
                        // Save shown milestone IDs to localStorage
                        localStorage.setItem('shownMilestoneIds', JSON.stringify(Array.from(shownMilestoneIds)));
                        isFirstCheck = false;
                    } else {
                        // Also set timestamp on first check if no milestones were found
                        if (isFirstCheck) {
                            var now = new Date();
                            now.setSeconds(now.getSeconds() - 5);
                            lastMilestoneCheck = now.toISOString();
                            localStorage.setItem('lastMilestoneCheck', lastMilestoneCheck);
                            isFirstCheck = false;
                        }
                    }
                })
                .catch(error => {
                    console.error('Fehler beim Laden der Meilensteine:', error);
                });
        }

        // Show milestone overlay with milestone data
        function showMilestoneOverlay(milestone) {
            var overlay = document.getElementById('milestone-overlay');
            var card = document.getElementById('milestone-card');
            var titleEl = document.getElementById('milestone-overlay-title');
            var nameEl = document.getElementById('milestone-overlay-name');
            var trackNameEl = document.getElementById('milestone-overlay-track-name');
            var topGroupEl = document.getElementById('milestone-overlay-top-group');
            var leafGroupEl = document.getElementById('milestone-overlay-leaf-group');
            var rewardEl = document.getElementById('milestone-overlay-reward');
            var descriptionEl = document.getElementById('milestone-overlay-description');
            var descriptionTextEl = document.getElementById('milestone-overlay-description-text');
            var linkEl = document.getElementById('milestone-overlay-link');
            var linkBtn = document.getElementById('milestone-overlay-link-btn');

            if (!overlay || !card) {
                console.error('Milestone overlay elements not found');
                return;
            }

            // Set title based on whether milestone is reached
            var isReached = milestone.is_reached || milestone.winner_group_name || milestone.group_name || false;
            if (titleEl) {
                titleEl.textContent = isReached ? '{% trans "Meilenstein erreicht!" %}' : '{% trans "Meilenstein" %}';
            }

            // Set milestone data
            if (nameEl) nameEl.textContent = milestone.name || '';
            if (trackNameEl) trackNameEl.textContent = milestone.track_name || '-';
            if (topGroupEl) topGroupEl.textContent = milestone.winner_parent_group_name || milestone.parent_group_name || '-';
            if (leafGroupEl) leafGroupEl.textContent = milestone.winner_group_name || milestone.group_name || '-';
            if (rewardEl) rewardEl.textContent = milestone.reward_text || milestone.text || '{% trans "Herzlichen Glückwunsch!" %}';

            // Beschreibung anzeigen (wenn vorhanden)
            if (milestone.description && milestone.description.trim() && descriptionEl && descriptionTextEl) {
                descriptionTextEl.textContent = milestone.description;
                descriptionEl.style.display = 'block';
            } else if (descriptionEl) {
                descriptionEl.style.display = 'none';
            }

            // Externer Link anzeigen (wenn vorhanden)
            if (milestone.external_link && milestone.external_link.trim() && linkEl && linkBtn) {
                linkBtn.href = milestone.external_link;
                linkEl.style.display = 'block';
            } else if (linkEl) {
                linkEl.style.display = 'none';
            }

            // Show overlay
            overlay.classList.remove('hidden');
            card.classList.remove('fade-out');

            // Automatically close after 30 seconds
            setTimeout(function() {
                closeMilestoneOverlay();
            }, milestonePopupDuration || 30000);
        }

        // Open milestone details from popup
        function openMilestoneDetailsFromPopup(id, name, description, externalLink, rewardText, winnerGroupName, winnerParentGroupName, reachedAt, km, trackName) {
            var milestone = {
                id: id,
                name: name,
                description: description,
                external_link: externalLink,
                reward_text: rewardText,
                text: rewardText,
                winner_group_name: winnerGroupName,
                winner_parent_group_name: winnerParentGroupName,
                reached_at: reachedAt,
                km: km,
                track_name: trackName || null,
                is_reached: !!(winnerGroupName || winnerParentGroupName) // Set is_reached based on whether there's a winner
            };
            showMilestoneOverlay(milestone);
        }

        // Close milestone overlay
        function closeMilestoneOverlay() {
            var overlay = document.getElementById('milestone-overlay');
            var card = document.getElementById('milestone-card');
            if (overlay && card) {
                card.classList.add('fade-out');
                setTimeout(function() {
                    overlay.classList.add('hidden');
                }, 300); // Match animation duration
            }
        }

        // Check for new milestones every 5 seconds
        setInterval(checkNewMilestones, 5000);
        // Initial check after 2 seconds
        setTimeout(checkNewMilestones, 2000);
        
        // Initialize milestone states on page load
        setTimeout(initializeMilestoneStates, 1000);
        
        // Update milestone markers every 10 seconds to catch resets
        setInterval(updateMilestoneMarkers, 10000);
        // Initial update after 5 seconds
        setTimeout(updateMilestoneMarkers, 5000);

        // Group change function
        // Track selector dropdown functions
        var trackDropdownOpen = false;
        var trackDropdownClickListener = null;
        
        function toggleTrackDropdown(event) {
            if (event) {
                event.stopPropagation();
            }
            var dropdown = document.getElementById('track-selector-dropdown');
            if (!dropdown) return;
            
            if (dropdown.style.display === 'none' || dropdown.style.display === '') {
                dropdown.style.display = 'block';
                trackDropdownOpen = true;
                // Add click listener when opening
                addTrackDropdownCloseListener();
            } else {
                dropdown.style.display = 'none';
                trackDropdownOpen = false;
                // Remove click listener when closing
                removeTrackDropdownCloseListener();
            }
        }
        
        // Close dropdown when clicking outside
        function closeTrackDropdown() {
            var dropdown = document.getElementById('track-selector-dropdown');
            if (dropdown) {
                dropdown.style.display = 'none';
                trackDropdownOpen = false;
                removeTrackDropdownCloseListener();
            }
        }
        
        // Add click outside listener
        function addTrackDropdownCloseListener() {
            // Remove existing listener if any
            removeTrackDropdownCloseListener();
            
            // Add new listener
            trackDropdownClickListener = function(event) {
                var wrapper = document.getElementById('track-selector-wrapper');
                var dropdown = document.getElementById('track-selector-dropdown');
                
                if (!wrapper || !dropdown) {
                    closeTrackDropdown();
                    return;
                }
                
                // Check if click is outside the wrapper
                if (!wrapper.contains(event.target)) {
                    closeTrackDropdown();
                }
            };
            
            // Use setTimeout to add listener after current event completes
            setTimeout(function() {
                document.addEventListener('click', trackDropdownClickListener, true);
            }, 0);
        }
        
        // Remove click outside listener
        function removeTrackDropdownCloseListener() {
            if (trackDropdownClickListener) {
                document.removeEventListener('click', trackDropdownClickListener, true);
                trackDropdownClickListener = null;
            }
        }
        
        // Update button text based on selection
        function updateTrackSelectorText() {
            var allCheckbox = document.getElementById('track-all');
            var checkboxes = document.querySelectorAll('.track-checkbox');
            var selectedTracks = Array.from(checkboxes).filter(cb => cb.checked);
            var buttonText = document.getElementById('track-selector-text');
            
            if (allCheckbox && allCheckbox.checked) {
                buttonText.textContent = '{% trans "Alle Routen" %}';
            } else if (selectedTracks.length === 0) {
                buttonText.textContent = '{% trans "Keine Routen" %}';
            } else if (selectedTracks.length === 1) {
                // Get track name from the checkbox's parent label
                var trackName = selectedTracks[0].parentElement.textContent.trim();
                buttonText.textContent = trackName;
            } else {
                buttonText.textContent = selectedTracks.length + ' {% trans "Routen" %}';
            }
        }
        
        // Handle "All Tracks" checkbox change
        function handleTrackAllChange(checkbox) {
            var trackCheckboxes = document.querySelectorAll('.track-checkbox');
            if (checkbox.checked) {
                // Check all individual tracks when "all" is selected
                trackCheckboxes.forEach(function(cb) {
                    cb.checked = true;
                });
                applyTrackFilter(true);
            } else {
                // Uncheck all individual tracks when "all" is unchecked
                trackCheckboxes.forEach(function(cb) {
                    cb.checked = false;
                });
                // When "Alle Routen" is deselected, hide all tracks
                applyTrackFilter(false);
            }
            updateTrackSelectorText();
        }
        
        // Handle individual track checkbox change
        function handleTrackChange(checkbox) {
            var allCheckbox = document.getElementById('track-all');
            var trackCheckboxes = document.querySelectorAll('.track-checkbox');
            var allChecked = Array.from(trackCheckboxes).every(cb => cb.checked);
            
            if (allChecked && allCheckbox) {
                // If all tracks are checked, check "all"
                allCheckbox.checked = true;
            } else if (allCheckbox) {
                // If not all tracks are checked, uncheck "all"
                allCheckbox.checked = false;
            }
            applyTrackFilter(false);
            updateTrackSelectorText();
        }
        
        // Apply track filter to map - update visibility without page reload
        function applyTrackFilter(forceShowAll) {
            if (!tracks || !Array.isArray(tracks)) {
                console.warn('Tracks not available for applyTrackFilter');
                return;
            }
            
            // Use Layer Control checkboxes (primary source) or fallback to sidebar checkboxes
            var allCheckbox = document.getElementById('layer-track-all') || document.getElementById('track-all');
            // Prefer Layer Control checkboxes, fallback to sidebar checkboxes
            var layerCheckboxes = document.querySelectorAll('.layer-track-toggle');
            var sidebarCheckboxes = document.querySelectorAll('.track-checkbox');
            var checkboxes = layerCheckboxes.length > 0 ? layerCheckboxes : sidebarCheckboxes;
            var selectedTracks = Array.from(checkboxes).filter(function(cb) { 
                return cb.checked && cb.value !== 'all' && cb.value !== ''; 
            });
            var totalCheckboxes = checkboxes.length;
            
            // Determine which tracks should be visible
            // Priority: forceShowAll > selectedTracks > allCheckbox > none
            var visibleTrackIds = [];
            if (forceShowAll === true) {
                // Show all tracks
                visibleTrackIds = tracks.map(function(t) { 
                    return typeof t.id === 'string' ? parseInt(t.id) : t.id; 
                }).filter(function(id) { return !isNaN(id); });
            } else if (selectedTracks.length > 0 && selectedTracks.length < totalCheckboxes) {
                // Show selected tracks
                visibleTrackIds = selectedTracks.map(function(cb) { 
                    return parseInt(cb.value); 
                }).filter(function(id) { return !isNaN(id); });
            } else if ((allCheckbox && allCheckbox.checked) || (totalCheckboxes > 0 && selectedTracks.length >= totalCheckboxes)) {
                // "All" is checked OR all individual tracks are checked, show all tracks
                visibleTrackIds = tracks.map(function(t) { 
                    return typeof t.id === 'string' ? parseInt(t.id) : t.id; 
                }).filter(function(id) { return !isNaN(id); });
            } else {
                // No tracks selected, show no tracks
                visibleTrackIds = [];
            }
            
            // Update track visibility
            updateTrackVisibility(visibleTrackIds);
            
            // Update URL without page reload
            var urlParams = new URLSearchParams(window.location.search);
            if (visibleTrackIds.length === 0) {
                urlParams.set('track_ids', 'none');
            } else if (visibleTrackIds.length === tracks.length) {
                urlParams.delete('track_ids');
            } else {
                urlParams.set('track_ids', visibleTrackIds.join(','));
            }
            
            // Update URL in browser without reload
            var newUrl = window.location.pathname;
            if (urlParams.toString()) {
                newUrl += '?' + urlParams.toString();
            }
            window.history.replaceState({}, '', newUrl);
            
            // Refresh avatars to reflect track changes
            if (typeof refreshAvatars === 'function' && window.avatarRefreshInterval) {
                // Trigger immediate refresh
                if (typeof window.updateMapIcons === 'function') {
                    window.updateMapIcons();
                }
            }
        }
        
        // Group selector dropdown functions
        var groupDropdownOpen = false;
        var groupDropdownClickListener = null;
        
        function toggleGroupDropdown(event) {
            if (event) {
                event.stopPropagation();
            }
            var dropdown = document.getElementById('group-selector-dropdown');
            if (!dropdown) return;
            
            if (dropdown.style.display === 'none' || dropdown.style.display === '') {
                dropdown.style.display = 'block';
                groupDropdownOpen = true;
                addGroupDropdownCloseListener();
            } else {
                dropdown.style.display = 'none';
                groupDropdownOpen = false;
                removeGroupDropdownCloseListener();
            }
        }
        
        // Close dropdown when clicking outside
        function closeGroupDropdown() {
            var dropdown = document.getElementById('group-selector-dropdown');
            if (dropdown) {
                dropdown.style.display = 'none';
                groupDropdownOpen = false;
                removeGroupDropdownCloseListener();
            }
        }
        
        // Add click outside listener
        function addGroupDropdownCloseListener() {
            removeGroupDropdownCloseListener();
            
            groupDropdownClickListener = function(event) {
                var wrapper = document.getElementById('group-selector-wrapper');
                var dropdown = document.getElementById('group-selector-dropdown');
                
                if (!wrapper || !dropdown) {
                    closeGroupDropdown();
                    return;
                }
                
                if (!wrapper.contains(event.target)) {
                    closeGroupDropdown();
                }
            };
            
            setTimeout(function() {
                document.addEventListener('click', groupDropdownClickListener, true);
            }, 0);
        }
        
        // Remove click outside listener
        function removeGroupDropdownCloseListener() {
            if (groupDropdownClickListener) {
                document.removeEventListener('click', groupDropdownClickListener, true);
                groupDropdownClickListener = null;
            }
        }
        
        // Legacy functions removed - now using Filter Bar and Layer Control only
        // Old sidebar group selector functions (handleGroupAllChange, handleGroupChange, updateGroupSelectorText) 
        // have been removed as the sidebar group selector is no longer used in ranking view
        
        // Apply group filter and reload ranking content without page reload
        function applyGroupFilter(forceShowAll) {
            // Use Layer Control checkboxes (map filter) as source of truth
            var allCheckbox = document.getElementById('layer-group-all');
            var checkboxes = document.querySelectorAll('.layer-group-toggle');
            // Filter out the 'all' checkbox value
            var selectedGroups = Array.from(checkboxes).filter(cb => cb.checked && cb.value !== 'all');
            var totalCheckboxes = checkboxes.length;
            
            // Preserve existing URL parameters except group_id and group
            var urlParams = new URLSearchParams(window.location.search);
            urlParams.delete('group_id');
            urlParams.delete('group');  // Also remove 'group' parameter (used by backend)
            
            // Determine what to do based on the state
            // Priority: forceShowAll > selectedGroups > allCheckbox > none
            var groupIdValue = null;
            if (forceShowAll === true) {
                // Force show all groups - no group_id parameter
                groupIdValue = null;
            } else if (selectedGroups.length > 0 && selectedGroups.length < totalCheckboxes) {
                // Some (but not all) individual groups are selected - show only those
                // Note: Backend expects comma-separated IDs
                groupIdValue = selectedGroups.map(cb => cb.value).join(',');
            } else if ((allCheckbox && allCheckbox.checked) || (totalCheckboxes > 0 && selectedGroups.length >= totalCheckboxes)) {
                // "All" is checked OR all individual TOP-Gruppen checkboxes are checked - show all groups (no parameter)
                // Note: >= instead of === to handle edge cases
                // When all TOP-Gruppen are selected, don't set group_id parameter so backend shows all groups
                groupIdValue = null;
            } else if (selectedGroups.length === 0 && (!allCheckbox || !allCheckbox.checked)) {
                // No groups selected at all - show no groups
                groupIdValue = 'none';
            } else {
                // Default: show all groups (no parameter)
                groupIdValue = null;
            }
            
            // Set or delete group_id parameter
            if (groupIdValue === null) {
                urlParams.delete('group_id');
            } else {
                urlParams.set('group_id', groupIdValue);
            }
            
            // Debug output
            console.log('applyGroupFilter - groupIdValue:', groupIdValue);
            console.log('applyGroupFilter - allCheckbox.checked:', allCheckbox ? allCheckbox.checked : 'N/A');
            console.log('applyGroupFilter - selectedGroups.length:', selectedGroups.length);
            console.log('applyGroupFilter - totalCheckboxes:', totalCheckboxes);
            console.log('applyGroupFilter - forceShowAll:', forceShowAll);
            console.log('applyGroupFilter - final URL group_id:', urlParams.get('group_id'));
            
            // Build ranking URL with group filter
            // Get language prefix from current URL
            var langPrefix = '';
            var pathParts = window.location.pathname.split('/');
            if (pathParts.length > 1 && pathParts[1].length === 2) {
                // Language prefix detected (e.g., /de/, /en/)
                langPrefix = '/' + pathParts[1] + '/';
            }
            var rankingUrl = langPrefix + 'ranking/';
            if (urlParams.toString()) {
                rankingUrl += '?' + urlParams.toString();
            }
            
            // Debug: Log the URL being requested
            console.log('Loading ranking with URL:', rankingUrl);
            console.log('forceShowAll:', forceShowAll);
            console.log('allCheckbox.checked:', allCheckbox ? allCheckbox.checked : 'N/A');
            console.log('selectedGroups.length:', selectedGroups.length);
            console.log('urlParams.get("group_id"):', urlParams.get('group_id'));
            
            // Reload ranking content via fetch without changing view
            var rankingContent = document.getElementById('ranking-content');
            if (rankingContent) {
                rankingContent.dataset.loaded = 'false'; // Force reload
                fetch(rankingUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'text/html',
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    credentials: 'same-origin',
                    mode: 'same-origin'
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.text();
                    })
                    .then(html => {
                        rankingContent.innerHTML = html;
                        // Process any HTMX elements in the loaded content
                        if (window.htmx) {
                            htmx.process(rankingContent);
                        }
                        rankingContent.dataset.loaded = 'true';
                    })
                    .catch(error => {
                        console.error('Error loading ranking page:', error);
                        rankingContent.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545;">Fehler beim Laden der Ranking-Seite. Bitte versuchen Sie es erneut.</div>';
                    });
            }
        }
        
        // Legacy function for compatibility
        function changeGroup(groupId) {
            var currentPath = window.location.pathname;
            var baseUrl = currentPath.split('?')[0];
            var params = [];
            
            if (groupId && groupId !== '') {
                params.push('group_id=' + encodeURIComponent(groupId));
            }
            
            var url = baseUrl;
            if (params.length > 0) {
                url += '?' + params.join('&');
            }
            window.location.href = url;
        }

        // View toggle functions with smooth transitions
        function showMapView() {
            var mapSection = document.getElementById('section-map');
            var rankingSection = document.getElementById('section-ranking');
            
            // Update button states
            document.getElementById('btn-show-map').classList.add('active');
            document.getElementById('btn-show-ranking').classList.remove('active');
            
            // Show map, hide ranking with transitions
            rankingSection.classList.remove('active');
            setTimeout(function() {
                mapSection.classList.remove('hidden');
            }, 50);
            
            // Show layer control (with tracks section visible, groups section hidden)
            var layerControl = document.getElementById('floating-layer-control');
            if (layerControl) {
                layerControl.style.display = 'block';
            }
            var tracksSection = document.getElementById('layer-control-tracks-section');
            if (tracksSection) {
                tracksSection.style.display = 'block';
            }
            var groupsSection = document.getElementById('layer-control-groups-section');
            if (groupsSection) {
                groupsSection.style.display = 'none';
            }
            
            // Show track selector, hide group selector in sidebar
            document.getElementById('track-selector-section').style.display = 'block';
            document.getElementById('group-selector-section').style.display = 'none';
            
            // Invalidate map size when switching back to map
            if (map) {
                setTimeout(function() {
                    map.invalidateSize();
                }, 300);
            }
        }

        function showRankingView() {
            var mapSection = document.getElementById('section-map');
            var rankingSection = document.getElementById('section-ranking');
            
            // Update button states
            document.getElementById('btn-show-map').classList.remove('active');
            document.getElementById('btn-show-ranking').classList.add('active');
            
            // Hide map, show ranking with transitions
            mapSection.classList.add('hidden');
            setTimeout(function() {
                rankingSection.classList.add('active');
            }, 50);
            
            // Hide track selector in sidebar (using Filter Bar for groups in ranking view)
            document.getElementById('track-selector-section').style.display = 'none';
            
            // Load ranking content with current group filter
            var rankingContent = document.getElementById('ranking-content');
            if (rankingContent && !rankingContent.dataset.loaded) {
                // Build ranking URL with current group filter
                var langPrefix = '';
                var pathParts = window.location.pathname.split('/');
                if (pathParts.length > 1 && pathParts[1].length === 2) {
                    langPrefix = '/' + pathParts[1] + '/';
                }
                var rankingUrl = langPrefix + 'ranking/';
                
                // Get current group selection from Filter Bar or Layer Control (sidebar removed)
                var groupAllCheckbox = document.getElementById('layer-group-all');
                var groupCheckboxes = document.querySelectorAll('.layer-group-toggle');
                // Filter out the 'all' checkbox value
                var selectedGroups = Array.from(groupCheckboxes).filter(cb => cb.checked && cb.value !== 'all');
                var totalCheckboxes = groupCheckboxes.length;
                var urlParams = new URLSearchParams();
                
                // Check if all groups are selected
                // Note: >= instead of === to handle edge cases where all checkboxes might be checked
                var allGroupsSelected = (groupAllCheckbox && groupAllCheckbox.checked) || 
                                       (totalCheckboxes > 0 && selectedGroups.length >= totalCheckboxes);
                
                if (allGroupsSelected) {
                    // Show all groups - no group_id parameter (backend will show all groups by default)
                    // Don't set any parameter
                } else if (selectedGroups.length > 0) {
                    // Some (but not all) groups selected - add selected group IDs
                    var groupIds = selectedGroups.map(cb => cb.value).join(',');
                    urlParams.set('group_id', groupIds);
                } else {
                    // No groups selected - set to 'none' to show nothing
                    urlParams.set('group_id', 'none');
                }
                
                // Add refresh_table parameter to get only table content
                urlParams.set('refresh_table', 'true');
                if (urlParams.toString()) {
                    rankingUrl += '?' + urlParams.toString();
                }
                
                // Load ranking content
                fetch(rankingUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'text/html',
                        'X-Requested-With': 'XMLHttpRequest',
                        'HX-Request': 'true'
                    },
                    credentials: 'same-origin',
                    mode: 'same-origin'
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.text();
                    })
                    .then(html => {
                        console.log('Ranking content loaded, length:', html.length);
                        // Extract only the table content if full page is returned
                        var tempDiv = document.createElement('div');
                        tempDiv.innerHTML = html;
                        var tableContent = tempDiv.querySelector('#rk-dynamic-table-content') || tempDiv.querySelector('.rk-table-wrapper') || tempDiv;
                        rankingContent.innerHTML = tableContent.innerHTML || html;
                        if (window.htmx) {
                            htmx.process(rankingContent);
                        }
                        rankingContent.dataset.loaded = 'true';
                        // Debug: Check if hierarchy data is present
                        var hierarchyElements = rankingContent.querySelectorAll('.rk-group-container');
                        console.log('Ranking hierarchy elements found:', hierarchyElements.length);
                    })
                    .catch(error => {
                        console.error('Error loading ranking page:', error);
                        rankingContent.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545;">Fehler beim Laden der Ranking-Seite. Bitte versuchen Sie es erneut.</div>';
                    });
            }
            
            // Load ranking page content via fetch
            var rankingContent = document.getElementById('ranking-content');
            if (rankingContent && !rankingContent.dataset.loaded) {
                // Build ranking URL with current language prefix
                var currentPath = window.location.pathname;
                var langPrefix = '';
                // Extract language prefix (e.g., /de/ or /en/)
                var langMatch = currentPath.match(/^\/([a-z]{2})\//);
                if (langMatch) {
                    langPrefix = '/' + langMatch[1] + '/';
                } else {
                    // Default to German if no prefix found
                    langPrefix = '/de/';
                }
                
                var rankingUrl = langPrefix + 'ranking/';
                // Get current group from selector
                var groupSelector = document.getElementById('group-selector');
                if (groupSelector && groupSelector.value) {
                    rankingUrl += "?group_id=" + encodeURIComponent(groupSelector.value);
                } else {
                    {% if group_id %}
                    rankingUrl += "?group_id={{ group_id|urlencode }}";
                    {% elif group_name %}
                    rankingUrl += "?group_name={{ group_name|urlencode }}";
                    {% endif %}
                }
                
                // Fetch the ranking page content
                fetch(rankingUrl, {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'HX-Request': 'true'
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP error! status: ' + response.status);
                    }
                    return response.text();
                })
                .then(html => {
                    // Parse the HTML and extract the body content
                    var parser = new DOMParser();
                    var doc = parser.parseFromString(html, 'text/html');
                    
                    // Extract the main content from the ranking page
                    var rankingBody = doc.body;
                    if (rankingBody) {
                        // Clone all child nodes
                        while (rankingContent.firstChild) {
                            rankingContent.removeChild(rankingContent.firstChild);
                        }
                        Array.from(rankingBody.children).forEach(function(child) {
                            rankingContent.appendChild(child.cloneNode(true));
                        });
                        
                        // Process HTMX on the new content
                        if (typeof htmx !== 'undefined') {
                            htmx.process(rankingContent);
                        }
                        
                        // Mark as loaded
                        rankingContent.dataset.loaded = 'true';
                    }
                })
                .catch(error => {
                    console.error('Error loading ranking page:', error);
                    rankingContent.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545;">Fehler beim Laden der Ranking-Seite. Bitte versuchen Sie es erneut.</div>';
                });
            }
        }
        
        // Sidebar toggle function
        function toggleSidebar() {
            var sidebar = document.getElementById('glassmorphism-sidebar');
            if (sidebar) {
                sidebar.classList.toggle('collapsed');
            }
        }
        
        // Update sidebar dropdown functions to work with new structure
        function toggleTrackDropdown(event) {
            if (event) {
                event.stopPropagation();
            }
            var dropdown = document.getElementById('track-selector-dropdown');
            if (!dropdown) return;
            dropdown.classList.toggle('open');
            
            // Close group dropdown if open
            var groupDropdown = document.getElementById('group-selector-dropdown');
            if (groupDropdown) {
                groupDropdown.classList.remove('open');
            }
        }
        
        function toggleGroupDropdown(event) {
            if (event) {
                event.stopPropagation();
            }
            var dropdown = document.getElementById('group-selector-dropdown');
            if (!dropdown) return;
            dropdown.classList.toggle('open');
            
            // Close track dropdown if open
            var trackDropdown = document.getElementById('track-selector-dropdown');
            if (trackDropdown) {
                trackDropdown.classList.remove('open');
            }
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            var trackDropdown = document.getElementById('track-selector-dropdown');
            var groupDropdown = document.getElementById('group-selector-dropdown');
            var trackButton = document.getElementById('track-selector-button');
            var groupButton = document.getElementById('group-selector-button');
            
            if (trackDropdown && trackButton && !trackDropdown.contains(event.target) && !trackButton.contains(event.target)) {
                trackDropdown.classList.remove('open');
            }
            if (groupDropdown && groupButton && !groupDropdown.contains(event.target) && !groupButton.contains(event.target)) {
                groupDropdown.classList.remove('open');
            }
        });
        
        // Information Hub Modal functions
        function openInfoHubModal() {
            var overlay = document.getElementById('info-hub-modal-overlay');
            if (overlay) {
                overlay.classList.add('show');
                document.body.style.overflow = 'hidden';
            }
        }
        
        function closeInfoHubModal(event) {
            if (event && event.target !== event.currentTarget) {
                return; // Don't close if clicking inside modal
            }
            var overlay = document.getElementById('info-hub-modal-overlay');
            if (overlay) {
                overlay.classList.remove('show');
                document.body.style.overflow = '';
            }
        }
        
        function toggleInfoHubFAQItem(header) {
            var item = header.closest('.info-hub-accordion-item');
            if (item) {
                item.classList.toggle('open');
            }
        }
        
        // Activity Toast System (replaces ticker)
        var activityToastQueue = [];
        var maxToasts = 5;
        var toastDuration = 5000; // 5 seconds
        
        function createActivityToast(cyclist) {
            var container = document.getElementById('activity-toast-container');
            if (!container) return;
            
            // Remove oldest toast if at max
            if (container.children.length >= maxToasts) {
                var oldestToast = container.firstElementChild;
                if (oldestToast) {
                    oldestToast.classList.add('fade-out');
                    setTimeout(function() {
                        if (oldestToast.parentNode) {
                            oldestToast.remove();
                        }
                    }, 300);
                }
            }
            
            var toast = document.createElement('div');
            toast.className = 'activity-toast';
            
            var icon = '🚴';
            var title = textCurrentlyCycling;
            var body = cyclist.user_id;
            if (cyclist.group_short_name) {
                body += ' (' + cyclist.group_short_name + ')';
            }
            body += ' - <span class="activity-toast-distance">' + formatNumberDE(cyclist.session_km, 2) + ' km</span>';
            
            toast.innerHTML = 
                '<div class="activity-toast-header">' +
                '<span class="activity-toast-icon">' + icon + '</span>' +
                '<span class="activity-toast-title">' + title + '</span>' +
                '</div>' +
                '<div class="activity-toast-body">' + body + '</div>';
            
            container.appendChild(toast);
            
            // Auto-remove after duration
            setTimeout(function() {
                if (toast.parentNode) {
                    toast.classList.add('fade-out');
                    setTimeout(function() {
                        if (toast.parentNode) {
                            toast.remove();
                        }
                    }, 300);
                }
            }, toastDuration);
        }
        
        // Monitor ticker updates and create Activity Toasts
        var lastTickerData = {};
        var lastTickerUpdate = null;
        
        function processTickerUpdate() {
            var tickerContent = document.getElementById('ticker-target');
            if (!tickerContent) return;
            
            var tickerItems = tickerContent.querySelectorAll('.ticker-item');
            var currentTime = Date.now();
            
            // Only process if enough time has passed since last update (avoid duplicates)
            if (lastTickerUpdate && (currentTime - lastTickerUpdate) < 1000) {
                return;
            }
            lastTickerUpdate = currentTime;
            
            // Extract cyclist data from ticker items
            tickerItems.forEach(function(item) {
                var text = item.textContent.trim();
                if (text && !text.includes('Warten auf Radler') && text.includes('km')) {
                    // Parse cyclist info from ticker format: "● USER_ID (GROUP) 🚴 X.XXX km"
                    var parts = text.split('●');
                    if (parts.length > 1) {
                        var cyclistText = parts[1].trim();
                        
                        // Extract user ID (text before first parenthesis or emoji)
                        var userMatch = cyclistText.match(/^([^\s(🚴]+)/);
                        if (!userMatch) return;
                        
                        // Extract group name (in parentheses)
                        var groupMatch = cyclistText.match(/\(([^)]+)\)/);
                        
                        // Extract km value (number before "km")
                        // Handle German format: "1.234,56 km" -> 1234.56
                        var kmMatch = cyclistText.match(/([\d.,]+)\s*km/i);
                        if (!kmMatch) return;
                        
                        var kmStr = kmMatch[1];
                        // German format: dots are thousands, comma is decimal
                        // Remove dots (thousands separators) and replace comma with dot
                        var sessionKm = parseFloat(kmStr.replace(/\./g, '').replace(',', '.'));
                        
                        var cyclist = {
                            user_id: userMatch[1].trim(),
                            session_km: sessionKm,
                            group_short_name: groupMatch ? groupMatch[1].trim() : null
                        };
                        
                        // Create unique key for this cyclist
                        var key = cyclist.user_id + '|' + (cyclist.group_short_name || '');
                        
                        // Only show toast if this is new data or km has increased significantly
                        var lastKm = lastTickerData[key];
                        if (!lastKm || Math.abs(cyclist.session_km - lastKm) > 0.1) {
                            createActivityToast(cyclist);
                            lastTickerData[key] = cyclist.session_km;
                        }
                    }
                }
            });
        }
        
        // Monitor HTMX updates
        document.addEventListener('htmx:afterSwap', function(event) {
            if (event.detail.target.id === 'ticker-target') {
                setTimeout(processTickerUpdate, 100); // Small delay to ensure DOM is updated
            }
        });
        
        // Also check on initial load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(processTickerUpdate, 1000);
            });
        } else {
            setTimeout(processTickerUpdate, 1000);
        }
        
        // Close Information Hub modal on Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeInfoHubModal();
            }
        });

        // ============================================
        // Layer Control Functions (Map View)
        // ============================================
        
        // Toggle layer control visibility
        function toggleLayerControl() {
            var layerControl = document.getElementById('floating-layer-control');
            if (layerControl) {
                layerControl.classList.toggle('expanded');
                
                // Ensure groups section is always hidden in map view
                var mapSection = document.getElementById('section-map');
                var rankingSection = document.getElementById('section-ranking');
                var isMapView = mapSection && !mapSection.classList.contains('hidden');
                
                if (isMapView) {
                    var groupsSection = document.getElementById('layer-control-groups-section');
                    if (groupsSection) {
                        groupsSection.style.display = 'none';
                    }
                }
            }
        }
        
        // Store filter state in sessionStorage for persistence
        function saveFilterState() {
            var trackCheckboxes = document.querySelectorAll('.layer-track-toggle, .track-checkbox');
            var groupCheckboxes = document.querySelectorAll('.layer-group-toggle');
            var selectedTracks = Array.from(trackCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
            var selectedGroups = Array.from(groupCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
            
            sessionStorage.setItem('selectedTracks', JSON.stringify(selectedTracks));
            sessionStorage.setItem('selectedGroups', JSON.stringify(selectedGroups));
        }
        
        // Restore filter state from sessionStorage, but prioritize URL parameters
        function restoreFilterState() {
            try {
                // Check URL parameters first - they take priority over sessionStorage
                var urlParams = new URLSearchParams(window.location.search);
                var urlTrackIds = urlParams.get('track_ids');
                
                var trackCheckboxes = document.querySelectorAll('.layer-track-toggle, .track-checkbox');
                var trackAllCheckbox = document.getElementById('layer-track-all') || document.getElementById('track-all');
                
                // If track_ids='none' in URL, uncheck all track checkboxes
                if (urlTrackIds === 'none') {
                    trackCheckboxes.forEach(function(cb) {
                        cb.checked = false;
                        cb.removeAttribute('checked');
                    });
                    if (trackAllCheckbox) {
                        trackAllCheckbox.checked = false;
                        trackAllCheckbox.removeAttribute('checked');
                    }
                } else if (urlTrackIds && urlTrackIds !== 'none') {
                    // If specific track IDs are in URL, only check those
                    var urlTrackIdList = urlTrackIds.split(',').map(function(id) { return id.trim(); });
                    trackCheckboxes.forEach(function(cb) {
                        var isSelected = urlTrackIdList.includes(cb.value);
                        cb.checked = isSelected;
                        if (isSelected) {
                            cb.setAttribute('checked', 'checked');
                        } else {
                            cb.removeAttribute('checked');
                        }
                    });
                    if (trackAllCheckbox) {
                        var allSelected = urlTrackIdList.length === trackCheckboxes.length;
                        trackAllCheckbox.checked = allSelected;
                        if (allSelected) {
                            trackAllCheckbox.setAttribute('checked', 'checked');
                        } else {
                            trackAllCheckbox.removeAttribute('checked');
                        }
                    }
                } else {
                    // No track_ids in URL - restore from sessionStorage or default to all checked
                    var savedTracks = JSON.parse(sessionStorage.getItem('selectedTracks') || '[]');
                    
                    if (savedTracks.length > 0) {
                        trackCheckboxes.forEach(function(cb) {
                            var isSelected = savedTracks.includes(cb.value);
                            cb.checked = isSelected;
                            if (isSelected) {
                                cb.setAttribute('checked', 'checked');
                            } else {
                                cb.removeAttribute('checked');
                            }
                        });
                        if (trackAllCheckbox) {
                            var allSelected = savedTracks.length === trackCheckboxes.length;
                            trackAllCheckbox.checked = allSelected;
                            if (allSelected) {
                                trackAllCheckbox.setAttribute('checked', 'checked');
                            } else {
                                trackAllCheckbox.removeAttribute('checked');
                            }
                        }
                    } else {
                        // No saved state - default to all checked
                        trackCheckboxes.forEach(function(cb) {
                            cb.checked = true;
                            cb.setAttribute('checked', 'checked');
                        });
                        if (trackAllCheckbox) {
                            trackAllCheckbox.checked = true;
                            trackAllCheckbox.setAttribute('checked', 'checked');
                        }
                    }
                }
                
                // Restore group checkboxes (only Layer Control and Filter Bar, no sidebar)
                var savedGroups = JSON.parse(sessionStorage.getItem('selectedGroups') || '[]');
                if (savedGroups.length > 0) {
                    var groupCheckboxes = document.querySelectorAll('.layer-group-toggle');
                    groupCheckboxes.forEach(function(cb) {
                        cb.checked = savedGroups.includes(cb.value);
                    });
                    var groupAllCheckbox = document.getElementById('layer-group-all');
                    if (groupAllCheckbox) {
                        groupAllCheckbox.checked = savedGroups.length === groupCheckboxes.length;
                    }
                }
                
                // Apply track filter after restoring state
                var allCheckbox = document.getElementById('layer-track-all') || document.getElementById('track-all');
                var checkboxes = document.querySelectorAll('.layer-track-toggle, .track-checkbox');
                var selectedTracks = Array.from(checkboxes).filter(cb => cb.checked && cb.value !== 'all');
                var totalCheckboxes = checkboxes.length;
                
                var visibleTrackIds = [];
                if (selectedTracks.length > 0 && selectedTracks.length < totalCheckboxes) {
                    visibleTrackIds = selectedTracks.map(function(cb) { return parseInt(cb.value); });
                } else if ((allCheckbox && allCheckbox.checked) || (totalCheckboxes > 0 && selectedTracks.length >= totalCheckboxes)) {
                    visibleTrackIds = tracks.map(function(t) { return t.id; });
                } else {
                    visibleTrackIds = [];
                }
                
                updateTrackVisibility(visibleTrackIds);
            } catch (e) {
                console.error('Error restoring filter state:', e);
            }
        }
        
        // Layer Control: Handle "All Tracks" toggle
        function handleLayerTrackAllChange(toggle) {
            var trackToggles = document.querySelectorAll('.layer-track-toggle');
            // Explicitly set all track checkboxes to the same state as "All Tracks" checkbox
            trackToggles.forEach(function(t) {
                // Use setAttribute to ensure the change is properly reflected
                if (toggle.checked) {
                    t.setAttribute('checked', 'checked');
                    t.checked = true;
                } else {
                    t.removeAttribute('checked');
                    t.checked = false;
                }
            });
            // Also update sidebar checkboxes if they exist
            var sidebarTracks = document.querySelectorAll('.track-checkbox');
            sidebarTracks.forEach(function(cb) {
                if (toggle.checked) {
                    cb.setAttribute('checked', 'checked');
                    cb.checked = true;
                } else {
                    cb.removeAttribute('checked');
                    cb.checked = false;
                }
            });
            // Also update the "all" checkbox in sidebar if it exists
            var sidebarAll = document.getElementById('track-all');
            if (sidebarAll) {
                if (toggle.checked) {
                    sidebarAll.setAttribute('checked', 'checked');
                    sidebarAll.checked = true;
                } else {
                    sidebarAll.removeAttribute('checked');
                    sidebarAll.checked = false;
                }
            }
            // Save state before applying filter (with empty array if unchecked)
            if (!toggle.checked) {
                // Clear saved tracks when "All" is unchecked
                sessionStorage.setItem('selectedTracks', JSON.stringify([]));
            } else {
                saveFilterState();
            }
            
            // Apply filter after state is saved
            if (toggle.checked) {
                applyTrackFilter(true);
            } else {
                // When "Alle Routen" is unchecked, ensure all individual tracks are unchecked
                // and apply filter to show no tracks
                applyTrackFilter(false);
            }
        }
        
        // Layer Control: Handle individual track toggle
        function handleLayerTrackChange(toggle) {
            var allToggle = document.getElementById('layer-track-all');
            var trackToggles = document.querySelectorAll('.layer-track-toggle');
            
            // Update visual state of the toggle
            if (toggle.checked) {
                toggle.setAttribute('checked', 'checked');
            } else {
                toggle.removeAttribute('checked');
            }
            
            var allChecked = Array.from(trackToggles).every(t => t.checked);
            
            if (allToggle) {
                allToggle.checked = allChecked;
                if (allChecked) {
                    allToggle.setAttribute('checked', 'checked');
                } else {
                    allToggle.removeAttribute('checked');
                }
            }
            // Also update sidebar checkboxes if they exist
            var sidebarAll = document.getElementById('track-all');
            if (sidebarAll) {
                sidebarAll.checked = allChecked;
                if (allChecked) {
                    sidebarAll.setAttribute('checked', 'checked');
                } else {
                    sidebarAll.removeAttribute('checked');
                }
            }
            var sidebarTracks = document.querySelectorAll('.track-checkbox');
            sidebarTracks.forEach(function(cb) {
                if (cb.value === toggle.value) {
                    cb.checked = toggle.checked;
                    if (toggle.checked) {
                        cb.setAttribute('checked', 'checked');
                    } else {
                        cb.removeAttribute('checked');
                    }
                }
            });
            
            // Save state before applying filter
            saveFilterState();
            
            applyTrackFilter(false);
        }
        
        // Layer Control: Handle "All Groups" toggle
        function handleLayerGroupAllChange(toggle) {
            var groupToggles = document.querySelectorAll('.layer-group-toggle');
            groupToggles.forEach(function(t) {
                t.checked = toggle.checked;
            });
            // Sync ranking filter checkboxes with layer control
            if (toggle.checked) {
                applyGroupFilter(true);
            } else {
                applyGroupFilter(false);
            }
            
            // Reload ranking content if ranking view is active
            var rankingSection = document.getElementById('section-ranking');
            if (rankingSection && rankingSection.classList.contains('active')) {
                var rankingContent = document.getElementById('ranking-content');
                if (rankingContent) {
                    rankingContent.dataset.loaded = 'false';
                }
                showRankingView();
            }
            
            saveFilterState();
        }
        
        // Layer Control: Handle individual group toggle
        function handleLayerGroupChange(toggle) {
            var allToggle = document.getElementById('layer-group-all');
            var groupToggles = document.querySelectorAll('.layer-group-toggle');
            var allChecked = Array.from(groupToggles).every(t => t.checked);
            
            if (allToggle) {
                allToggle.checked = allChecked;
            }
            // Sync ranking filter checkboxes with layer control
            applyGroupFilter(false);
            
            // Update ranking filter chips
            updateRankingFilterChips();
            
            // Update ranking filter chips
            updateRankingFilterChips();
            
            // Reload ranking content if ranking view is active
            var rankingSection = document.getElementById('section-ranking');
            if (rankingSection && rankingSection.classList.contains('active')) {
                var rankingContent = document.getElementById('ranking-content');
                if (rankingContent) {
                    rankingContent.dataset.loaded = 'false';
                }
                showRankingView();
            }
            
            saveFilterState();
        }
        
        // Show/hide layer control based on view
        function showMapView() {
            var mapSection = document.getElementById('section-map');
            var rankingSection = document.getElementById('section-ranking');
            
            // Update button states
            document.getElementById('btn-show-map').classList.add('active');
            document.getElementById('btn-show-ranking').classList.remove('active');
            
            // Show map, hide ranking with transitions
            rankingSection.classList.remove('active');
            setTimeout(function() {
                mapSection.classList.remove('hidden');
            }, 50);
            
            // Show layer control (with tracks section visible, groups section hidden)
            var layerControl = document.getElementById('floating-layer-control');
            if (layerControl) {
                layerControl.style.display = 'block';
            }
            var tracksSection = document.getElementById('layer-control-tracks-section');
            if (tracksSection) {
                tracksSection.style.display = 'block';
            }
            var groupsSection = document.getElementById('layer-control-groups-section');
            if (groupsSection) {
                groupsSection.style.display = 'none';
            }
            
            // Show track selector, hide group selector in sidebar
            document.getElementById('track-selector-section').style.display = 'block';
            document.getElementById('group-selector-section').style.display = 'none';
            
            // Update Champions Overlay when switching to map view
            // Use setTimeout to ensure map is fully visible
            setTimeout(function() {
                if (window.allFinishAvatars) {
                    updateChampionsOverlay(window.allFinishAvatars);
                }
            }, 100);
            
            // Invalidate map size when switching back to map
            if (map) {
                setTimeout(function() {
                    map.invalidateSize();
                }, 300);
            }
        }

        function showRankingView() {
            var mapSection = document.getElementById('section-map');
            var rankingSection = document.getElementById('section-ranking');
            
            // Update button states
            document.getElementById('btn-show-map').classList.remove('active');
            document.getElementById('btn-show-ranking').classList.add('active');
            
            // Ensure white background is set immediately
            if (rankingSection) {
                rankingSection.style.background = '#ffffff';
            }
            var rankingContent = document.getElementById('ranking-content');
            if (rankingContent) {
                rankingContent.style.background = '#ffffff';
            }
            
            // Hide map, show ranking with transitions
            mapSection.classList.add('hidden');
            setTimeout(function() {
                rankingSection.classList.add('active');
            }, 50);
            
            // Hide Champions Overlay in ranking view
            var championsOverlay = document.getElementById('champions-overlay');
            if (championsOverlay) {
                championsOverlay.classList.add('hidden');
            }
            
            // Hide layer control in ranking view (filter is handled by filter bar)
            var layerControl = document.getElementById('floating-layer-control');
            if (layerControl) {
                layerControl.style.display = 'none';
            }
            
            // Hide sidebar toggle and sidebar in ranking view (using new filter bar instead)
            var sidebarToggle = document.getElementById('sidebar-toggle');
            if (sidebarToggle) {
                sidebarToggle.style.display = 'none';
            }
            var sidebar = document.getElementById('glassmorphism-sidebar');
            if (sidebar) {
                sidebar.style.display = 'none';
            }
            
            // Update ranking filter chips based on layer control selection
            // Use a small delay to ensure checkboxes are available
            setTimeout(function() {
                updateRankingFilterChips();
            }, 50);
            
            // Load ranking content with current group filter from layer control
            // Always load content when switching to ranking view
            var rankingContent = document.getElementById('ranking-content');
            if (rankingContent) {
                // Build ranking URL with current group filter from layer control
                var langPrefix = '';
                var pathParts = window.location.pathname.split('/');
                if (pathParts.length > 1 && pathParts[1].length === 2) {
                    langPrefix = '/' + pathParts[1] + '/';
                }
                var rankingUrl = langPrefix + 'ranking/';
                
                // Get current group selection from layer control (map filter)
                var groupAllCheckbox = document.getElementById('layer-group-all');
                var groupCheckboxes = document.querySelectorAll('.layer-group-toggle:checked');
                var selectedGroups = Array.from(groupCheckboxes).filter(cb => cb.value !== 'all').map(cb => cb.value);
                var totalCheckboxes = document.querySelectorAll('.layer-group-toggle').length;
                
                var urlParams = new URLSearchParams();
                // Check if all groups are selected
                var allGroupsSelected = (groupAllCheckbox && groupAllCheckbox.checked) || 
                                       (totalCheckboxes > 0 && selectedGroups.length >= totalCheckboxes);
                
                if (allGroupsSelected) {
                    // All groups selected, no filter needed (backend shows all by default)
                } else if (selectedGroups.length > 0) {
                    // Some (but not all) groups selected - add selected group IDs
                    var groupIds = selectedGroups.join(',');
                    urlParams.set('group_id', groupIds);
                } else {
                    // No groups selected, show none
                    urlParams.set('group_id', 'none');
                }
                // Add refresh_table parameter to get only table content
                urlParams.set('refresh_table', 'true');
                if (urlParams.toString()) {
                    rankingUrl += '?' + urlParams.toString();
                }
                
                console.log('Loading ranking content from URL:', rankingUrl);
                
                // Load ranking content
                fetch(rankingUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'text/html',
                        'X-Requested-With': 'XMLHttpRequest',
                        'HX-Request': 'true'
                    },
                    credentials: 'same-origin'
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok: ' + response.status);
                    }
                    return response.text();
                })
                .then(html => {
                    console.log('Ranking content loaded in showRankingView, length:', html.length);
                    console.log('Ranking content preview:', html.substring(0, 200));
                    rankingContent.innerHTML = html;
                    if (window.htmx) {
                        htmx.process(rankingContent);
                    }
                    rankingContent.dataset.loaded = 'true';
                    // Debug: Check if hierarchy data is present
                    var hierarchyElements = rankingContent.querySelectorAll('.rk-group-container');
                    console.log('Ranking hierarchy elements found:', hierarchyElements.length);
                    if (hierarchyElements.length === 0) {
                        console.warn('No hierarchy elements found in ranking content!');
                    }
                    // Update filter chips after content is loaded
                    // Use a small delay to ensure DOM is fully updated
                    setTimeout(function() {
                        updateRankingFilterChips();
                    }, 100);
                })
                .catch(error => {
                    console.error('Error loading ranking:', error);
                    rankingContent.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545;">Fehler beim Laden der Ranking-Seite: ' + error.message + '</div>';
                    rankingContent.dataset.loaded = 'false'; // Reset on error so it can be retried
                });
            }
        }
        
        // ============================================
        // Ranking Filter Bar - Hierarchical Chips
        // ============================================
        
        // Store expanded state for top-level groups
        var expandedTopGroups = new Set();
        
        // Store all TOP groups from template context (always available, independent of route filtering)
        var allTopGroupsData = [
            {% for group in all_groups %}
            {
                id: '{{ group.id }}',
                name: '{% trans group.name %}',
                color: '{% if group.color %}{{ group.color }}{% else %}#6b7280{% endif %}'
            }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ];
        
        // Update ranking filter chips based on layer control selection
        function updateRankingFilterChips() {
            var container = document.getElementById('filter-chips-container');
            if (!container) return;
            
            // Use allTopGroupsData as the source of truth for available groups
            // This ensures all chips are always visible, regardless of route filtering
            if (allTopGroupsData.length === 0) {
                console.warn('No top groups data available, preserving existing chips');
                return;
            }
            
            // Get current checkbox states from layer control (for checked status)
            var groupCheckboxes = document.querySelectorAll('.layer-group-toggle');
            var checkboxStates = {};
            groupCheckboxes.forEach(function(cb) {
                if (cb.value !== 'all') {
                    checkboxStates[cb.value] = {
                        checked: cb.checked,
                        color: cb.getAttribute('data-color') || '#6b7280'
                    };
                }
            });
            
            // Build allGroups array from allTopGroupsData, using checkbox states if available
            var allGroups = allTopGroupsData.map(function(groupData) {
                var checkboxState = checkboxStates[groupData.id];
                return {
                    id: groupData.id,
                    name: groupData.name,
                    checked: checkboxState ? checkboxState.checked : false,
                    color: checkboxState ? checkboxState.color : groupData.color
                };
            });
            
            container.innerHTML = '';
            
            // Create chips for ALL top-level groups (both active and inactive)
            allGroups.forEach(function(group) {
                var chip = document.createElement('div');
                chip.className = 'filter-chip';
                chip.setAttribute('data-group-id', group.id);
                chip.setAttribute('data-group-checked', group.checked ? 'true' : 'false');
                
                if (group.checked) {
                    // Active chip: use group color
                    chip.classList.add('active');
                    chip.style.setProperty('--chip-color', group.color);
                    chip.style.backgroundColor = group.color;
                    chip.style.color = 'white';
                    chip.style.borderColor = group.color;
                } else {
                    // Inactive chip: grayed out
                    chip.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
                    chip.style.color = '#666';
                    chip.style.borderColor = 'rgba(0, 0, 0, 0.2)';
                    chip.style.opacity = '0.6';
                }
                
                var chipContent = document.createElement('span');
                chipContent.textContent = group.name;
                chip.appendChild(chipContent);
                
                // Add click handler: if active, toggle sub-groups; if inactive, activate group
                chip.addEventListener('click', function(e) {
                    if (e.target.classList.contains('chip-close')) return;
                    if (chip.classList.contains('active')) {
                        // Active chip: toggle sub-groups (drill-down)
                        toggleSubGroups(group.id, chip);
                    } else {
                        // Inactive chip: activate group
                        toggleGroupChip(group.id, chip);
                    }
                });
                
                // Add close/activate button
                var actionBtn = document.createElement('span');
                actionBtn.className = 'chip-close';
                actionBtn.textContent = group.checked ? '×' : '+';
                actionBtn.title = group.checked ? '{% trans "Gruppe deaktivieren" %}' : '{% trans "Gruppe aktivieren" %}';
                actionBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleGroupChip(group.id, chip);
                });
                chip.appendChild(actionBtn);
                
                container.appendChild(chip);
                
                // If this group was expanded and is active, show sub-groups
                if (expandedTopGroups.has(group.id) && group.checked) {
                    showSubGroups(group.id, container, chip);
                }
            });
            
            // Make container scrollable if more than 15 chips
            var totalChips = container.querySelectorAll('.filter-chip').length;
            if (totalChips > 15) {
                container.classList.add('scrollable');
            } else {
                container.classList.remove('scrollable');
            }
        }
        
        // Toggle sub-groups for a top-level group (only if group is active)
        function toggleSubGroups(groupId, topChip) {
            // Only allow drill-down if chip is active
            if (!topChip.classList.contains('active')) {
                return;
            }
            
            if (expandedTopGroups.has(groupId)) {
                // Collapse: remove sub-group row
                var subRow = document.getElementById('sub-groups-' + groupId);
                if (subRow) {
                    subRow.remove();
                }
                expandedTopGroups.delete(groupId);
            } else {
                // Expand: show sub-group row
                var container = document.getElementById('filter-chips-container');
                showSubGroups(groupId, container, topChip);
                expandedTopGroups.add(groupId);
            }
        }
        
        // Show sub-groups for a top-level group
        function showSubGroups(groupId, container, topChip) {
            // Remove existing sub-group row if any
            var existingRow = document.getElementById('sub-groups-' + groupId);
            if (existingRow) {
                existingRow.remove();
            }
            
            // Create sub-group row
            var subRow = document.createElement('div');
            subRow.id = 'sub-groups-' + groupId;
            subRow.className = 'filter-sub-groups-row';
            subRow.style.width = '100%';
            subRow.style.display = 'flex';
            subRow.style.flexWrap = 'wrap';
            subRow.style.gap = '6px';
            subRow.style.marginTop = '8px';
            subRow.style.paddingLeft = '12px';
            subRow.style.borderLeft = '3px solid ' + (topChip.style.backgroundColor || '#6b7280');
            
            // Get sub-groups from ranking content (if loaded)
            var subGroups = [];
            var rankingContent = document.getElementById('ranking-content');
            if (rankingContent) {
                // Find the group container for this top-level group by matching group name
                var topGroupName = topChip.querySelector('span').textContent.trim();
                var groupContainers = rankingContent.querySelectorAll('.rk-group-container');
                
                groupContainers.forEach(function(container) {
                    var groupHeader = container.querySelector('.rk-group-header');
                    if (groupHeader) {
                        var headerText = groupHeader.textContent.trim();
                        // Match by group name (remove emoji and extra text, compare names)
                        var headerName = headerText.replace(/^[^\w]*/, '').replace(/\s*km.*$/, '').trim();
                        var topName = topGroupName.trim();
                        
                        if (headerName === topName || headerText.includes(topName)) {
                            // Found matching top-level group container
                            // Sub-groups are in .rk-group-content as divs with class .rk-subgroup-container
                            var groupContent = container.querySelector('.rk-group-content');
                            if (groupContent) {
                                // Sub-groups are divs with .rk-subgroup-container class
                                var subGroupDivs = groupContent.querySelectorAll('.rk-subgroup-container');
                                subGroupDivs.forEach(function(subDiv) {
                                    // Get real sub-group ID from data-group-id attribute
                                    var subGroupId = subDiv.getAttribute('data-group-id');
                                    if (!subGroupId) return; // Skip if no ID
                                    
                                    // Extract sub-group name from the div (look for text starting with 👥)
                                    var subGroupText = subDiv.textContent.trim();
                                    var subGroupNameMatch = subGroupText.match(/👥\s*(.+?)(?:\s+\d|$)/);
                                    if (subGroupNameMatch) {
                                        var subGroupName = subGroupNameMatch[1].trim();
                                        subGroups.push({
                                            id: subGroupId, // Use real group ID
                                            name: subGroupName,
                                            color: topChip.style.backgroundColor || '#6b7280'
                                        });
                                    }
                                });
                            }
                        }
                    }
                });
            }
            
            // If no sub-groups found, show message
            if (subGroups.length === 0) {
                var noSubMsg = document.createElement('div');
                noSubMsg.className = 'filter-chip sub-group';
                noSubMsg.style.opacity = '0.6';
                noSubMsg.textContent = '{% trans "Keine Untergruppen" %}';
                subRow.appendChild(noSubMsg);
            } else {
                // Get current selected groups from URL or Layer Control
                var urlParams = new URLSearchParams(window.location.search);
                var currentGroupIds = urlParams.get('group_id');
                var selectedGroupIds = [];
                var parentIsActive = topChip.classList.contains('active');
                
                // Parse current group IDs
                if (currentGroupIds && currentGroupIds !== 'none') {
                    selectedGroupIds = currentGroupIds.split(',').map(function(id) { return id.trim(); });
                } else {
                    // If no group_id in URL, get from Layer Control checkboxes
                    var checkboxes = document.querySelectorAll('.layer-group-toggle:checked');
                    selectedGroupIds = Array.from(checkboxes).map(function(cb) { return cb.value; });
                    // If parent is active and no explicit filter, sub-groups are active by default
                    if (parentIsActive && currentGroupIds !== 'none') {
                        // Parent is active, so sub-groups are implicitly active
                        // Don't add them to selectedGroupIds, but mark them as selected
                    }
                }
                
                subGroups.forEach(function(subGroup) {
                    // Check if sub-group is currently selected
                    // If parent is active and no explicit filter (no group_id in URL or group_id is null), 
                    // sub-groups are active by default
                    var hasExplicitFilter = currentGroupIds && currentGroupIds !== 'none' && currentGroupIds !== null;
                    var isSelected = selectedGroupIds.includes(subGroup.id) || 
                                    (parentIsActive && !hasExplicitFilter);
                    
                    var subChip = document.createElement('div');
                    subChip.className = 'filter-chip sub-group' + (isSelected ? ' active' : '');
                    subChip.setAttribute('data-group-id', subGroup.id);
                    subChip.setAttribute('data-parent-id', groupId);
                    subChip.setAttribute('data-group-checked', isSelected ? 'true' : 'false');
                    
                    var chipColor = subGroup.color || topChip.style.backgroundColor || '#6b7280';
                    subChip.style.setProperty('--chip-color', chipColor);
                    
                    if (isSelected) {
                        // Active state
                        subChip.style.backgroundColor = chipColor;
                        subChip.style.color = 'white';
                        subChip.style.borderColor = chipColor;
                        subChip.style.opacity = '1';
                    } else {
                        // Inactive state
                        subChip.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
                        subChip.style.color = '#666';
                        subChip.style.borderColor = 'rgba(0, 0, 0, 0.2)';
                        subChip.style.opacity = '0.6';
                    }
                    
                    var subChipContent = document.createElement('span');
                    subChipContent.textContent = subGroup.name;
                    subChip.appendChild(subChipContent);
                    
                    // Add click handler for sub-chip: toggle activation
                    subChip.addEventListener('click', function(e) {
                        if (e.target.classList.contains('chip-close')) return;
                        toggleSubGroupChip(subGroup.id, subChip);
                    });
                    
                    var subCloseBtn = document.createElement('span');
                    subCloseBtn.className = 'chip-close';
                    subCloseBtn.textContent = isSelected ? '×' : '+';
                    subCloseBtn.title = isSelected ? '{% trans "Untergruppe deaktivieren" %}' : '{% trans "Untergruppe aktivieren" %}';
                    subCloseBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        toggleSubGroupChip(subGroup.id, subChip);
                    });
                    subChip.appendChild(subCloseBtn);
                    
                    subRow.appendChild(subChip);
                });
            }
            
            // Insert sub-row after top chip
            topChip.parentNode.insertBefore(subRow, topChip.nextSibling);
        }
        
        // Toggle group chip activation (activate if inactive, deactivate if active)
        function toggleGroupChip(groupId, chipElement) {
            var checkbox = document.getElementById('layer-group-' + groupId);
            if (checkbox) {
                var isCurrentlyChecked = checkbox.checked;
                checkbox.checked = !isCurrentlyChecked;
                
                // Update chip visual state
                if (checkbox.checked) {
                    // Activate chip
                    chipElement.classList.add('active');
                    var groupColor = checkbox.getAttribute('data-color') || '#6b7280';
                    chipElement.style.setProperty('--chip-color', groupColor);
                    chipElement.style.backgroundColor = groupColor;
                    chipElement.style.color = 'white';
                    chipElement.style.borderColor = groupColor;
                    chipElement.style.opacity = '1';
                    chipElement.setAttribute('data-group-checked', 'true');
                    var actionBtn = chipElement.querySelector('.chip-close');
                    if (actionBtn) {
                        actionBtn.textContent = '×';
                        actionBtn.title = '{% trans "Gruppe deaktivieren" %}';
                    }
                } else {
                    // Deactivate chip
                    chipElement.classList.remove('active');
                    chipElement.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
                    chipElement.style.color = '#666';
                    chipElement.style.borderColor = 'rgba(0, 0, 0, 0.2)';
                    chipElement.style.opacity = '0.6';
                    chipElement.setAttribute('data-group-checked', 'false');
                    var actionBtn = chipElement.querySelector('.chip-close');
                    if (actionBtn) {
                        actionBtn.textContent = '+';
                        actionBtn.title = '{% trans "Gruppe aktivieren" %}';
                    }
                    // Remove sub-groups if expanded
                    var subRow = document.getElementById('sub-groups-' + groupId);
                    if (subRow) {
                        subRow.remove();
                    }
                    expandedTopGroups.delete(groupId);
                }
                
                // Update "All Groups" checkbox if needed
                var allCheckbox = document.getElementById('layer-group-all');
                var groupCheckboxes = document.querySelectorAll('.layer-group-toggle');
                var allChecked = Array.from(groupCheckboxes).every(function(cb) { return cb.checked; });
                if (allCheckbox) {
                    allCheckbox.checked = allChecked;
                }
                
                // Trigger change to update filter
                handleLayerGroupChange(checkbox);
            }
        }
        
        // Remove a group chip (legacy function - now uses toggleGroupChip)
        function removeGroupChip(groupId) {
            var chip = document.querySelector('[data-group-id="' + groupId + '"]');
            if (chip) {
                toggleGroupChip(groupId, chip);
            }
        }
        
        // Toggle sub-group chip activation (activate if inactive, deactivate if active)
        function toggleSubGroupChip(subGroupId, chipElement) {
            // Get current selected groups from URL or Layer Control
            var urlParams = new URLSearchParams(window.location.search);
            var currentGroupIds = urlParams.get('group_id');
            var selectedGroupIds = [];
            var parentId = chipElement.getAttribute('data-parent-id');
            var parentChip = document.querySelector('[data-group-id="' + parentId + '"]');
            var parentIsActive = parentChip && parentChip.classList.contains('active');
            
            // Parse current group IDs
            if (currentGroupIds && currentGroupIds !== 'none') {
                selectedGroupIds = currentGroupIds.split(',').map(function(id) { return id.trim(); });
            } else {
                // If no group_id in URL, get from Layer Control checkboxes
                var checkboxes = document.querySelectorAll('.layer-group-toggle:checked');
                selectedGroupIds = Array.from(checkboxes).map(function(cb) { return cb.value; });
            }
            
            // Check if sub-group is currently selected
            // If parent is active and no explicit filter, sub-groups are active by default
            var hasExplicitFilter = currentGroupIds && currentGroupIds !== 'none' && currentGroupIds !== null;
            var isCurrentlySelected = selectedGroupIds.includes(subGroupId) || 
                                    (parentIsActive && !hasExplicitFilter);
            
            if (isCurrentlySelected) {
                // Deactivate: remove from selected groups
                selectedGroupIds = selectedGroupIds.filter(function(id) { return id !== subGroupId; });
                
                // If no explicit filter was present before, we need to include all active TOP groups
                // and all other active sub-groups (except the one being deactivated)
                if (!hasExplicitFilter && parentIsActive) {
                    // Get all active TOP groups from Layer Control
                    var activeTopGroups = Array.from(document.querySelectorAll('.layer-group-toggle:checked'))
                        .map(function(cb) { return cb.value; });
                    // Add all active TOP groups to selectedGroupIds if not already present
                    activeTopGroups.forEach(function(topGroupId) {
                        if (!selectedGroupIds.includes(topGroupId)) {
                            selectedGroupIds.push(topGroupId);
                        }
                    });
                    // Get all other active sub-groups from the same parent (except the one being deactivated)
                    var subGroupChips = document.querySelectorAll('[data-parent-id="' + parentId + '"].filter-chip.sub-group.active');
                    subGroupChips.forEach(function(chip) {
                        var otherSubGroupId = chip.getAttribute('data-group-id');
                        if (otherSubGroupId && otherSubGroupId !== subGroupId && !selectedGroupIds.includes(otherSubGroupId)) {
                            selectedGroupIds.push(otherSubGroupId);
                        }
                    });
                }
                
                // Update chip visual state
                chipElement.classList.remove('active');
                chipElement.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
                chipElement.style.color = '#666';
                chipElement.style.borderColor = 'rgba(0, 0, 0, 0.2)';
                chipElement.style.opacity = '0.6';
                chipElement.setAttribute('data-group-checked', 'false');
                var actionBtn = chipElement.querySelector('.chip-close');
                if (actionBtn) {
                    actionBtn.textContent = '+';
                    actionBtn.title = '{% trans "Untergruppe aktivieren" %}';
                }
            } else {
                // Activate: add to selected groups
                if (!selectedGroupIds.includes(subGroupId)) {
                    selectedGroupIds.push(subGroupId);
                }
                // Update chip visual state
                chipElement.classList.add('active');
                var chipColor = parentChip ? (parentChip.style.backgroundColor || '#6b7280') : '#6b7280';
                chipElement.style.setProperty('--chip-color', chipColor);
                chipElement.style.backgroundColor = chipColor;
                chipElement.style.color = 'white';
                chipElement.style.borderColor = chipColor;
                chipElement.style.opacity = '1';
                chipElement.setAttribute('data-group-checked', 'true');
                var actionBtn = chipElement.querySelector('.chip-close');
                if (actionBtn) {
                    actionBtn.textContent = '×';
                    actionBtn.title = '{% trans "Untergruppe deaktivieren" %}';
                }
            }
            
            // Update URL with new group IDs
            var newUrlParams = new URLSearchParams(window.location.search);
            if (selectedGroupIds.length === 0) {
                newUrlParams.set('group_id', 'none');
            } else {
                // Also include parent group if not already included
                if (parentId && !selectedGroupIds.includes(parentId)) {
                    selectedGroupIds.push(parentId);
                }
                // If no explicit filter was present before, we need to include all active TOP groups
                if (!hasExplicitFilter && parentIsActive) {
                    // Get all active TOP groups from Layer Control
                    var activeTopGroups = Array.from(document.querySelectorAll('.layer-group-toggle:checked'))
                        .map(function(cb) { return cb.value; });
                    // Add all active TOP groups to selectedGroupIds if not already present
                    activeTopGroups.forEach(function(topGroupId) {
                        if (!selectedGroupIds.includes(topGroupId)) {
                            selectedGroupIds.push(topGroupId);
                        }
                    });
                }
                newUrlParams.set('group_id', selectedGroupIds.join(','));
            }
            
            // Update browser URL without reloading the page
            var newUrl = window.location.pathname + '?' + newUrlParams.toString();
            window.history.pushState({}, '', newUrl);
            
            // Save filter state
            saveFilterState();
            
            // Reload ranking content using HTMX if available, otherwise fetch
            var rankingContent = document.getElementById('ranking-content');
            if (rankingContent) {
                rankingContent.dataset.loaded = 'false';
                var rankingUrl = '{% url "ranking:ranking_page" %}?' + newUrlParams.toString() + '&refresh_table=true';
                
                // Try HTMX first
                if (typeof htmx !== 'undefined' && htmx.process) {
                    htmx.ajax('GET', rankingUrl, {
                        target: '#ranking-content',
                        swap: 'innerHTML'
                    }).then(function() {
                        rankingContent.dataset.loaded = 'true';
                        // Update sub-group chips after reload
                        updateRankingFilterChips();
                    });
                } else {
                    // Fallback to fetch
                    fetch(rankingUrl, {
                        headers: {
                            'HX-Request': 'true'
                        }
                    })
                    .then(function(response) { return response.text(); })
                    .then(function(html) {
                        rankingContent.innerHTML = html;
                        rankingContent.dataset.loaded = 'true';
                        // Update sub-group chips after reload
                        updateRankingFilterChips();
                    })
                    .catch(function(error) {
                        console.error('Error reloading ranking:', error);
                    });
                }
            }
        }
        
        // Initialize: Restore filter state and set initial layer control visibility
        document.addEventListener('DOMContentLoaded', function() {
            restoreFilterState();
            
            // Check if we're in map view or ranking view
            var mapSection = document.getElementById('section-map');
            var rankingSection = document.getElementById('section-ranking');
            var isMapView = !mapSection.classList.contains('hidden');
            var isRankingView = rankingSection && rankingSection.classList.contains('active');
            
            // Hide groups section in map view (always hidden in map view)
            var groupsSection = document.getElementById('layer-control-groups-section');
            if (groupsSection) {
                if (isMapView) {
                    groupsSection.style.display = 'none';
                } else if (isRankingView) {
                    // In ranking view, layer control is hidden anyway, but ensure groups section is hidden
                    groupsSection.style.display = 'none';
                } else {
                    // Default: hide groups section
                    groupsSection.style.display = 'none';
                }
            }
            
            // Show tracks section in map view initially
            var tracksSection = document.getElementById('layer-control-tracks-section');
            if (tracksSection) {
                if (isMapView) {
                    tracksSection.style.display = 'block';
                } else {
                    tracksSection.style.display = 'none';
                }
            }
            
            // Update ranking filter chips on initial load if ranking view is active
            if (isRankingView) {
                updateRankingFilterChips();
            }
        });
        
        // Update sub-group chips after HTMX reload of ranking content
        document.addEventListener('htmx:afterSwap', function(event) {
            if (event.detail && event.detail.target && event.detail.target.id === 'ranking-content') {
                // Ranking content was reloaded - update sub-group chips for expanded groups
                var expandedTopGroups = window.expandedTopGroups || new Set();
                expandedTopGroups.forEach(function(groupId) {
                    var topChip = document.querySelector('[data-group-id="' + groupId + '"]');
                    if (topChip && topChip.classList.contains('active')) {
                        // Re-show sub-groups for this expanded group
                        var container = document.getElementById('filter-chips-container');
                        if (container) {
                            // Remove existing sub-group row if any
                            var existingRow = document.getElementById('sub-groups-' + groupId);
                            if (existingRow) {
                                existingRow.remove();
                            }
                            // Re-show sub-groups
                            showSubGroups(groupId, container, topChip);
                        }
                    }
                });
            }
        });
    </script>

</body>
</html>
