<!-- Copyright (c) 2026 SAI-Lab / MyCyclingCity
     SPDX-License-Identifier: AGPL-3.0-or-later
     
     @file    kiosk_leaderboard.html
     @author  Roland Rutz
     @note    This code was developed with the assistance of AI (LLMs).
-->

{% load i18n l10n %}
{% get_current_language as LANGUAGE_CODE %}
<!DOCTYPE html>
<html lang="{{ LANGUAGE_CODE }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% trans "Kiosk Leaderboard" %}</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-geometryutil@0.10.3/src/leaflet.geometryutil.min.js"></script>
    <style>
        @keyframes pulse-ring {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .pulse-ring {
            animation: pulse-ring 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        .trophy-badge {
            transform: rotate(12deg);
        }
        .progress-bar {
            height: 2px;
            transition: width 0.1s linear;
        }
        @keyframes marquee {
            0% { transform: translateX(100vw); }
            100% { transform: translateX(-100%); }
        }
        .ticker-wrapper {
            width: 100%;
            overflow: hidden;
            position: relative;
        }
        .ticker-marquee {
            display: inline-flex;
            will-change: transform;
            white-space: nowrap;
            animation: marquee 30s linear infinite;
        }
        .ticker-marquee > * {
            flex-shrink: 0;
        }
        .ticker-marquee:hover {
            animation-play-state: paused;
        }
        #ticker-content {
            display: inline-flex;
            white-space: nowrap;
        }

        /* ============================================
           Mobile-Only Overrides (max-width: 1023px)
           Protects Kiosk Mode - Desktop remains untouched
           ============================================ */
        @media screen and (max-width: 1023px) {
            /* Root Scaling: Scale up all rem-based elements for mobile */
            html {
                font-size: 110%; /* Scales all rem-based elements up */
            }

            /* Typography: Ensure minimum readable size for mobile */
            body {
                font-size: 16px; /* Minimum readable size for mobile */
                line-height: 1.5;
            }

            /* Map optimization: Full height with absolute positioning to remove white gap */
            #map {
                height: 100vh !important; /* Full height */
                width: 100vw !important;
                position: absolute;
                top: 0;
                left: 0;
                margin: 0;
                padding: 0;
            }

            /* Map view: Full screen on mobile */
            #map-view {
                overflow: hidden;
            }

            /* Leaderboard view: Enable scrolling on mobile */
            #leaderboard-view {
                overflow-y: auto;
                overflow-x: hidden;
            }

            /* Ticker: Adjust height for mobile */
            .h-\[5vh\] {
                min-height: 40px;
            }

            /* Banner: Adjust height for mobile */
            .h-\[15vh\] {
                min-height: 80px;
            }

            /* Main content: Better mobile layout */
            #leaderboard-content {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Footer: Adjust height for mobile */
            .h-\[5vh\] {
                min-height: 40px;
            }

            /* Touch targets: Increase size for buttons and interactive elements */
            button, a, select, input {
                min-height: 44px; /* Touch-friendly minimum height */
                min-width: 44px;
                padding: 15px 25px; /* Larger padding for better touch targets */
                font-size: 16px; /* Ensure readable text */
            }

            /* Ticker text: Better mobile readability */
            .ticker-marquee {
                font-size: 16px; /* Increased from 14px for better readability */
            }

            /* Banner content: Better mobile padding */
            .px-6 {
                padding-left: 20px; /* Increased padding */
                padding-right: 20px;
            }

            /* Small text blocks and labels: Ensure minimum readable size */
            label, .text-sm {
                font-size: 14px; /* Minimum readable size for labels */
            }
        }
    </style>
</head>
<body class="h-screen overflow-hidden bg-slate-900 text-white">
    <!-- View Container -->
    <div id="view-container" class="h-full w-full relative">
        <!-- Map View (hidden by default, shown via rotation) -->
        <div id="map-view" class="h-full w-full" style="display: none;">
            <!-- Map container - Leaflet map will be initialized here -->
            <div id="map" style="width: 100%; height: 100%;"></div>
        </div>
        
        <!-- Leaderboard View -->
        <div id="leaderboard-view" class="h-full w-full flex flex-col">
            <!-- Top Layer: Ticker (5vh) -->
            <div class="h-[5vh] bg-yellow-400 text-black border-b-2 border-yellow-600 overflow-hidden relative">
                <div class="ticker-wrapper h-full">
                    <div class="ticker-marquee whitespace-nowrap text-lg font-bold">
                        <div id="ticker-content"
                             hx-get="{% url 'kiosk_leaderboard' %}?ticker_only=true{% if current_filter %}&group={{ current_filter|urlencode }}{% endif %}{% if sort_by %}&sort={{ sort_by|urlencode }}{% endif %}"
                             hx-trigger="every {{ KIOSK_TICKER_UPDATE_INTERVAL }}s"
                             hx-swap="innerHTML"
                             hx-target="this">
                            {% include 'map/partials/kiosk_ticker.html' %}
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Header: Parent Group Banner (15vh) -->
            <div class="h-[15vh] bg-gradient-to-r from-slate-800 to-slate-900 border-b border-slate-700 flex items-center justify-center relative overflow-hidden px-6">
                <div id="banner-content"
                     hx-get="{% url 'kiosk_leaderboard' %}?banner_only=true{% if current_filter %}&group={{ current_filter|urlencode }}{% endif %}{% if sort_by %}&sort={{ sort_by|urlencode }}{% endif %}"
                     hx-trigger="every {{ KIOSK_BANNER_UPDATE_INTERVAL }}s"
                     hx-swap="innerHTML"
                     hx-target="this">
                    {% include 'map/partials/kiosk_banner.html' %}
                </div>
            </div>
            
            <!-- Main: Group Grid (75vh) -->
            <div id="leaderboard-content" class="flex-1 overflow-hidden" 
                 hx-get="{% url 'kiosk_leaderboard' %}{% if current_filter %}?group={{ current_filter|urlencode }}{% endif %}{% if sort_by and sort_by != 'daily' %}{% if current_filter %}&{% else %}?{% endif %}sort={{ sort_by|urlencode }}{% endif %}" 
                 hx-trigger="every {{ KIOSK_CONTENT_UPDATE_INTERVAL }}s, tickerCyclistCountChanged from:body" 
                 hx-swap="innerHTML" 
                 hx-target="this">
                {% include 'map/partials/kiosk_leaderboard_content.html' %}
            </div>
            
            <!-- Footer: Statistics (5vh) -->
            <div class="h-[5vh] bg-slate-800 border-t border-slate-700"
                 id="leaderboard-footer"
                 hx-get="{% url 'kiosk_leaderboard' %}?footer_only=true{% if current_filter %}&group={{ current_filter|urlencode }}{% endif %}{% if sort_by %}&sort={{ sort_by|urlencode }}{% endif %}"
                 hx-trigger="every {{ KIOSK_FOOTER_UPDATE_INTERVAL }}s, tickerCyclistCountChanged from:body"
                 hx-swap="innerHTML"
                 hx-target="this">
                {% include 'map/partials/kiosk_leaderboard_footer.html' %}
            </div>
        </div>
    </div>
    
    <!-- Progress Bar (2px at bottom) -->
    <div class="fixed bottom-0 left-0 right-0 h-0.5 bg-slate-700">
        <div id="progress-bar" class="progress-bar bg-blue-600 h-full" style="width: 0%"></div>
    </div>
    
    <script>
        // Check URL parameter for initial view
        const urlParams = new URLSearchParams(window.location.search);
        const viewParam = urlParams.get('view');
        const startWithLeaderboard = viewParam === 'leaderboard';
        
        // View rotation logic
        let currentView = startWithLeaderboard ? 'leaderboard' : 'map'; // 'leaderboard' or 'map'
        let rotationInterval = 60000; // 60 seconds
        let progressInterval = null;
        let isPaused = false;
        let timeRemaining = rotationInterval;
        
        const mapView = document.getElementById('map-view');
        const leaderboardView = document.getElementById('leaderboard-view');
        const progressBar = document.getElementById('progress-bar');
        const manualModeBadge = document.getElementById('manual-mode-badge');
        
        // Initialize view based on URL parameter
        if (startWithLeaderboard) {
            // Start with leaderboard - hide map immediately
            mapView.style.display = 'none';
            mapView.classList.add('hidden');
            leaderboardView.style.display = 'flex';
            leaderboardView.classList.remove('hidden');
            currentView = 'leaderboard';
        } else {
            // Start with map - hide leaderboard
            mapView.style.display = 'block';
            mapView.classList.remove('hidden');
            leaderboardView.style.display = 'none';
            leaderboardView.classList.add('hidden');
            currentView = 'map';
        }
        
        function switchView() {
            if (currentView === 'leaderboard') {
                mapView.style.display = 'block';
                mapView.classList.remove('hidden');
                leaderboardView.style.display = 'none';
                leaderboardView.classList.add('hidden');
                currentView = 'map';
                // Initialize map if not already done
                if (!mapInitialized) {
                    setTimeout(initializeMap, 100);
                } else if (mapInstance) {
                    // Invalidate size to fix map display after being hidden
                    setTimeout(() => mapInstance.invalidateSize(), 100);
                }
            } else {
                mapView.style.display = 'none';
                mapView.classList.add('hidden');
                leaderboardView.style.display = 'flex';
                leaderboardView.classList.remove('hidden');
                currentView = 'leaderboard';
            }
            resetTimer();
        }
        
        function resetTimer() {
            timeRemaining = rotationInterval;
            updateProgressBar();
            
            // Restart the interval if not paused
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
            if (!isPaused) {
                startRotation();
            }
        }
        
        function updateProgressBar() {
            const percentage = ((rotationInterval - timeRemaining) / rotationInterval) * 100;
            progressBar.style.width = percentage + '%';
        }
        
        function startRotation() {
            if (isPaused) return;
            
            progressInterval = setInterval(() => {
                if (!isPaused) {
                    timeRemaining -= 100;
                    updateProgressBar();
                    
                    if (timeRemaining <= 0) {
                        switchView();
                    }
                }
            }, 100);
        }
        
        function pauseRotation() {
            isPaused = !isPaused;
            if (isPaused) {
                // Show manual mode badge in footer
                if (manualModeBadge) {
                    manualModeBadge.classList.remove('hidden');
                }
                if (progressInterval) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
            } else {
                // Hide manual mode badge
                if (manualModeBadge) {
                    manualModeBadge.classList.add('hidden');
                }
                startRotation();
            }
        }
        
        // Ticker animation - ensure seamless scrolling
        function duplicateTickerContent() {
            const tickerContent = document.getElementById('ticker-content');
            const tickerMarquee = document.querySelector('.ticker-marquee');
            if (tickerContent && tickerMarquee) {
                // Remove all existing duplicates
                const existingDuplicates = tickerMarquee.querySelectorAll('#ticker-content-duplicate');
                existingDuplicates.forEach(dup => dup.remove());
                
                // Create duplicate to ensure seamless infinite scroll
                const duplicate = tickerContent.cloneNode(true);
                duplicate.id = 'ticker-content-duplicate';
                duplicate.removeAttribute('hx-get');
                duplicate.removeAttribute('hx-trigger');
                duplicate.removeAttribute('hx-swap');
                duplicate.removeAttribute('hx-target');
                // Insert duplicate right after the original content
                tickerMarquee.insertBefore(duplicate, tickerContent.nextSibling);
            }
        }
        
        // Track active cyclist count to detect changes
        let previousActiveCyclistCount = -1;  // Use -1 to force initial update
        
        function countActiveCyclistsInTicker() {
            const tickerContent = document.getElementById('ticker-content');
            if (!tickerContent) return 0;
            
            // Count ticker items (each cyclist is in a ticker-item span)
            const tickerItems = tickerContent.querySelectorAll('.ticker-item');
            // Filter out the "Ready to start" message
            let count = 0;
            tickerItems.forEach(item => {
                const text = item.textContent || '';
                // If it contains "Ready to start" or similar, don't count it
                // Also check if it contains a user_id (which would be in <strong> tags)
                const hasUserId = item.querySelector('strong');
                if (hasUserId && !text.includes('Ready to start') && !text.includes('Bereit zum Start')) {
                    count++;
                }
            });
            return count;
        }
        
        // Initialize cyclist count on page load
        previousActiveCyclistCount = countActiveCyclistsInTicker();
        
        // Duplicate content after HTMX updates to ensure seamless animation
        document.body.addEventListener('htmx:afterSwap', function(event) {
            if (event.target.id === 'ticker-content') {
                // Wait a bit to ensure content is rendered
                requestAnimationFrame(() => {
                    duplicateTickerContent();
                    
                    // Check if active cyclist count has changed
                    const currentActiveCyclistCount = countActiveCyclistsInTicker();
                    if (currentActiveCyclistCount !== previousActiveCyclistCount) {
                        // Cyclist count changed - trigger immediate update of footer and content
                        const oldCount = previousActiveCyclistCount;
                        previousActiveCyclistCount = currentActiveCyclistCount;
                        
                        // Dispatch custom event to trigger updates
                        const updateEvent = new CustomEvent('tickerCyclistCountChanged', {
                            bubbles: true,
                            detail: { 
                                previousCount: oldCount,
                                currentCount: currentActiveCyclistCount 
                            }
                        });
                        document.body.dispatchEvent(updateEvent);
                    }
                });
            }
        });
        
        // Initial duplicate on page load and initialize cyclist count
        function initializeTicker() {
            setTimeout(() => {
                duplicateTickerContent();
                // Initialize cyclist count after content is duplicated
                previousActiveCyclistCount = countActiveCyclistsInTicker();
            }, 100);
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeTicker);
        } else {
            initializeTicker();
        }
        
        // Dynamic banner group visibility based on viewport width
        function adjustBannerGroups() {
            const bannerContainer = document.getElementById('banner-groups');
            if (!bannerContainer) return;
            
            const groups = bannerContainer.querySelectorAll('.banner-group-item');
            if (groups.length === 0) return;
            
            // Get the parent container (the banner div)
            const bannerParent = bannerContainer.parentElement;
            if (!bannerParent) return;
            
            // Reset all groups to visible first
            groups.forEach(group => {
                group.style.display = '';
            });
            
            // Force a reflow to get accurate measurements
            bannerContainer.offsetHeight;
            
            // Get actual container dimensions
            const containerRect = bannerParent.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerLeft = containerRect.left;
            const containerRight = containerRect.right;
            
            // Get container padding
            const containerStyle = window.getComputedStyle(bannerParent);
            const paddingLeft = parseFloat(containerStyle.paddingLeft) || 0;
            const paddingRight = parseFloat(containerStyle.paddingRight) || 0;
            
            // Calculate trophy badge space more accurately
            const trophyBadge = document.querySelector('.trophy-badge');
            let badgeRightSpace = 0;
            if (trophyBadge) {
                const badgeRect = trophyBadge.getBoundingClientRect();
                const containerRect = bannerParent.getBoundingClientRect();
                // Calculate space from left edge of badge to right edge of container
                const badgeLeft = badgeRect.left;
                const badgeRight = badgeRect.right;
                const containerRight = containerRect.right;
                // Space needed: from container right edge to badge left edge, plus badge width, plus extra margin
                badgeRightSpace = containerRight - badgeLeft + 32; // 32px extra margin for safety
            }
            
            // Available width: container width minus badge space minus both paddings
            // No extra margin needed since groups start from left (justify-start)
            const availableWidth = containerWidth - badgeRightSpace - paddingLeft - paddingRight;
            const gap = 24; // gap-6 = 1.5rem = 24px
            
            // Measure all groups and hide from right to left
            let totalWidth = 0;
            const visibleGroups = [];
            
            // Go from left to right and collect groups that fit
            for (let i = 0; i < groups.length; i++) {
                const group = groups[i];
                const groupWidth = group.offsetWidth;
                const neededWidth = totalWidth + groupWidth + (totalWidth > 0 ? gap : 0);
                
                // Add a larger safety margin (16px) to prevent edge cases and ensure groups don't overlap badge
                // This accounts for rounding errors and ensures groups stay well clear of the badge
                if (neededWidth + 16 <= availableWidth) {
                    totalWidth = neededWidth;
                    visibleGroups.push(i);
                } else {
                    break; // Stop when we find a group that doesn't fit
                }
            }
            
            // Hide all groups that don't fit
            groups.forEach((group, index) => {
                if (!visibleGroups.includes(index)) {
                    group.style.display = 'none';
                }
            });
        }
        
        // Adjust banner groups on load and resize
        function initBannerGroups() {
            // Wait a bit longer to ensure badge is fully rendered
            setTimeout(adjustBannerGroups, 150);
            window.addEventListener('resize', function() {
                setTimeout(adjustBannerGroups, 100);
            });
        }
        
        // Initialize on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initBannerGroups);
        } else {
            initBannerGroups();
        }
        
        // Adjust after HTMX updates
        document.body.addEventListener('htmx:afterSwap', function(event) {
            if (event.target.id === 'leaderboard-view' || event.target.closest('#leaderboard-view')) {
                // Wait longer after HTMX swap to ensure badge is rendered
                setTimeout(adjustBannerGroups, 150);
            }
        });
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.key === ' ') {
                e.preventDefault();
                // Toggle view and restart timer to exactly 60 seconds
                switchView();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                // Also toggle view and restart timer
                switchView();
            } else if (e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                pauseRotation();
            }
        });
        
        // Map initialization (only once, state preserved via display:none)
        let mapInstance = null;
        let mapInitialized = false;
        
        function initializeMap() {
            if (mapInitialized) return;
            
            const mapElement = document.getElementById('map');
            if (!mapElement) return;
            
            // Initialize Leaflet map
            mapInstance = L.map('map').setView([51.16, 10.45], 6);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapInstance);
            
            // Add tracks
            const tracks = {{ tracks_json|safe }};
            const trackLayers = L.featureGroup().addTo(mapInstance);
            const trackStartEndMarkers = L.layerGroup().addTo(mapInstance); // Markers for start and end of tracks
            tracks.forEach(function(t) {
                if (t.points && t.points.length > 0) {
                    L.polyline(t.points, {color: '#007bff', weight: 6, opacity: 0.5}).addTo(trackLayers);
                    
                    // Add start and end markers (flags) for each track
                    const startPoint = t.points[0];
                    const endPoint = t.points[t.points.length - 1];
                    
                    // Start marker (green flag)
                    const startIcon = L.divIcon({
                        className: 'start-marker',
                        html: '<div style="font-size: 30px; line-height: 1;">üö©</div>',
                        iconSize: [30, 30],
                        iconAnchor: [15, 30]
                    });
                    const startMarker = L.marker([startPoint[0], startPoint[1]], {
                        icon: startIcon,
                        title: 'Start: ' + t.name
                    }).addTo(trackStartEndMarkers);
                    startMarker.bindPopup('<strong>Start</strong><br>' + t.name);
                    
                    // End marker (red flag)
                    const endIcon = L.divIcon({
                        className: 'end-marker',
                        html: '<div style="font-size: 30px; line-height: 1;">üèÅ</div>',
                        iconSize: [30, 30],
                        iconAnchor: [15, 30]
                    });
                    const endMarker = L.marker([endPoint[0], endPoint[1]], {
                        icon: endIcon,
                        title: 'Ziel: ' + t.name
                    }).addTo(trackStartEndMarkers);
                    endMarker.bindPopup('<strong>Ziel</strong><br>' + t.name);
                }
            });
            if (tracks.length > 0) mapInstance.fitBounds(trackLayers.getBounds());
            
            // Map size adjustment function - fixes quarter-map issue on mobile
            function adjustMap() {
                if (typeof mapInstance !== 'undefined') {
                    mapInstance.invalidateSize();
                }
            }
            window.addEventListener('resize', adjustMap);
            // Call after CSS changes to fill any gaps
            setTimeout(adjustMap, 500);
            setTimeout(adjustMap, 1000); // Additional call to ensure map fills after CSS is fully applied
            
            // Add devices
            const devices = {{ devices_json|safe }};
            const deviceMarkers = L.layerGroup().addTo(mapInstance);
            devices.forEach(function(d) {
                if (d.lat && d.lon) {
                    const deviceIcon = L.divIcon({
                        className: 'device-marker',
                        html: '<div style="background: #28a745; border: 3px solid #155724; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 18px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">üö≤</div>',
                        iconSize: [30, 30],
                        iconAnchor: [15, 15]
                    });
                    const marker = L.marker([d.lat, d.lon], {icon: deviceIcon}).addTo(deviceMarkers);
                    // Format number based on current language
                    function formatNumberDE(value, decimals) {
                        if (value === null || value === undefined || isNaN(value)) {
                            const lang = document.documentElement.lang || 'de';
                            const isGerman = lang.startsWith('de');
                            const decimalSep = isGerman ? ',' : '.';
                            return '0' + (decimals > 0 ? decimalSep + '0'.repeat(decimals) : '');
                        }
                        const num = parseFloat(value);
                        const fixed = num.toFixed(decimals || 2);
                        const parts = fixed.split('.');
                        const integerStr = parts[0];
                        const decimalPart = parts[1] || '';
                        
                        // Get language from HTML lang attribute
                        const lang = document.documentElement.lang || 'de';
                        const isGerman = lang.startsWith('de');
                        
                        // Add thousands separators
                        let integerWithSeparators = '';
                        for (let i = 0; i < integerStr.length; i++) {
                            if (i > 0 && (integerStr.length - i) % 3 === 0) {
                                integerWithSeparators += isGerman ? '.' : ',';
                            }
                            integerWithSeparators += integerStr[i];
                        }
                        
                        // Add decimal separator
                        if (decimalPart) {
                            return integerWithSeparators + (isGerman ? ',' : '.') + decimalPart;
                        }
                        return integerWithSeparators;
                    }
                    let popupContent = '<strong>{% trans "Ger√§t" %}: ' + d.name + '</strong><br>{% trans "Gesamt" %}: ' + formatNumberDE(d.distance_total, 2) + ' km';
                    if (d.last_active) {
                        popupContent += '<br>{% trans "Zuletzt aktiv" %}: ' + new Date(d.last_active).toLocaleString('de-DE');
                    }
                    marker.bindPopup(popupContent);
                }
            });
            
            // Add milestones
            const milestones = {{ milestones_json|safe }};
            const milestoneMarkers = L.layerGroup().addTo(mapInstance);
            milestones.forEach(function(m) {
                if (m.lat && m.lon) {
                    const isTarget = (m.name && (m.name.toLowerCase().includes('ziel') || m.name.toLowerCase().includes('target'))) ||
                                   (m.track_total_length_km && Math.abs(m.track_total_length_km - (m.km || 0)) < 0.1);
                    const isReached = m.is_reached || false;
                    const bgColor = isTarget ? (isReached ? '#28a745' : '#20c997') : (isReached ? '#28a745' : '#ffd700');
                    const borderColor = isTarget ? (isReached ? '#155724' : '#17a2b8') : (isReached ? '#1e7e34' : '#ff8c00');
                    const iconEmoji = isTarget ? 'üèÅ' : (isReached ? '‚úÖ' : 'üèÜ');
                    
                    const milestoneIcon = L.divIcon({
                        className: 'milestone-marker',
                        html: '<div style="background: ' + bgColor + '; border: 3px solid ' + borderColor + '; border-radius: ' + (isTarget ? '8px' : '50%') + '; width: ' + (isTarget ? '40px' : '30px') + '; height: ' + (isTarget ? '40px' : '30px') + '; display: flex; align-items: center; justify-content: center; font-size: ' + (isTarget ? '24px' : '18px') + '; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transform: ' + (isTarget ? 'rotate(-5deg)' : 'none') + ';">' + iconEmoji + '</div>',
                        iconSize: [isTarget ? 40 : 30, isTarget ? 40 : 30],
                        iconAnchor: [isTarget ? 20 : 15, isTarget ? 20 : 15]
                    });
                    const marker = L.marker([m.lat, m.lon], {icon: milestoneIcon}).addTo(milestoneMarkers);
                    let popupContent = '<strong>' + (isTarget ? 'üèÅ ' + m.name : m.name) + '</strong><br>' + formatNumberDE(m.km, 1) + ' km';
                    if (m.text) popupContent += '<br><em>' + m.text + '</em>';
                    if (isReached && m.winner_group_name) {
                        popupContent += '<br><strong>{% trans "Erreicht von" %}: ' + m.winner_group_name + '</strong>';
                    }
                    marker.bindPopup(popupContent);
                }
            });
            
            mapInitialized = true;
        }
        
        // Initialize rotation
        if (!startWithLeaderboard) {
            startRotation();
            // Initialize map immediately if starting with map view
            setTimeout(initializeMap, 100);
        } else {
            // If starting with leaderboard, still start the timer
            startRotation();
        }
    </script>
</body>
</html>


